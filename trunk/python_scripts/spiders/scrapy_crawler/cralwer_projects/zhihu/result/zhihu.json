[
{"title": "如何入门 Python 爬虫？", "description": "嘛”，让一众小白菜鸟一脸懵逼。。作为一个0起步（之前连python都不会），目前总算掌握基础，开始向上进阶的菜鸟，深知其中的不易，所以我会在这个回答里", "article": "看了大部分回答不禁叹口气，主要是因为看到很多大牛在回答像“如何入门爬虫”这种问题的时候，一如当年学霸讲解题目，跳步无数，然后留下一句“不就是这样推嘛”，让一众小白菜鸟一脸懵逼。。作为一个0起步（之前连python都不会），目前总算掌握基础，开始向上进阶的菜鸟，深知其中的不易，所以我会在这个回答里，尽可能全面、细节地分享给大家从0学习爬虫的各种步骤，如果对你有帮助，请点赞~\n-------------------------------------------------------------------------------------------------\n#我要写爬虫！\n \n#Ver.1.2 \n \n#Based on: Python 2.7\n#Author:高野良\n#\n原创内容，转载请注明出处\n首先！你要对爬虫有个明确的认识，这里引用毛主席的思想：\n在战略上藐视：\n \n“所有网站皆可爬”：\n互联网的内容都是人写出来的，而且都是偷懒写出来的（不会第一页是a，下一页是8），所以肯定有规律，这就给人有了爬取的可能，可以说，天下没有不能爬的网站\n“框架不变”：\n网站不同，但是原理都类似，大部分爬虫都是从 \n发送请求——获得页面——解析页面——下载内容——储存内容\n 这样的流程来进行，只是用的工具不同\n在战术上重视：\n \n持之以恒，戒骄戒躁：\n对于初学入门，不可轻易自满，以为爬了一点内容就什么都会爬了，爬虫虽然是比较简单的技术，但是往深学也是没有止境的（比如搜索引擎等）！只有不断尝试，刻苦钻研才是王道！（为何有种小学作文即视感）\n                              ||\n                                ||\n                                V\n然后，你需要一个宏伟的目标，来让你有持续学习的动力（没有实操项目，真的很难有动力）\n我要爬整个豆瓣！...\n我要爬整个草榴社区！\n我要爬知乎各种妹子的联系方式*&^#%^$#\n                              ||\n                                ||\n                                V\n接着，你需要扪心自问一下，自己的python基本功吼不吼啊？\n吼啊！\n——OK，开始欢快地学习爬虫吧 ！\n不吼？你还需要学习一个！\n赶紧回去看廖雪峰老师的教程，\n2.7的。至少\n这些功能和语法\n你要有基本的掌握 ：\nlist，dict：\n用来序列化你爬的东西\n切片：\n用来对爬取的内容进行分割，生成\n条件判断（if等）：\n用来解决爬虫过程中哪些要哪些不要的问题\n循环和迭代（for while ）：\n用来循环，重复爬虫动作\n文件读写操作（open，close等）：\n用来读取参数、保存爬下来的内容等\n编码常识（codecs等）：\n非常关键，爬虫写熟了以后遇到的各种古怪问题，很多来自于UTF-8 GBK等奇奇怪怪的编码！这个问题先做了解，后面调试时候再解决也不迟！\n                              ||\n                                ||\n                                V\n然后，你需要补充一下下面几个内容，作为你的知识储备：\n（注：这里并非要求“掌握”，下面讲的两点，只需要先了解，然后通过具体项目来不断实践，直到熟练掌握）\n1、网页的基本知识：\n基本的HTML语言知识（知道href等大学计算机一级内容即可）\n理解网站的发包和收包的概念（POST GET）\n稍微一点点的js知识，用于理解动态网页（当然如果本身就懂当然更好啦）\n2、一些分析语言，为接下来解析网页内容做准备\nNO.1  正则表达式：扛把子技术，总得会最基础的：\nNO.2  XPATH：高效的分析语言，表达清晰简单，掌握了以后基本可以不用正则\n参考：\nXPath 教程\n \nNO.3  Beautifulsoup：\n美丽汤模块解析网页神器,一款神器，如果不用一些爬虫框架（如后文讲到的scrapy），配合request，urllib等模块（后面会详细讲），可以编写各种小巧精干的爬虫脚本\n官网文档：\nBeautiful Soup 4.2.0 文档\n \n参考案例：\n \n                              ||\n                              ||\n                              V\n接着，你需要一些高效的工具来辅助\n（同样，这里先了解，到具体的项目的时候，再熟悉运用）\nNO.1   F12 开发者工具：\n \n看源代码：快速定位元素\n分析xpath：1、此处建议谷歌系浏览器,可以在源码界面直接右键看\nNO.2  抓包工具：\n \n推荐httpfox，火狐浏览器下的插件,比谷歌火狐系自带的F12工具都要好，可以方便查看网站收包发包的信息\nNO.3  XPATH CHECKER (火狐插件）：\n非常不错的xpath测试工具，但是有几个坑，都是个人踩过的，，在此告诫大家：\n     1、xpath checker生成的是绝对路径，遇到一些动态生成的图标（常见的有列表翻页按钮等），飘忽不定的绝对路径很有可能造成错误，所以这里建议在真正分析的时候，只是作为参考\n     2、记得把如下图xpath框里的“x:”去掉，貌似这个是早期版本xpath的语法，目前已经和一些模块不兼容（比如scrapy），还是删去避免报错\nNO.4  正则表达测试工具：\n \n在线正则表达式测试\n ，拿来多练练手，也辅助分析！里面有很多现成的正则表达式可以用，也可以进行参考！\n                              ||\n                              ||\n                              V\nok！这些你都基本有一些了解了，现在开始进入抓取时间，上各种模块吧！python的火，很大原因就是各种好用的模块，这些模块是居家旅行爬网站常备的——\nurllib\nurllib2\nrequests\n                              ||\n                              ||\n                              V\n不想重复造轮子，有没有现成的框架？\n华丽丽的scrapy(这块我会重点讲，我的最爱）\n||\n||\nV\n遇到动态页面怎么办？\nselenium（会了这个配合scrapy无往不利，是居家旅行爬网站又一神器，下一版更新的时候会着重安利，因为这块貌似目前网上的教程还很少）\nphantomJS（不显示网页的selenium）\n||\n||\nV\n遇到反爬虫策略验证码之类咋整？（不想折腾的直接第四个）\nPIL\nopencv\npybrain\n打码平台\n||\n||\nV\n然后是数据库，这里我认为开始并不需要非常深入，在需要的时候再学习即可\nmysql\nmongodb\nsqllite\n||\n||\nV\n爬来的东西怎么用？\nnumpy 数据分析，类似matlab的模块\npandas（基于numpy的数据分析模块，相信我，如果你不是专门搞TB级数据的，这个就够了）\n||\n||\nV\n进阶技术\n多线程、分布式\n———————————— 乱入的分割线 —————————————\n然后学习编程关键的是学以致用，天天捧一本书看不如直接上手操练，下面我通过实际的例子来讲解爬虫——\n比如最近，楼主在豆瓣上认识了一个很可爱的妹子，发现她一直会更新签名和日志，所以没事就会去她主页看看，但一直没有互相加好友（作为一只高冷的天蝎，怎么可以轻易加好友嘛！而且加了好友，你更新什么都会收到推送，那多没意思啊！一点神秘感都没有了！），可还是想及时获得妹子的最新动态，怎么办？\n于是我就写了个70几行的python脚本，包含爬虫+邮件模块，跑在家里的一台闲置笔记本上，通过计划任务每准点抓取妹子的签名和最新文章一次，发送到我的邮箱。。嗯，其实是很简单的技术，，代码如下所示：\n#-*-coding:utf-8-*- #编码声明，不要忘记！\n\n\nimport\n \nrequests\n  \n#这里使用requests，小脚本用它最合适！\n\n\nfrom\n \nlxml\n \nimport\n \nhtml\n    \n#这里我们用lxml，也就是xpath的方法\n\n\n\n#豆瓣模拟登录，最简单的是cookie，会这个方法，80%的登录网站可以搞定\n\n\ncookie\n \n=\n \n{}\n \n\n\nraw_cookies\n \n=\n \n''\n#引号里面是你的cookie，用之前讲的抓包工具来获得\n\n\n\nfor\n \nline\n \nin\n \nraw_cookies\n.\nsplit\n(\n';'\n):\n\n    \nkey\n,\nvalue\n \n=\n \nline\n.\nsplit\n(\n\"=\"\n,\n \n1\n)\n\n    \ncookie\n[\nkey\n]\n \n=\n \nvalue\n \n#一些格式化操作，用来装载cookies\n\n\n\n#重点来了！用requests，装载cookies，请求网站\n\n\npage\n \n=\n \nrequests\n.\nget\n(\n'#妹纸的豆瓣主页#'\n,\ncookies\n=\ncookie\n)\n\n\n\n#对获取到的page格式化操作，方便后面用XPath来解析\n\n\ntree\n \n=\n \nhtml\n.\nfromstring\n(\npage\n.\ntext\n)\n\n\n\n#XPath解析，获得你要的文字段落！\n\n\nintro_raw\n \n=\n \ntree\n.\nxpath\n(\n'//span[@id=\"intro_display\"]/text()'\n)\n\n\n\n#简单的转码工作，这步根据需要可以省略\n\n\nfor\n \ni\n \nin\n \nintro_raw\n:\n\n    \nintro\n \n=\n \ni\n.\nencode\n(\n'utf-8'\n)\n\n\n\nprint\n \nintro\n \n#妹子的签名就显示在屏幕上啦\n\n\n\n#接下来就是装载邮件模块，因为与本问题关联不大就不赘述啦~\n\n\n\n\n怎么样~是不是很简单~\nV1.2更新日志：\n修改了一些细节和内容顺序"},
{"title": "Python爬虫告诉你上海房价有多高", "description": "最近用Python爬取了贝壳上7万多套上海的在售房源，7万多套房源是目前贝壳上正在挂牌出售的房源，覆盖了上海各个区县。我们对这7万多套房源做一下分析，来真实地感受一下上海的房价到底有多高", "article": "最近用Python爬取了贝壳上7万多套上海的在售房源，7万多套房源是目前贝壳上正在挂牌出售的房源，覆盖了上海各个区县。我们对这7万多套房源做一下分析，来真实地感受一下上海的房价到底有多高。\n爬虫思路\n首先介绍一下我们这个爬虫的思路。贝壳网上的房源按照区县、版块做了划分，如下\n我们首先获取所有的区和版块数据。\n然后对于每一个版块，爬取版块内的所有房源数据。每一套房源的数据除了单价总价外还包括小区名字、户型、面积、朝向、装修、电梯、楼层等，如下图\n爬取的数据存入MongoDB。爬取完所有的数据后，我们从MongoDB读取数据并做分析。\n代码这里不详细展开，文末会给出获取方式。\n房源数据分析\n爬取完所有房源数据后，我们来对数据做一下分析。\n本次共爬取挂牌在售的房源总数\n72994\n套，在售房源的平均售价是\n531万\n/套，平均单价是\n56000元\n/平米。\n按照区县划分，每个区的在售房源的分布如下：\n可以看到浦东新区作为上海第一大区，挂牌在售的房源数量也是最多的。\n上海各个区县的均价如下图：\n静安、黄浦两个区位于上海的市中心，房价也最高，都超过了9万/平米，长宁、徐汇紧随其后，单价也超过了7万/平米。这4个区也是上海高端商业区、高端写字楼密集的地方，商场上档次，生活有品位，在这里拥有一套住房也成为了身份的象征。房价最低的是金山区，地处上海偏远的郊县，虽然也属于上海，但每次去金山都有一种出差的感觉。\n下面是上海单价最贵的十大小区\n可以看到大多数都集中在静安、黄浦、徐汇、长宁这4个区。浦东有一个小区入围，那是曾经全上海最贵的汤臣一品，如今在最贵的名单里也只能排在第7了。\n最后我们来欣赏一下上海的那些最贵的顶级豪宅的房价\n总价里的零是不是数不过来了？每一套都在1亿以上。豪宅的名字也很有趣，都是什么庄园、什么山庄之类的。\n我们来欣赏一下豪宅庄园的图片\n看了是不是很喜欢？是不是很动心？\n那么月薪1万，如何才能买得起这样的豪宅呢？\n不要急，一步步来。先设定一个小目标，比如：先活他个500年。\n爬虫代码已上传github，如需代码，可在公众号【\nPython与数据分析\n】后台回复“房价”获取代码地址。"},
{"title": "为什么人工智能用 Python？", "description": "因为脚本语言写起来简单容易。 Python虽然慢但是它只是调用AI接口，真正的计算全是C/C++写好的底层，用Python只是写逻辑，即第一步怎么算，第二步怎么算", "article": "因为脚本语言写起来简单容易。\nPython虽然慢但是它只是调用AI接口，真正的计算全是C/C++写好的底层，用Python只是写逻辑，即第一步怎么算，第二步怎么算，几行代码就出来了。\n换成C++，得先学1个月才能编译通过。不是说用C++写不了上层逻辑，而是代码量太大，开发效率太低，换来总体速度提升1%，不合适。\n计算机语言各有适用性，即C/C++速度快适合底层写算法，Python慢但适合上层写逻辑。两者各自牛逼的特点恰好是对方傻逼的特点。"},
{"title": "给伸手党的福利：Python 新手入门引导", "description": "Head First Python Dive Into Python Python 核心编程 深入理解 Python Python 标准库 Python 编程指南 我们搜集了一些网上的电子书版本", "article": "这是一篇 Python 入门指南，针对那些没有任何编程经验，从零开始学习 Python 的同学。不管你学习的出发点是兴趣驱动、拓展思维，还是工作需要、想要转行，都可以此文作为一个参考。\n在这个信息爆炸的时代，以 “Python入门” 为关键字搜索出的结果成千上万。不少小白选手难免会东一榔头西一棒槌，最终看了很多文章，却仍没跨过新手那道门槛。\n结合自身的学习经验以及与很多自学者的沟通了解，我们整理出一条可操作性较强的自学路线，同时收集了多种形式的 Python 优质学习资源，供诸位尚未入门或刚入门不久的同学参考。\n0. 心态准备\n编程是一门技术，也可说是一门手艺。如同书法、绘画、乐器、雕刻等，技艺纯熟的背后肯定付出了长时间的反复练习。编程的世界浩瀚无边，所以请保持一颗敬畏的心态去学习，认真对待写下的每一行代码，甚至每一个字符。收拾好自己的心态，向着编程的世界出发。\n1. 入门阶段\n第一步至关重要，是关系到初学者从入门到精通还是从入门到放弃。选一条合适的入门道路，并坚持下去。\n1.1 配置 Python 学习环境\nPython2 还是 Python3？\n很多人都在纠结入门应该学 Python2 还是 Python3。这其实不是个问题。我从没听过某个人是 Python2 程序员或 Python3 程序员。二者只是程序不兼容，思想上并无大差别，语法变动也并不多。选择任何一个入手，都没有大影响。\n如果你仍然无法抉择，那请选择 Python3，毕竟这是未来的趋势，参考知乎回答\nPython2 还是 Python3？\n \n应该学习最新版本的 Python 3 还是旧版本的 Python 2？\n编辑器该如何选？\n我推荐 \npycharm 社区版\n，配置简单、功能强大、使用起来省时省心，对初学者友好。并且还是完全免费的！\n社区版地址：\nPyCharm\n其他可以尝试的编辑器：\nidle\n： Python 自带编辑器。如果只是想尽快写出几行代码来，这是最简便的方式。\nvs code\n： \nVisual Studio Code - Code Editing. Redefined\natom\n： \nA hackable text editor for the 21st Century\nSublimeText\n： \nSublime Text - Download\nnotepad++\n： \nNotepad++ Home\n为了让初学者集中更多的精力在写代码这件事情上，所以我们就不推荐 vim 和 Emacs 了。\n操作系统？\nPython 支持现有所有主流操作平台，不管是 windows 还是 mac 还是 linux，都能很好的运行 Python。并且后两者都默认自带 Python 环境。\n1.2 入门教程\n《Crossin的编程教室 - Python 入门》\nCrossin的编程教室 - Python入门\n自认为算得上是最浅显易懂的入门教程，很适合没有任何编程基础的人上手。\n74篇图文教程，从最简单的 Python 安装到基本语法、数据结构、函数、文件操作、网络请求、面向对象等逐步深入。\n对于如何加深对一个知识点的印象，最好的办法就是自己写代码实现一遍。如果还是不懂，那就再来一遍。所以无论你使用什么教程，都请将其中的示例代码全部在电脑上输入并运行，learning by doing！\n配套练习\nCrossin的编程教室 - 基础练习\nCrossin的编程教室 - 在线练习\n课外练习\n《笨办法学Python》\n序言 - [ 笨办法学Python ] - 看云\n这是本很有名的 Python 书籍，但并不适合纯零基础自学。因为其中重实践但不解释，新手很容易看得一头雾水。作为学习同时的辅助倒更合适。\n其他推荐教程\n《父与子的编程之旅》\n 又名 \n《与孩子一起学编程》\n这也是一本非常适合零基础的 Python 入门书籍。喜欢阅读纸质书的同学可以买一本，不少在线书店有售。\n《简明 Python 教程》\n在线阅读：\n简明 Python 教程\n这是一本言简意赅的 Python 入门教程，简单直白，没有废话。适合有过其他语言基础的人快速了解 Python 语法。\n以上是我们推荐的学习材料，主要偏重没有太多编程基础的纯新手。其他也有一些不错的资源，可供不同需求的学习者使用：\n在线文字教程：\n廖雪峰的Python教程\nPython教程\n廖先生的教程涵盖了 Python 知识的方方面面，内容更加系统，有一定深度，有一定基础之后学习会有更多的收获。\n其他入门书籍：\nHead First Python\nDive Into Python\nPython 核心编程\n深入理解 Python\nPython 标准库\nPython 编程指南\n我们搜集了一些网上的电子书版本，放在了网盘里：\n​\nhttps://\npan.baidu.com/s/1ECLky\n交互式学习网站：\ncodecademy\nPython\ncodeschool\n：\nLearn to code by doing | Code School\ncodecademy 与 codeschool 这两个通过互联网学习 Python 的网站均备受好评。不妨去体验一下。\n在线视频课程：\n在线教育网站（Coursera网易云edx课堂腾讯课堂等）有哪些值得推荐的 Python 教程？\n在线教育网站（Coursera、网易云课堂、腾讯课堂等）有哪些值得推荐的 Python 课程？\n2. 提升阶段\n完成入门阶段的基础学习之后，常会陷入一个瓶颈期，通过看教程很难进一步提高编程水平。这时候，需要的是练习，大量的练习。\n可以从书上的例程开始写，再写小程序片段，然后写完整的项目。\n我们收集了一些练习题和网站。可根据自己阶段，选择适合的练习去做。建议最好挑选一两个系列重点完成，而不是到处浅尝辄止。\nCrossin的编程教室 - 每周一坑\n：\n编程教室的公众号每周会放出一道题目供练习，并在下一周讲解。欢迎关注微信公众号，和大家一起提交解答。\n往期题目：\n【每周一坑】三门问题\n【每周一坑】双色球选号器\n【每周一坑】统计英文小说词频\n【每周一坑】特殊回文数\nCrossin的编程教室 - 编程实例\nCrossin的编程教室 - 编程实例\n相对于编程教室基础练习着重于单一知识点，编程实例更注重对知识的融会贯通。\n实验楼\n 提升编程水平从做项目开始\n实验楼 - 在线做实验，高效学编程\nhackerrank\n Python 部分难度循序渐进，符合学习曲线\nhttps://www.\nhackerrank.com/domains/\npython/py-introduction\ncodewar\n 社区型编程练习网站，内容由易到难\nhttps://www.\ncodewars.com/?\nlanguage=python\nleetcode\n 为编程面试准备，对初学者稍难\nLeetCode\n牛客网\n 提供 BAT 等大厂笔试题目\n牛客网-专业IT笔试面试备考平台,最全C++JAVA前端求职题库,全面提升IT编程能力\ncodecombat\n 一边游戏一边编程\nCodeCombat中国 - 中国爱好者的 CodeCombat！在游戏中学习编程\nprojecteuler\n 纯粹的编程练习网站\nhttps://\nprojecteuler.net/archiv\nes\n菜鸟教程100例\n 基于 py2 的基础练习\nhttp://www.\nrunoob.com/python/pytho\nn-100-examples.html\n知乎：Python3.x基础学习资料整理\n \nhttps://\nzhuanlan.zhihu.com/p/24\n249743\n知乎：Python学习路径及练手项目合集\nhttps://\nzhuanlan.zhihu.com/p/23\n561159\n知乎：Python 的练手项目有哪些值得推荐？\nhttps://www.\nzhihu.com/question/2937\n2574\n \n3. 遇到问题怎么办？\n学习的过程中或多或少都会有各种问题出现，不要试着逃避，真的勇士敢于直面惨淡的 BUG。\n第一步肯定是利用好搜索引擎，怎么用也是一门技术活：\n编程初学者如何使用搜索引擎\n第二步，求助于各大同性交友网站（大雾）：\nStackOverflow\nhttp://\nstackoverflow.com/\nv2ex\nhttps://www.\nv2ex.com/\nsegmentfault\nhttps://\nsegmentfault.com/\n4. 过来人的建议\n在初学编程的过程中，你会有各种各样的疑惑，你会遇到各种各样的坑。这时，前人的经验尤为重要，我们整理了一些知乎问题供参考：\n你是如何自学Python的？\nhttps://www.\nzhihu.com/question/2070\n2054\n怎么用最短时间高效而踏实地学习 Python？\nhttps://www.\nzhihu.com/question/2853\n0832\n对于编程零基础，第一个语言是 Python 的人有什么建议？\nhttps://www.\nzhihu.com/question/2278\n5587\nPython 编程，应该养成哪些好的习惯？\nhttps://www.\nzhihu.com/question/2896\n6220\n如何处理 Python 入门难以进步的现象？\nhttps://www.\nzhihu.com/question/2796\n9262\n5. 写在最后\n经过第一步和第二步训练，相信一般的小程序都难不倒你了，你已经在编程的世界里已经迈出了关键的一步。接下来就可以去挑战具体的项目了，爬虫、web开发、数据分析、机器学习等等丰富的世界已经向你敞开，选择一个方向重新出发吧！\n记住：在编程的道路上，没有捷径。\n【\n公众号（Crossin的编程教室）里回复 \n新手\n，获取脱水版资源链接汇总页面。\n】\n教程及练习将持续更新，欢迎关注我们。\n其他文章及回答：\nCrossin：如何用100行Python代码做出魔性声控游戏“八分音符酱”\n学习编程的过程中可能会走哪些弯路，有哪些经验可以参考？\n你是如何自学 Python 的？\nCrossin的编程教室\n微信公众号ID：crossincode\n网站：\ncrossincode.com"},
{"title": "Python和Java二选一该学啥？", "description": "或者很少使用到Java或者Python，来告诉你Java好还是Python好，这是赤裸裸的不负责任。如果这个人用Python并且混得还稍微可以，他一定会告诉你Python好，如果这个人用Java", "article": "声明：这是一篇容易引起撕逼的问答，为了祖国和谐，人民安康，请各位看官尽量理性讨论。正巧我前两天写了一篇 \nJava和Python现在都挺火，我应该怎么选\n 的文章，正好对题，就此回答一波。同时，这篇文章是面向一些初入行的朋友进行一些相对中肯一点的分析和建议而已，虽然有浓厚的个人色彩，但我还是尽量以事实说话，以代码说话，大牛们就不要拿自己的牛逼经验来这里装逼了，当然，你如果非得来跟我撕，哥们儿我奉陪。另外，由于文中以自己所在的机构蜗牛学院所做的一些事情来举例，如果你认为这是软文广告，请止步于此。强哥打广告，都是硬的，软的不来（做了**还要立**的事哥不屑）。好吧，咱们进入正题。\n我先问大家一个问题，为什么中国人用刀叉是很容易上手的一件事情，而外国人用筷子，应该是他们在中国吃饭时最痛苦的一件事情吧。为什么会这样呢？\n其实原因非常简单，当我们学会了一门技术难度要求更高的技能以后，再去降级学习难度更低的技能是非常容易的一件事情，反之则不然。\n这个道理同样适用于我们的学习，强哥对Java和Python都有较为丰富的使用经验，当然，Java的应用经验更丰富，代码量比Python更多一些。正是由于我们丰富的Java经验，当蜗牛学院的软件测试方向需要为学生讲授Python课程时，我们所有的讲师都会被分配任务去研究Python，并完成教案编写，教材编写，案例编写。我们会发现，使用Python是一件非常容易的事情。基本上来说，解决问题的方式，方法，算法，思路，所有的编程语言都一样。我们去学习一门新的编程语言的时候就会容易很多，只需要关注与我们所熟悉的编程语言在语法和使用上存在哪些方面的不同即可。\n那么问题来了，蜗牛学院也要讲授Python，那到底是Python值得学习还是Java呢？\n这里面有三点我必须说破，却很少有人从这个角度来给大家做分析：\n如果一个不懂2-3门编程语言的人，或者很少使用到Java或者Python，来告诉你Java好还是Python好，这是赤裸裸的不负责任。如果这个人用Python并且混得还稍微可以，他一定会告诉你Python好，如果这个人用Java，他一定会告诉你用Java好。如果两个语言都没有用过的键盘侠，他会告诉你语言都是相通的，不要纠结。每一个人都说得好有道理的样子，于是让你无从选择。强哥熟练使用8种以上的编程语言，所以才稍微感觉有点资格，来说一说这两门编程语言。虽然，从我个人的角度在我心目中，编程语言只有两种，第一种是Java/C，第二种是其它。但是我不能通过这种偏激的方式来误导大家。\n我们必须要明白Java和Python的各自定位。Java源自C和C++的技术体系，于1995年推出，定位于给专门的程序员设计大型的复杂分布式应用而设计。而Python是1991年推出（比Java还早）主要面向于系统管理，科研，教育和非程序员群体等。大家一定要理解清楚一个现实，这个世界上并不是只有程序员才需要写程序，还有很多群体需要写程序。比如蜗牛学院在这方面的定位就很清楚：Java开发全栈方向的学生学习Java编程和JavaScript编程，软件测试方向的就业班学员学习Python（因为他们并非专业的程序员群体），而软件测试方向下属的自动化测试开发高级研修班，是Java/Python两个方向同时存在。那你说你觉得哪个更好呢？\nPython比Java早4年出身，但是在国内为什么几乎到2010年之后，Python才逐渐火起来呢？原因很简单，因为我们都太现实了。由于大数据的盛行，由于自动化测试方面的人才需求，以及对于互联网的一些基础应用系统的的开发，企业加大了对Python人才的招聘力度（当然，与Java比还有较大的差距），由于有一门感觉很简单又能赚大钱的编程语言出现了，简直是人类的福音啊，所以火起来了。这一点与近几年虚火很旺的Web前端开发很像，其实绝大部分人没什么技术能力，但是工资却拿得不错。这不是个人的原因，企业也很浮躁，仅此而已，一旦虚火泄了，谁能撑到最后？请各位自行脑补。\n也不知道大家从哪里得来的一些“误导”，觉得Python简单，Java很难，所谓\"人生苦短,我用Python\"之类的。一方面，Python上手的确相对要快一点而已，仅此而已。解决复杂问题时，没有人会觉得难点在使用哪门编程语言上，而是解决这个具体问题的算法思路上。这一点各位务必要拎清这个思路。另外一方面，由于Python近几年的火爆，不排除一些人故意散播一些言论，来误导大家使用Python。这件事情就像这么多年，一直有人觉得学习软件测试要容易一些一样，很多人也是报着通过软件测试进入这个行业，选择了一个自己认为没有难度的领域进入。但是，强哥发现，当3，5年过去了，很多测试人员目前最焦虑的就是，自己技术不够深，在企业当中越来越没有竞争力了。所以最终，还是得硬着头皮研究深层次的测试技术，无论是编程，网络，数据库，协议，还是自动化测试，性能测试等。但是这个过程非常痛苦，就像我说的那样，这个世界上99%的人都会选择一条容易走的大路，因为懒惰，因为恐惧。而成功是属于那1%的人一样。这句话同样适用于编程语言或者技术功底的训练上。\n其实大家如果有过实际的编程经验，我们不妨认真想想，当我们研发一个系统的时候，究竟会用到哪些技术？\n那些什么需求分析，跟测试撕逼，跟客户撕逼，跟老板撕逼的那些烂事我们就不提了。我们就来看看纯技术层面的一些基本要求：数据库，Linux命令，网络协议，接口设计，算法思路，框架，改BUG，编程，前端交互。你应该懂我，利用不同的编程语言编写程序只是研发过程中众多你需要掌握的技术当中的一块而已。其它，与你用哪们编程语言无关，这一点如果你都理解不了，觉得强哥在忽悠你的话，那请自便吧。或者换一个角度，会一门编程语言，而不是完整技术体系，就能当技术大牛的情况，我觉得可能只有在你们家村里可以行得通，因为就你一个人懂。\n当然，以上我们讨论是的纯粹的基于技术定位，你也许可以反驳我说，难道做测试的都得懂编程，难道做Python的都不行？\n这当然不是这样的，任何一个领域都有大神，随着经验的丰富都能够解决很多难题。但是，那是很久以后的事了，我们现在讨论的是，你还在纠结Java还是Python的这件事，毫无疑问，这个时候，你仍然还是一个菜鸟，甚至连门都没入。强哥建议大家，不要因为什么事情简单，所以我要去做，无论是学习编程语言，还是其它，这是最要命的一个出发点，会毁了你的未来。\n下面我给大家列出一段我分别使用Java和Python写的发送一个HTTP协议的一段代码。这段代码收录在强哥今年年底即将出版的一本自动化测试开发的高级教程里面，全书均采用Java进行代码演示，明年，我会有一本几乎一模一样的但是是使用Python进行代码实现的书。之所以能够这样，原因很简单，Java能解决的基本问题，Python也能解决，当然，Python能解决的，Java一样可以。但是在干重活儿方面呢，Java更成熟一些。\nJava的代码，实现Agileone系统的需求提案新增功能：\n// 实现需求提案的新增\npublic void doAdd() {\n    // 先发送POST请求实现登录\n    String postUrl1 = \"http://localhost/agileone/index.php/common/login\";\n    String postData1 = \"username=admin&password=admin&savelogin=true\";\n    String resp1 = hr.sendPost(postUrl1, postData1);\n    System.out.println(resp1);\n    // 对sendPost()方法进行了额外的封装，一次封装，处处使用\n\n    // 再发送POST请求完成新增\n    String postUrl2 = \"http://localhost/agileone/index.php/proposal/add\";\n    String postData2 = \"type=Enhancement&importance=Medium&\"\n           + \"headline=&\"\n           + \"content=这是用于Java代码测试的内容-10009&processresult=\";\n    String resp2 = hr.sendPost(postUrl2, postData2);\n    System.out.println(resp2);\n}\n我们再来看看Python实现同样功能的代码：\n# 导入urllib和http库\n import urllib\n import http.cookiejar\n\n# 利用cookiejar自动管理整个过程中的Cookie\n cj = http.cookiejar.CookieJar()\n opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))\n\n # 利用urllib构造POST请求并处理登录\n logindata = { \"username\" : 'admin', \"password\": 'admin', \"savelogin\" : \"true\" }\n data_encoded = urllib.parse.urlencode(logindata).encode('utf-8')\n login = opener.open(\"http://localhost/agileone/index.php/common/login/\", data_encoded)\n print(login.read())\n\n # 发送Post请求提交新增需求提案\n proposaldata = {\"type\":\"Requirement\", \"importance\":\"medium\",\n             \"headline\":\"Headline from Python - 10010\",\n             \"content\":\"Content from Python - 10010\", \"scope\":\"1\", \n\"processresult\":\"\"}\n data_encoded = urllib.parse.urlencode(proposaldata).encode('utf-8')\n proposal = opener.open(\"http://localhost/agileone/index.php/proposal/add\", data_encoded)\n print(proposal.read())\n相信大家很难区分所谓的简单与难。因为代码几乎都很类似，这种情况发生在很多场景，解决很多问题时都是一样的。其实很多人之所以宣传Python简单易学，我们抛开某些可能的商业目的或者社会心理的原因之外（商业目的还用说吗，比如最简单的例子，蜗牛学院专门做Python培训的，当然我会不顾一切地说服你，Python是最好的编程语言，没有之一，Java都是垃圾，都是落伍了的，这种睁眼说瞎话的还少吗？因为你很懒，懒得去求证真相而已。社会心理就是我自己是搞Python的，我怎么能说自己做的技术很Low逼呢，我自己是搞Java的，Java必然是最牛的啊）。让我们单纯从事实出发，Python简单的原因只是因为，我们使用Python时，我们可能跟个傻子一样，在直接调用别人给我们写好的代码接口而已，而Java的很多处理相对要原生一点，我们写的代码要稍微多一点。但是只要完成封装，代码就很难说谁更简单了。而这个封装的过程，其实才是编程最重要的部分，如果这一部分我们都不愿意亲自参与，也不想知道个中实现原理，你想想，你怎么可能成长为一个优秀的程序员，还有天理吗？让那些勤奋的人，情何以堪。\n这一点就像C语言，由于C语言更原生，更底层，几乎没有提供太多封装好的代码接口，很多问题的解决都需要我们自己写代码，所以这也是为什么很多人觉得C语言很难，道理是一样的。但是，牛逼的人，都更喜欢自己创造。相比起C语言来说，Java和C#之类的，为我们提供的代码接口要丰富得多，我们使用起来其实也要容易得多，结论就是，在C语言面前，其它高级语言都太简单了，因为封装了太多可以直接用的类库和接口。所以，要成长为一个高级程序员，一定不是写写简单的应用而已，比如Java的源代码是必须要去学习的，我们一定要知道这些封装好的代码接口的实现细节。否则，跟使用Python封装好的东西，又有何本质区别呢？\n所以，请不要再纠结了。强哥的经验，如果你把Java作为你的人生的第一门用心学习的语言，那么你只需要花极短的时间，就可以基本学会C++，JavaScript，PHP, Python，R，C#，Objective-C，Swift，Go（是的，每一门语言都可以在极短的时间学会，只是具体的问题解决和一些坑需要多积累一些实战经验而已）。但是反过来，如果你把Python作为你的第一门语言，问题就回到外国人使用筷子这件事情上了，答案不言而喻。\n所以，你未来如果要立志成为一个专业的程序员，建议先学习Java（或者C#也行，两者有很多原理上很像，实在不行，C/C++也可以哦），那是给程序员的专属语言，是有门槛的，所以你才能够建立自己的竞争力。如果你只是想玩玩，感受一下，或者是把编程语言作为一个工作中的工具而已，Python是个不错的选择。这是面向学习的建议，如果是在企业中真实做项目，那就不要纠结了，项目需要什么，咱们就学什么，不需要那么多理由，干，才是真理。\n锤子好用还是榔头好用？\nJava好还是Python好？\n为什么非得二选一？\n浮躁，一个吃饭的工具而已，搞技术的，通吃它们不就完了吗，你再也不会纠结了，这，才是一个技术人员该有的状态。难道不是吗？\n注：\n本文为蜗牛学院CEO邓强所撰，原文链接\nhttp://www.\nbossqiang.com/article/4\n，转载请联系我方获得授权并注明原文出处。"},
{"title": "在大型项目上，Python 是个烂语言吗？", "description": "最终也将迁出Python体系。YouTube也将不再是一个Python项目了。 YouTube的故事就讲到这里。YouTube无疑是一个使用Python的成功项目", "article": "前YouTuber来讲讲YouTube的故事吧。话说我们YouTuber跟Instagram的朋友吃饭，都要事先约定不谈Python，不然YouTuber分分钟变祥林嫂。不过再怎么吐嘈，YouTube不管从历史，代码量，码农数量，还是支撑的业务规模看，都是一个成功的大型Python Web项目 —— 至少曾经是，为什么是曾经，请一定要看到最后。\nYouTube从一开始就是一个典型的Python + MySQL项目。代码随着业务发展自然生长，在很多年前代码量就以百万计了。这时候的主要工程实践就是一些老生常谈：接口文档，单元测试和集成测试，严格的code review, 还是能维持feature开发；性能上前面一个高度优化的模板引擎 (\nhttps://\ngithub.com/youtube/spit\nfire\n) 后面一个 DB Proxy (\nhttps://\nvitess.io/\n) 就撑起了巨大的流量。Google的代码管理、构建系统和持续集成系统确实是好，serving infrastructure也够强悍，这些底子打得好是这个项目不用很多tricks都能撑到这么大的重要原因。\n但此时软件复杂性的问题已经非常明显，在这个规模上YouTube居然还是一个单体项目，不是不想拆是拆不了。问题就出在「自然生长」上，YouTube代码有典型的分层和业务模块分离设计，但是在这个开发团队规模上，很难有一个独裁架构师管控代码设计，工程师为了一些局部优化目标加一些例外破坏原始架构设计，比如在貌似ORM层的地方放业务特定代码，或者为了实现功能跨模块直接调用。Code review能保证局部代码设计合理，高覆盖的测试能大概保证上线能跑，但长期下来那么多工程师那么多例外，软件整体就变成了一团分层不明，依赖混乱，无法拆分的东西。这是常见的软件工程问题，其实跟Python没什么关系，它在一个Python项目上的体现就是随便改一两行代码都有可能break掉完全不相关的不知什么东西，而且不花至少半个小时跑完至少几千个单元测试你都发现不了（跑完了也不保证能发现就是了），开发者肯定是不爽的，我自己就变成了祥林嫂，至于什么快速开发，从来就不存在。\n由于核心数据库访问逻辑在这团无法拆分的大包里，要加涉及核心数据的功能，只能像滚屎球一样捏着鼻子继续往上加代码。但是对相对独立的新功能，工程师首先考虑的是不再需要用MySQL了 —— Google唯二大规模MySQL部署是广告后台和YouTube, 广告后台切Spanner/F1之后就只剩YouTube了，新功能都被鼓励用Spanner等Google原生存储平台。既然如此，那也就没有那坨Python貌似ORM又不是ORM的代码什么事了，业务逻辑当然就可以写成C++或者Java的后台服务。这时候YouTube就已经是一个Python+MySQL+一大堆C++/Java后台的混合架构。\n真正让YouTuber觉得日子没法过了的，其实还是运行时的问题。由于GIL, Python在多线程环境中很难扩展，YouTube用的是prefork多进程模式。YouTube为了接入Google生产环境以及跟各种Google系统交互，难免要大量调用Google通用的C++库，然而这些C++库全都假定是在一个典型的单进程多线程环境下跑的，开几个后台线程，加载一个共享数据表稀松平常，因为它们都假定这些都是给几千个线程共享的资源开销平摊下来没什么，但到了YouTube的多进程环境就尴尬了，最直接的影响就是巨大的内存占用，那些年内存价格高企，问题就尤其突出。CPU单核性能不再提高之后，CPU开销也成了大问题。YouTube尝试过PyPy, 但是发现由于之前明显的CPU瓶颈已经被用C模块的方法优化掉了，接下来上PyPy并没有带来期望的明显性能提升。从profiler上看到的就是做大型复杂工程的人熟悉的：处处都性能不佳，处处都不是瓶颈的景象，软件太复杂，响应最简单的请求都要做很多免不了的事，就得花那么多CPU. pypy-stm 还很不成熟，破除GIL带来的prefork魔咒遥遥无期。走投无路之下YouTube甚至搞过Grumpy(\nhttps://\ngithub.com/google/grump\ny\n) 这种疯狂的东西，就是一个用Go写的Python runtime, 企图用goroutine和将Python代码渐进移植成Go的方法破除性能屏障，项目似乎理所当然地没有了下文。光从性能上说另一个有希望的方向是Cython, 然而就像上面说的，明显CPU瓶颈已经用手写C模块优化过了，要再广泛铺开Cython必然要手工改写大量业务代码，话说既然都要手工改写了，那为什么还用Python呢？\n花开两朵各表一支，在codebase上，YouTuber历尽千辛万苦，还是将代码分出来严格的Web前端和API层，API层严格划分出了服务模块，各层和模块间只能采用Protocol Buffer的RPC API交互。虽然由于各种不得已这个严格划分好了的Python codebase（居然）还是要整体发布，但是现在逐个模块重写，至少在技术上成了可能。\n轰轰烈烈的 #YTFExit 运动开始了（YTFE = YouTube FrontEnd），运动还有一个契机：MySQL是真的撑不住了，就算技术上撑得住，Google SRE也不愿再为YouTube维护一套全Google唯一的巨型MySQL环境了。YouTube决定将所有存储迁移到Spanner, 并且重新设计表结构，那坨绕不开的数据访问Python代码横竖都是要重写的了。YouTube决定将API层的服务逐个用C++重写成独立部署的微服务，最大限度利用Google完善的C++ infrastructure, prefork什么的自然不会存在，性能的话，其实不管用什么语言只要把陈年代码推倒重写一次都能有显著提升，更别说是C++了。最后只剩下Web层还是Python, 而由于YouTube Web前端已经迁移到Polymer, 可以直接跟API层通信，需要服务器拼接Web页面的地方越来越少，剩下的Web层代码也越来越少，最终也将迁出Python体系。YouTube也将不再是一个Python项目了。\nYouTube的故事就讲到这里。YouTube无疑是一个使用Python的成功项目，但Python是否就是YouTube各个时期最好的选择，每个参与者都有自己的结论。我们可以问很多假设性问题，像是假如YouTube是个独立公司不需要依赖其他Google软件，会不会在运行时问题上没那么痛苦，有更多优化的机会；假如及早在架构上严格拆分，开发效率是否就不会掉得这么严重；假如早年在用Go写Vitess的时候咬咬牙把YTFE也用Go重写了项目发展会不会更顺利。要是去深入思考每一个假如，就会发现这从来不是一个单纯的语言技术问题。\n我自己的看法是，在一个大团队，长期开发的项目中，「自然生长」和滚屎球难以避免，在因此导致的软件复杂和冗余面前，单纯写代码的速度没有什么意义，在技术上能对项目有帮助的主要是 1. 编译和静态分析速度要快 2. 有个靠谱的运行时。Python在这两方面都没能做得很好（pytype没能在YouTube大规模铺开，因为对YouTube的规模来说它实在太慢了），不是说Python就一定做不好，只是在这个领域选择太多，为什么非要抱着Python不放？社区和生态系统就没有选择往这方面优化。#YTFExit 最终的选择居然是 C++, 要说C++在很多方面也非常不适合现代大型项目，比如编译时间就不及格，但是架不住那么多非C++不可的地方Google不得不下死力气优化，也符合了YouTube的要求。#YTFExit没有选择Go的最大考量是C++互操作性不好，如果不是因为Google的这个C++马太效应，要我开始一个YouTube这样的大型Web项目，我会选择Go.\n当然命运没有给我这个如果，我离开YouTube后去了搞一个大型机器学习项目。本以为逃出了YouTube的焦油坑，结果到项目第一天就被糊了一脸稀烂的Python code. Python成了机器学习默认语言这事也有很多偶然，不过已是既成事实，对构建神经网络的前端DSL是Python这件事我没有什么意见。其实一个机器学习项目除了这一点神经网络构建外其他大部分的工作都是各种倒腾protobuf数据，我认为这是非常不适合Python的东西，但是既然Python是机器学习默认语言，大部分researcher开始倒腾数据的时候也是直接上Python, 你跟谁说理去？也许以后Python社区能大力出奇迹，让语言和生态变得特别适应这类的大型项目。所以一个语言的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程，这个显而易见的道理知乎小编认为政治敏感，摊手。"},
{"title": "你好Python，再见Excel", "description": "疼的地方，那么我们应该怎么解决呢？ 学习Python呀 1) Python简单 首先Python容易学习，而且用途非常广泛。 2) 有利于找工作 求职网上逛一圈", "article": "现在很多行业，都离不开用Excel：\n做财务的，要用Excel做报表；\n做物流的，会用Excel来跟踪订单情况；\n做HR的，会用Excel算工资；\n做分析的，会用Excel计算数据做报表。\n不知道你有没有这样的经历，\n每次你用Excel做数据分析时，\n你往往会生成好多张工作簿，\n来做中间计算过程，\n鼠标一路移到最后一页，\n才出现最终结果表。\n这种现象在咨询师，分析师很常见。\n如果这时候源数据出了些问题，\n你可能要从第一种报表开始看起，\n然后，\n一张张的仔细查看，确定错误出在哪。\n而且，\n这样一张张切换工作簿，很容易看花眼，错上加错。\n为了避免这种情况，希望达到报表自动化，\n很多人开始学Excel的高级技能 - VBA。\n但其实，\n第一，VBA并不容易学。\n第二，VBA在数据量大的情况下，运行的很耗时。\n下面我总结了几种，Excel让人头疼的地方：\n1) 连套错误\n如果一个数据发生变化，而且这个数据在工作簿里多次被用到。万一其他地方没有引用公式，那么这个错误，很有可能要花很多手工和眼力去修改，而且还不一定能够改对。\n2) 不可扩展\nExcel最多只有1048576行，16384列。\n如果你的数据很多，\n而且你的电脑内存又不够多的时候，\n很有可能出现，\n一直在处理或者直接跳出，\n没有保存的现象。\n我猜很多人都出现过这个现象。\n3) 性能不好\n一旦Excel数据量太大，就会大大影响你的工作簿的效率。\n有时候，你哪怕新增一个数字，都要花很久才能输入完成。\n更别说，打开和保存工作簿了。\n4) 公式复杂\n由于Excel的单元格公式必须要在一句里面写完。\n所以计算逻辑一旦复杂，不管是你在写的时候，还是公式出错的时候，或者别人读你的公式时候，都会非常的麻烦。\n往往要花很多时间，来弄懂逻辑意义。\n5) 灾难性的忘记保存\n要是遇上死机，自动跳出；\n或者手滑按了关闭。\n那么恭喜你，你可能一个上午的工作都白做了。\n6) 协同工作\n虽然现在市面上云平台共享Excel供大家使用。\n但是，大数据情况下，尤其在中国，\nExcel还是在本地机器上运行和编辑，\n这样的就对协同工作造成很大的不变。\n7) 版本控制\nExcel的报告通常是V1，V2，VF版本来的。\n如果是多人经手，你还能看到John_V1，Lily_V2等。\n如果两个人同事都在改V3版本，又差不多时间发出，那就完全悲剧了。\n7) 公司运营\n其实最早Excel是用来做一些小的，快速计算的事情，并不算入公司层面的永久方案的。\n但现在，越来越多的需求是Excel的报表要求对接财务系统，运营系统，而Excel本身开发设计的时候，根本不是处于这些目的设计的。\n所以不仅维护麻烦，而且这种报表在公司内部打通也不是一件容易的事。\n说了那么多让人头疼的地方，那么我们应该怎么解决呢？\n学习Python呀\n1) Python简单\n首先Python容易学习，而且用途非常广泛。\n2) 有利于找工作\n求职网上逛一圈，你会看多越来越多的职位招聘要求，除了会Excel外，还要求会Python。\n3）可以偷懒呀\n掌握了python后，你绝对能在1小时内，完成别人用Excel花2天做的事情。\n别人996，你拿着手机偷偷玩王者荣耀，没有比这更爽的了吧！\n为什么学Python，不学C++，JAVA呢\n虽然很多人说C++，JAVA也完成Python的功能啊，为什么不学他们？理由有2点：\n不容易学\n代码太复杂\n同一个数据处理，C++可能需要10行，而Python一行就可以搞定。\nPython可以帮你做很多事情\nPython还提供很多已经预先写好的代码，你只要引用一下就可以，连代码都不用写。\n比如：\n读写清理数据\n统计计算\n外部数据库直接对接\n机器学习建模\n画一些美观，而且有交互性的图表\n写SQL\n自动发送Email\n网页爬虫\n自动化\n和Excel交互（如果你真的喜欢用Excel）\n看完这10点，你是不是觉得Python像一个万能药，学1样，就能帮你做100样的感觉。\n用什么软件平台学Python？\n用Jupyter Notebook。\nJupyter Notebook是链接网络的平台，打开Jupyter Notebook，就像在浏览器里打开一个页面。\n当然，下载Jupyter notebook也是很简单的，就像下载王者荣耀那样简单。\n这个页面里面有，\n一些直接用鼠标选择的按键；\n用文字介绍代码是什么意思的解释区域；\n还有写代码的区域；\n展示代码结果的区域。\n心情好的话，你还可以放些照片\n既然Python那么好，那还要不要继续用Excel？\n当然要用。\n其实Excel在有些地方还是非常方便的，\n比如：\n数据量不是很大\n不需要实时更新结果\n更改原数据，即时看每次结果有多大不同\n只要一个大体概念和粗略分析\n不需要长期使用和维护\n最后再安利一波Python的优点\n处理数据功能很强大\n图形展示很高级\n大数据量也能处理\n运行速度可以分布管理\n可以边写，边测试\n很多免费好资源直接使用\n可追溯错误出在哪里\n很容易就实现自动化\n边写代码，边做文档\n用的很舒服，哈哈\n注意⚠️\n广告时间：\n现在从事财务工作、采购工作、行政工作、运营工作；又或是学生党的你，\n会一点Excel，加上看了上面的介绍后，对Python重启学习热情，\n苦恼网上的Python课程太深奥，才听了5分钟，就开始怀疑自己智商，而且，不能和自己工作马上联系起来。\n如果你是上面那几种，那你可以看看下面👇的课程，\n为什么？因为导师讲的都是大白话！绝对不怕你听不懂！"},
{"title": "通过 Python 生成各种“福”", "description": "Crossin：用Python写一份独特的元宵节祝福 文字福 这个福字是将福字图片转成文字符号显示而组成。 使用 opencv-python 库，方法及代码见：Crossin", "article": "是什么让你忽然意识到\n下周就要过年了\n？\n是考完期末考试的最后一门？还是抢到了回家的火车票？又或者是年终奖的到账短信？\n作为一个没有寒假、不用回老家也没有年终奖的人，让我发现马上就要过年的现象是：各个群里面又开始\n集五福\n了！\n五福卡我是没法帮你搞出来。这种 APP 的计算都是放在后端（服务器上），哪怕你完全破解了自己手机上支付宝，该还花呗也还是得还。\n不过，我倒是可以帮你生成一些福字，直接拿去扫一扫，省得满世界地找了。没准也能扫出个全家福呢！😏\n以下这些福字，全部是用 \nCrossin 的编程教室\n往期文章中介绍的方法，通过 \nPython 语言及相关库\n所生成。\n头像福\n这个福字是用微信好友的头像所组成。\n使用 \nitchat\n 和 \nPIL\n 库，方法及代码见：\nCrossin：用Python写一份独特的元宵节祝福\n文字福\n这个福字是将福字图片转成文字符号显示而组成。\n使用 \nopencv-python\n 库，方法及代码见：\nCrossin：超不清视频播放器-用Python将视频转成字符\n名画福\n如果左边跟着梵高画个福，再跟着毕加索右边画个福，会是什么样的效果？\n这两个福字分别通过\n梵高的《星空》\n和\n毕加索的《缪斯》\n风格生成。\n使用 \nopencv-python\n 中的 \nDNN\n（深度神经网络），方法及代码见：\nCrossin：Python+OpenCV 十几行代码模仿世界名画\n变形福\n还有几个用图像处理产生的不同福字，总有一款适合你。\n使用 \nopencv-python\n 课程，方法及代码见：\nCrossin：python 图像处理：一福变五福\n经验证，以上福字皆可扫。本人已集齐✌️\n最后，再送上一张阿里某马姓员工写的福字，据说扫它能抽到稀有福！\n------\n一起学，走得远！\n欢迎搜索：\nCrossin的编程教室"},
{"title": "一行Python代码能做什么？", "description": "原文在：一行 Python 代码 自从08年接触Python，就有爱不释手的感觉，逐渐地，有些不忍地疏远了Perl 和Shell编程，因为python 的优雅么？", "article": "很典型的文章，基本可以展示Python代码到底有多黑魔法。虽然文中有些案例连我都觉得走火入魔，但真的很值得一看。。。\n原文在：\n一行 Python 代码\n自从08年接触Python，就有爱不释手的感觉，逐渐地，有些不忍地疏远了Perl 和Shell编程，因为python 的优雅么？ 不全是，主要是可以高效开发吧。\n那一行代码可以干什么呢？\n有趣\n我孩子的英文名叫andy，也许当初教他写程序的时候，如果先秀一下这行代码，可能就更能激起他对代码的兴趣了。\n>>> print'\\n'.join([''.join([('AndyLove'[(x-y)%8]if((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3<=0 else' ')for x in range(-30,30)])for y in range(15,-15,-1)])\n再python 里执行它，会输出一个字符拼出的心形。\n字符图形还是很有趣的，有一个著名的图像叫mandelbrot。Mandelbrot图像中的每个位置都对应于公式N=x+y＊i 中的一个复数，高中学过复数的都还应该有印象。每个位置用参数N来表示，它是x＊x+y＊y的平方根。如果这个值大于或等于2，则这个数字对应的位置值是0。如果参数N的值小于2，就把N的值改为N*N-\nN（N=（x*x-y*y-x）+（2*x*y-y）*i）），并再次测试这个新N值。wiki百科给出的图像是这样的：\n让我们用一行代码画一个Mandelbrot：\n>>> print'\\n'.join([''.join(['*'if abs((lambda a:lambda z,c,n:a(a,z,c,n))(lambda s,z,c,n:z if n==0else s(s,z*z+c,c,n-1))(0,0.02*x+0.05j*y,40))2 else' 'for x in range(-80,20)])for y in range(-20,20)])\n高效\n对于随手小工具而言，更是Python的拿手好戏。\n一行代码打印九九乘法表:\nprint '\\n'.join([' '.join(['%s*%s=%-2s' % (y,x,x*y) for y in range(1,x+1)]) for x in range(1,10)])\n输出：\n一行代码计算出1-1000之间的素数\nprint(*(i for i in range(2, 1000) if all(tuple(i%j for j in range(2, int(i**.5))))))  \n一行代码可以输出前100项斐波那契数列的值：\nprint [x[0] for x in [ (a[i][0], a.append((a[i][1], a[i][0]+a[i][1]))) for a in ([[1,1]], ) for i in xrange(100) ]]\n一行代码实现阶乘，而且还带交互：\n>>> reduce ( lambda x,y:x*y, range(1,input()+1))\n10\n3628800\n一行代码实现摄氏度与华氏度之间的转换器：\n>>> print((lambda i:i not in [1,2] and \"Invalid input!\" or i==1 and (lambda f:f<-459.67 and \"Invalid input!\" or f)(float(input(\"Please input a Celsius temperature:\"))*1.8+32) or i==2 and (lambda c:c<-273.15 and \"Invalid input!\" or c)((float(input(\"Please input a Fahrenheit temperature:\"))-32)/1.8))(int(input(\"1,Celsius to Fahrenheit\\n2,Fahrenheit to Celsius\\nPlease input 1 or 2\\n\"))))\n1,Celsius to Fahrenheit\n2,Fahrenheit to Celsius\nPlease input 1 or 2\n1\nPlease input a Celsius temperature:28\n82.4\n>>>\n至于字符串排序和快速排序更是手到擒来。\n\"\".join((lambda x:(x.sort(),x)[1])(list(‘string’)))\n\nqsort = lambda arr: len(arr) > 1 and qsort(filter(lambda x: x<=arr[0], arr[1:] )) + arr[0:1] + qsort(filter(lambda x:x>arr[0], arr[1:] )) or arr\n内涵\n看一看下面一行python代码，可能就要晕了：\n这是原来为了激发孩子编程兴趣，让孩子练习的代码，它的真实面貌是大致这样的：\ndef guess_my_number(n):\nwhile True:\nuser_input = raw_input(\"Enter a positive integer to guess: \")\nif len(user_input)==0 or not user_input.isdigit():\nprint \"Not a positive integer!\"\nelse:\nuser_input = int(user_input)\nif user_input > n:\nprint \"Too big ! Try again!\"\nelif user_input < n:\nprint \"Too small ! Try again!\"\nelse:\nprint \"You win!\"\nreturn True\nguess_my_number(42)\n实际上，只要理解了函数式编程，使用神奇的Lambda，配合列表推导以及复杂一点的判断语句，任何的python 代码都可以转换成一行代码的。\n例如，取一个列表里的随机数\nimport random as rnd\nprint rnd.choice([2,3, 5,7, 11,13,17])\n转换成Lambda 可以是：\nprint (lambda rnd: rnd.choice([1, 2, 3, 10]))(__import__('random'))\n这些代码出了觉得好玩，主要是可以\n帮助我们了解某些Python的雕虫小记，尤其是神奇的Lambda 用法。\n延展\n当然，还有其他好玩的地方，输入下面这一行\nimport antigravity\n它打开了浏览器，展示网站上的漫画和相关内容：\n我们可以把python的文件打包，做成库的形式，然后import进来，是一种偷换概念和前提的一行代码。例如，为了与windows 传输文件，再Mac上临时搭个ftp：\n$ python -m pyftpdlib\n这当然要依赖pyftpdlib 这个库了，机器上没有，pip install pyftpdlib 就可以了。\n如果一行代码中允许分号存在，那就只是牺牲可读性而已了，那就基本上无所不能。\n在连网的前提下，获取公网IP地址\npython -c \"import socket; sock=socket.create_connection(('ns1.dnspod.net',6666)); print sock.recv(16); sock.close()\"\n一行代码就可以轻易写个小游戏了，来模拟一下golf击球。\npython -c \"import math as m;a,v=eval(input());[print('%03d'%x+' '*m.floor(0.5+x*m.tan(a)-x*x/(v*m.cos(a)))+'o') for x in range(102)]\"\n输入角度和力量大小如（0.8,80)，就能得到一条字符描画的抛物线了。\n增加上while 等语句，画一个没完没了的\npython -c \"while 1:import random;print(random.choice('╱╲'), end='')\"\n最后，一行代码以python 的哲学结束吧。\n$ python -c \"import this\"\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n你想更深入了解学习Python知识体系，你可以看一下我们花费了一个多月整理了上百小时的几百个知识点体系内容：\n【超全整理】《Python自动化全能开发从入门到精通》笔记全放送"},
{"title": "这些是 Python 官方推荐的最好书籍（推荐）", "description": "的 Python 书 七：免费下载资源 Free Python books - pythonbooks", "article": "简评：Python 官方有一个推荐书单「\nPythonBooks.org\n 」，这里面涵盖了从初学到入门再到精通（并没有到放弃）的各个阶段，最好的学习书籍。园长整理了列表方便查找对应的中文版。\nPython 官方书单列表：\nPythonBooks.org\n \n这个列表中有七大类书籍：\n一：编程初学者的书籍\n二：中级 Python 程序员书籍\n掌握语言\n程序实操\n三：参考书\n四：专题书籍\n算法和数据结构\n生物学\n计算机安全\n工程学\n金融学\n地理信息系统\nGUI 开发\n计算机视觉和图形学\n计算机高性能\n机器学习和 AI\n微控制器\n网络编程\n自然语言处理\n数值编程和数据挖掘\n树莓派\n网络爬虫\nweb 开发\n五：刚接触 Python 的老程序员\n六：给孩子看的 Python 书\n七：可免费下载的书籍\n因为每一个表单很长，我只放上这个类目前三的书籍（我\n会附上上京东中文版书籍的截图\n）。\n如果想看完整列表，请访问 \nFind the best Python books - pythonbooks.org\n。\n无水印版请在公众号「极光开发者」，回复「python书单」\n一：初学编程，这些书籍适合你（前三名）\n：\n二：中级 Python 程序员：\n掌握语言：\n实践：\n三：相关书籍\n四：专项书籍（这个分类太多我就贴机器学习和 AI 了，其他自己看吧）\nPython 的机器学习和 AI\n五：有经验的程序员学 Python 可以看\n六：孩子看的 Python 书\n七：免费下载资源 \nFree Python books - pythonbooks.org\n很多免费的 python 学习书籍，都是英文版。\n以上。\n没有原文，只有官网：\nFind the best Python books - pythonbooks.org\n园长：\n我整理的那个中文版书单，有个别几个还没中文版，就直接贴上了英文版的图。\n另外，想要高清无水印书单的原图，请关注公众号「\n极光开发者\n」，回复关键字「\npython书单\n」。\n极光日报，\n极光开发者\n旗下媒体。\n每天导读三篇英文技术文章。"},
{"title": "毫无基础的人如何入门 Python ？", "description": "Day01~15 - Python语言基础 Day01 - 初识Python Python简介 - Python的历史 / Python的优缺点 / Python的应用领域", "article": "之前回答过很受知友们欢迎，再分享一下。\nGithub上位名叫骆昊 (jackfrued) 的资深程序员，为大家规划了一条从“从新手到大师”的百天之路！我觉得这个模式你可以参考一下。\n现在已经有5w+星了！\n给初学者的几个建议：\nMake English as your working language.\nPractice makes perfect.\nAll experience comes from mistakes.\nDon't be one of the leeches.\nEither stand out or kicked out.\n先附上github地址：\nhttps://github.com/jackfrued/Python-100-Day\n下面是这个一百天计划里面的学习框架，我在这里放上来。\n（PS.对于毫无基础的人想百天完成这里面的学习计划就实话说根本是不可能的，我个人是比较认可这个学习框架的，大家没有必要严格卡这个100天，照着这个进程学习是完全可以的。）\nDay01~15 - \nPython语言基础\nDay01 - \n初识Python\nPython简介 - Python的历史 / Python的优缺点 / Python的应用领域\n搭建编程环境 - Windows环境 / Linux环境 / MacOS环境\n从终端运行Python程序 - Hello, world / print函数 / 运行程序\n使用IDLE - 交互式环境(REPL) / 编写多行代码 / 运行程序 / 退出IDLE\n注释 - 注释的作用 / 单行注释 / 多行注释\nDay02 - \n语言元素\n程序和进制 - 指令和程序 / 冯诺依曼机 / 二进制和十进制 / 八进制和十六进制\n变量和类型 - 变量的命名 / 变量的使用 / input函数 / 检查变量类型 / 类型转换\n数字和字符串 - 整数 / 浮点数 / 复数 / 字符串 / 字符串基本操作 / 字符编码\n运算符 - 数学运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 身份运算符 / 运算符的优先级\n应用案例 - 华氏温度转换成摄氏温度 / 输入圆的半径计算周长和面积 / 输入年份判断是否是闰年\nDay03 - \n分支结构\n分支结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图\nif语句 - 简单的if / if-else结构 / if-elif-else结构 / 嵌套的if\n应用案例 - 用户身份验证 / 英制单位与公制单位互换 / 掷骰子决定做什么 / 百分制成绩转等级制 / 分段函数求值 / 输入三条边的长度如果能构成三角形就计算周长和面积\nDay04 - \n循环结构\n循环结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图\nwhile循环 - 基本结构 / break语句 / continue语句\nfor循环 - 基本结构 / range类型 / 循环中的分支结构 / 嵌套的循环 / 提前结束程序\n应用案例 - 1~100求和 / 判断素数 / 猜数字游戏 / 打印九九表 / 打印三角形图案 / 猴子吃桃 / 百钱百鸡\nDay05 - \n构造程序逻辑\n基础练习 - 水仙花数 / 完美数 / 五人分鱼 / Fibonacci数列 / 回文素数\n综合练习 - Craps赌博游戏\nDay06 - \n函数和模块的使用\n函数的作用 - 代码的坏味道 / 用函数封装功能模块\n定义函数 - def语句 / 函数名 / 参数列表 / return语句 / 调用自定义函数\n调用函数 - Python内置函数 / 导入模块和函数\n函数的参数 - 默认参数 / 可变参数 / 关键字参数 / 命名关键字参数\n函数的返回值 - 没有返回值 / 返回单个值 / 返回多个值\n作用域问题 - 局部作用域 / 嵌套作用域 / 全局作用域 / 内置作用域 / 和作用域相关的关键字\n用模块管理函数 - 模块的概念 / 用自定义模块管理函数 / 命名冲突的时候会怎样（同一个模块和不同的模块）\nDay07 - \n字符串和常用数据结构\n字符串的使用 - 计算长度 / 下标运算 / 切片 / 常用方法\n列表基本用法 - 定义列表 / 用下表访问元素 / 下标越界 / 添加元素 / 删除元素 / 修改元素 / 切片 / 循环遍历\n列表常用操作 - 连接 / 复制(复制元素和复制数组) / 长度 / 排序 / 倒转 / 查找\n生成列表 - 使用range创建数字列表 / 生成表达式 / 生成器\n元组的使用 - 定义元组 / 使用元组中的值 / 修改元组变量 / 元组和列表转换\n集合基本用法 - 集合和列表的区别 / 创建集合 / 添加元素 / 删除元素 / 清空\n集合常用操作 - 交集 / 并集 / 差集 / 对称差 / 子集 / 超集\n字典的基本用法 - 字典的特点 / 创建字典 / 添加元素 / 删除元素 / 取值 / 清空\n字典常用操作 - keys()方法 / values()方法 / items()方法 / setdefault()方法\n基础练习 - 跑马灯效果 / 列表找最大元素 / 统计考试成绩的平均分 / Fibonacci数列 / 杨辉三角\n综合案例 - 双色球选号 / 井字棋\nDay08 - \n面向对象编程基础\n类和对象 - 什么是类 / 什么是对象 / 面向对象其他相关概念\n定义类 - 基本结构 / 属性和方法 / 构造器 / 析构器 / __str__方法\n使用对象 - 创建对象 / 给对象发消息\n面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态\n基础练习 - 定义学生类 / 定义时钟类 / 定义图形类 / 定义汽车类\nDay09 - \n面向对象进阶\n属性 - 类属性 / 实例属性 / 属性访问器 / 属性修改器 / 属性删除器 / 使用__slots__\n类中的方法 - 实例方法 / 类方法 / 静态方法\n运算符重载 - __add__ / __sub__ / __or__ /__getitem__ / __setitem__ / __len__ / __repr__ / __gt__ / __lt__ / __le__ / __ge__ / __eq__ / __ne__ / __contains__\n类(的对象)之间的关系 - 关联 / 继承 / 依赖\n继承和多态 - 什么是继承 / 继承的语法 / 调用父类方法 / 方法重写 / 类型判定 / 多重继承 / 菱形继承(钻石继承)和C3算法\n综合案例 - 工资结算系统 / 图书自动折扣系统 / 自定义分数类\nDay10 - \n图形用户界面和游戏开发\n使用tkinter开发GUI\n使用pygame三方库开发游戏应用\n“大球吃小球”游戏\nDay11 - \n文件和异常\n读文件 - 读取整个文件 / 逐行读取 / 文件路径\n写文件 - 覆盖写入 / 追加写入 / 文本文件 / 二进制文件\n异常处理 - 异常机制的重要性 / try-except代码块 / else代码块 / finally代码块 / 内置异常类型 / 异常栈 / raise语句\n数据持久化 - CSV文件概述 / csv模块的应用 / JSON数据格式 / json模块的应用\nDay12 - \n字符串和正则表达式\n字符串高级操作 - 转义字符 / 原始字符串 / 多行字符串 / in和 not in运算符 / is开头的方法 / join和split方法 / strip相关方法 / pyperclip模块 / 不变字符串和可变字符串 / StringIO的使用\n正则表达式入门 - 正则表达式的作用 / 元字符 / 转义 / 量词 / 分组 / 零宽断言 /贪婪匹配与惰性匹配懒惰 / 使用re模块实现正则表达式操作（匹配、搜索、替换、捕获）\n使用正则表达式 - re模块 / compile函数 / group和groups方法 / match方法 / search方法 / findall和finditer方法 / sub和subn方法 / split方法\n应用案例 - 使用正则表达式验证输入的字符串\nDay13 - \n进程和线程\n进程和线程的概念 - 什么是进程 / 什么是线程 / 多线程的应用场景\n使用进程 - fork函数 / multiprocessing模块 / 进程池 / 进程间通信\n使用线程 - thread模块 / threading模块 / Thread类 / Lock类 / Condition类 / 线程池\nDay14 - \n网络编程入门和网络应用开发\n计算机网络基础 - 计算机网络发展史 / “TCP-IP”模型 / IP地址 / 端口 / 协议 / 其他相关概念\n网络应用模式 - “客户端-服务器”模式 / “浏览器-服务器”模式\n基于HTTP协议访问网络资源 - 网络API概述 / 访问URL / requests模块 / 解析JSON格式数据\nPython网络编程 - 套接字的概念 / socket模块 / socket函数 / 创建TCP服务器 / 创建TCP客户端 / 创建UDP服务器 / 创建UDP客户端 / SocketServer模块\n电子邮件 - SMTP协议 / POP3协议 / IMAP协议 / smtplib模块 / poplib模块 / imaplib模块\n短信服务 - 调用短信服务网关\nDay15 - \n图像和文档处理\n用Pillow处理图片 - 图片读写 / 图片合成 / 几何变换 / 色彩转换 / 滤镜效果\n读写Word文档 - 文本内容的处理 / 段落 / 页眉和页脚 / 样式的处理\n读写Excel文件 - xlrd模块 / xlwt模块\n生成PDF文件 - pypdf2模块 / reportlab模块\nDay16~Day20 - \nPython语言进阶\n常用数据结构\n函数的高级用法 - “一等公民” / 高阶函数 / Lambda函数 / 作用域和闭包 / 装饰器\n面向对象高级知识 - “三大支柱” / 类与类之间的关系 / 垃圾回收 / 魔术属性和方法 / 混入 / 元类 / 面向对象设计原则 / GoF设计模式\n迭代器和生成器 - 相关魔术方法 / 创建生成器的两种方式 /\n并发和异步编程 - 多线程 / 多进程 / 异步IO / async和await\nDay21~30 - \nWeb前端入门\n用HTML标签承载页面内容\n用CSS渲染页面\n用JavaScript处理交互式行为\njQuery入门和提高\nVue.js入门\nElement的使用\nBootstrap的使用\nDay31~35 - \n玩转Linux操作系统\n操作系统发展史和Linux概述\nLinux基础命令\nLinux中的实用程序\nLinux的文件系统\nVim编辑器的应用\n环境变量和Shell编程\n软件的安装和服务的配置\n网络访问和管理\n其他相关内容\nDay36~40 - \n数据库基础和进阶\n关系型数据库MySQL\n关系型数据库概述\nMySQL的安装和使用\nSQL的使用\nDDL - 数据定义语言 - create / drop / alter\nDML - 数据操作语言 - insert / delete / update / select\nDCL - 数据控制语言 - grant / revoke\n相关知识\n范式理论 - 设计二维表的指导思想\n数据完整性\n数据一致性\n在Python中操作MySQL\nNoSQL入门\nNoSQL概述\nRedis概述\nMongo概述\nDay41~55 - \n实战Django\nDay41 - \n快速上手\nWeb应用工作原理和HTTP协议\nDjango框架概述\n5分钟快速上手\n使用视图模板\nDay42 - \n深入模型\n关系型数据库配置\n管理后台的使用\n使用ORM完成对模型的CRUD操作\nDjango模型最佳实践\n模型定义参考\nDay43 - \n静态资源和Ajax请求\n加载静态资源\n用Ajax请求获取数据\nDay44 - \n表单的应用\n表单和表单控件\n跨站请求伪造和CSRF令牌\nForm和ModelForm\n表单验证\nDay45 - \nCookie和Session\n实现用户跟踪\ncookie和session的关系\nDjango框架对session的支持\n视图函数中的cookie读写操作\nDay46 - \n报表和日志\n通过HttpResponse修改响应头\n使用StreamingHttpResponse处理大文件\n使用xlwt生成Excel报表\n使用reportlab生成PDF报表\n使用ECharts生成前端图表\n配置日志和Django-Debug-Toolbar\nDay47 - \n中间件的应用\n什么是中间件\nDjango框架内置的中间件\n自定义中间件及其应用场景\nDay48 - \n前后端分离开发入门\n返回JSON格式的数据\n用Vue.js渲染页面\nDay49 - \nRESTful架构和DRF入门\nDay50 - \nRESTful架构和DRF进阶\nDay51 - \n使用缓存\n网站优化第一定律\n在Django项目中使用Redis提供缓存服务\n在视图函数中读写缓存\n使用装饰器实现页面缓存\n为数据接口提供缓存服务\nDay52 - \n文件上传和富文本编辑\n文件上传表单控件和图片文件预览\n服务器端如何处理上传的文件\n富文本编辑器概述\nwangEditor的使用\nDay53 - \n短信和邮件\n常用短信网关平台介绍\n使用螺丝帽发送短信\nDjango框架对邮件服务的支持\nDay54 - \n异步任务和定时任务\n网站优化第二定律\n配置消息队列服务\n在项目中使用celery实现任务异步化\n在项目中使用celery实现定时任务\nDay55 - \n单元测试和项目上线\nPython中的单元测试\nDjango框架对单元测试的支持\n使用版本控制系统\n配置和使用uWSGI\n动静分离和Nginx配置\n配置HTTPS\nDay56~60 - \n实战Flask\nDay56 - \nFlask入门\nDay57 - \n模板的使用\nDay58 - \n表单的处理\nDay59 - \n数据库操作\nDay60 - \n项目实战\nDay61~65 - \n实战Tornado\nDay61 - \n预备知识\n并发编程\nI/O模式和事件驱动\nDay62 - \nTornado入门\nTornado概述\n5分钟上手Tornado\n路由解析\n请求处理器\nDay63 - \n异步化\naiomysql和aioredis的使用\nDay64 - \nWebSocket的应用\nWebSocket简介\nWebSocket服务器端编程\nWebSocket客户端编程\n项目：Web聊天室\nDay65 - \n项目实战\n前后端分离开发和接口文档的撰写\n使用Vue.js实现前端渲染\n使用ECharts实现报表功能\n使用WebSocket实现推送服务\nDay66~75 - \n爬虫开发\nDay66 - \n网络爬虫和相关工具\n网络爬虫的概念及其应用领域\n网络爬虫的合法性探讨\n开发网络爬虫的相关工具\n一个爬虫程序的构成\nDay67 - \n数据采集和解析\n数据采集的标准和三方库\n页面解析的三种方式：正则表达式解析 / XPath解析 / CSS选择器解析\nDay68 - \n存储数据\n如何存储海量数据\n实现数据的缓存\nDay69 - \n并发下载\n多线程和多进程\n异步I/O和协程\nasync和await关键字的使用\n三方库aiohttp的应用\nDay70 - \n解析动态内容\nJavaScript逆向工程\n使用Selenium获取动态内容\nDay71 - \n表单交互和验证码处理\n自动提交表单\nCookie池的应用\n验证码处理\nDay72 - \nScrapy入门\nScrapy爬虫框架概述\n安装和使用Scrapy\nDay73 - \nScrapy高级应用\nSpider的用法\n中间件的应用：下载中间件 / 蜘蛛中间件\nScrapy对接Selenium抓取动态内容\nScrapy部署到Docker\nDay74 - \nScrapy分布式实现\n分布式爬虫的原理\nScrapy分布式实现\n使用Scrapyd实现分布式部署\nDay75 - \n爬虫项目实战\n爬取招聘网站数据\n爬取房地产行业数据\n爬取二手车交易平台数据\nDay76~90 - \n数据处理和机器学习\nDay76 - \n机器学习基础\nDay77 - \nPandas的应用\nDay78 - \nNumPy和SciPy的应用\nDay79 - \nMatplotlib和数据可视化\nDay80 - \nk最近邻(KNN)分类\nDay81 - \n决策树\nDay82 - \n贝叶斯分类\nDay83 - \n支持向量机(SVM)\nDay84 - \nK-均值聚类\nDay85 - \n回归分析\nDay86 - \n大数据分析入门\nDay87 - \n大数据分析进阶\nDay88 - \nTensorflow入门\nDay89 - \nTensorflow实战\nDay90 - \n推荐系统\nDay91~100 - \n团队项目开发\n第91天：\n团队项目开发准备\n软件过程模型\n经典过程模型（瀑布模型）\n可行性分析（研究做还是不做），输出《可行性分析报告》。\n需求分析（研究做什么），输出《需求规格说明书》和产品界面原型图。\n概要设计和详细设计，输出概念模型图、物理模型图、类图、时序图等。\n编码 / 测试。\n上线 / 维护。\n敏捷开发（Scrum）- 产品所有者、Scrum Master、研发人员 - Sprint\n产品的Backlog（用户故事、产品原型）。\n计划会议（评估和预算）。\n日常开发（站立会议、番茄工作法、结对编程、测试先行、代码重构……）。\n修复bug（问题描述、重现步骤、测试人员、被指派人）。\n评审会议（Showcase）。\n回顾会议（当前周期做得好和不好的地方）。\n补充：敏捷软件开发宣言\n个体和互动\n 高于 流程和工具\n工作的软件\n 高于 详尽的文档\n客户合作\n 高于 合同谈判\n响应变化\n 高于 遵循计划\n角色：产品所有者（决定做什么，能对需求拍板的人）、团队负责人（解决各种问题，专注如何更好的工作，屏蔽外部对开发团队的影响）、开发团队（项目执行人员，具体指开发人员和测试人员）。\n准备工作：商业案例和资金、合同、憧憬、初始产品需求、初始发布计划、入股、组建团队。\n敏捷团队通常人数为8-10人。\n工作量估算：将开发任务量化，包括原型、Logo设计、UI设计、前端开发等，尽量把每个工作分解到最小任务量，最小任务量标准为工作时间不能超过两天，然后估算总体项目时间。把每个任务都贴在白板上面，白板上分三部分：to do（待完成）、in progress（进行中）和done（已完成）。\n项目团队组建\n团队的构成和角色\n说明：谢谢付祥英女士绘制了下面这张精美的公司组织架构图。\n编程规范和代码审查（flake8、pylint）\nPython中的一些“惯例”（请参考\n《Python惯例-如何编写Pythonic的代码》\n）\n影响代码可读性的原因：\n代码注释太少或者没有注释\n代码破坏了语言的最佳实践\n反模式编程（意大利面代码、复制-黏贴编程、自负编程、……）\n2.团队开发工具介绍\n版本控制：Git、Mercury\n缺陷管理：\nGitlab\n、\nRedmine\n敏捷闭环工具：\n禅道\n、\nJIRA\n持续集成：\nJenkins\n、\nTravis-CI\n请参考\n《团队项目开发》\n。\n项目选题和理解业务\n选题范围设定\nCMS（用户端）：新闻聚合网站、问答/分享社区、影评/书评网站等。\nMIS（用户端+管理端）：KMS、KPI考核系统、HRS、CRM系统、供应链系统、仓储管理系统等。\nApp后台（管理端+数据接口）：二手交易类、报刊杂志类、小众电商类、新闻资讯类、旅游类、社交类、阅读类等。\n其他类型：自身行业背景和工作经验、业务容易理解和把控。\n2.需求理解、模块划分和任务分配\n需求理解：头脑风暴和竞品分析。\n模块划分：画思维导图（XMind），每个模块是一个枝节点，每个具体的功能是一个叶节点（用动词表述），需要确保每个叶节点无法再生出新节点，确定每个叶子节点的重要性、优先级和工作量。\n任务分配：由项目负责人根据上面的指标为每个团队成员分配任务。\n3.制定项目进度表（每日更新）\n第92天：\nDocker的使用\n第93天：\n数据库设计和OOAD\n概念模型和正向工程\nUML（统一建模语言）的类图\n通过模型创建表（正向工程）\npython manage.py makemigrations app python manage.py migrate\n物理模型和反向工程\nPowerDesigner\n2.通过数据表创建模型（反向工程）\npython manage.py inspectdb > app/models.py\n第94天：\n网络API接口设计\n第95天：\n使用Django开发项目\n项目开发中的公共问题\n数据库的配置（多数据库、主从复制、数据库路由）\n缓存的配置（分区缓存、键设置、超时设置、主从复制、故障恢复（哨兵））\n日志的配置\n分析和调试（Django-Debug-ToolBar）\n好用的Python模块（日期计算、图像处理、数据加密、三方API）\nREST API设计\nRESTful架构\n理解RESTful架构\nRESTful API设计指南\nRESTful API最佳实践\nAPI接口文档的撰写\nRAP2\nYAPI\ndjango-REST-framework\n的应用\n项目中的重点难点剖析\n使用缓存缓解数据库压力 - Redis\n使用消息队列做解耦合和削峰 - Celery + RabbitMQ\n第96天：\n软件测试和自动化测试\n单元测试\n测试的种类\n编写单元测试（unittest、pytest、nose2、tox、ddt、……）\n测试覆盖率（coverage）\n项目部署\n部署前的准备工作\n关键设置（SECRET_KEY / DEBUG / ALLOWED_HOSTS / 缓存 / 数据库）\nHTTPS / CSRF_COOKIE_SECUR / SESSION_COOKIE_SECURE\n日志相关配置\nLinux常用命令回顾\nLinux常用服务的安装和配置\nuWSGI/Gunicorn和Nginx的使用\nGunicorn和uWSGI的比较\n对于不需要大量定制化的简单应用程序，Gunicorn是一个不错的选择，uWSGI的学习曲线比Gunicorn要陡峭得多，Gunicorn的默认参数就已经能够适应大多数应用程序。\nuWSGI支持异构部署。\n由于Nginx本身支持uWSGI，在线上一般都将Nginx和uWSGI捆绑在一起部署，而且uWSGI属于功能齐全且高度定制的WSGI中间件。\n在性能上，Gunicorn和uWSGI其实表现相当。\n虚拟化技术（Docker）\n性能测试\nAB的使用\nSQLslap的使用\nsysbench的使用\n自动化测试\n使用Shell和Python进行自动化测试\n使用Selenium实现自动化测试\nSelenium IDE\nSelenium WebDriver\nSelenium Remote Control\n测试工具Robot Framework介绍\n第97天：\n电商网站技术要点剖析\n第98天：\n项目部署上线和性能调优\nMySQL数据库调优\nWeb服务器性能优化\n3.代码性能调优\n多线程\n异步化\n4.静态资源访问优化\n云存储\nCDN\n第99天：\n面试中的公共问题\n第100天：\n英语面试\n作者：骆昊 (jackfrued)\n来源：github\ngithub地址：\nhttps://\ngithub.com/jackfrued/Py\nthon-100-Days\n另外，CSDN也出过一个图谱，\n希望能帮到你。"},
{"title": "整理了70个Python实战项目列表，都有完整且详细的教程", "description": "你也可以从中寻找灵感去做自己的项目。 70个Python项目列表： 1、【Python 图片转字符画】 2、【200行Python代码实现2048】 3、【Python3 实现火车票查询工具】", "article": "不管学习那门语言都希望能做出实际的东西来，这个实际的东西当然就是项目啦，不用多说大家都知道学编程语言一定要做项目才行。\n 这里整理了70个Python实战项目列表，都有完整且详细的教程，你可以从中选择自己想做的项目进行参考学习练手，你也可以从中寻找灵感去做自己的项目。\n 70个Python项目列表：\n 1、\n【Python 图片转字符画】\n2、\n【200行Python代码实现2048】\n3、\n【Python3 实现火车票查询工具】\n4、\n【高德API+Python解决租房问题 】\n5、\n【Python3 色情图片识别】\n6、\n【Python 破解验证码】\n7、\n【Python实现简单的Web服务器】\n8、\n【pygame开发打飞机游戏】\n9、\n【Django 搭建简易博客】\n10、\n【Python基于共现提取《釜山行》人物关系】\n11、\n【基于scrapy爬虫的天气数据采集(python)】\n12、\n【Flask 开发轻博客】\n13、\n【Python3 图片隐写术】\n14、\n【Python 实现简易 Shell】\n15、\n【使用 Python 解数学方程】\n16、\n【PyQt 实现简易浏览器】\n17、\n【神经网络实现手写字符识别系统 】\n18、\n【Python 实现简单画板】\n19、\n【Python实现3D建模工具】\n20、\n【NBA常规赛结果预测——利用Python进行比赛数据分析】\n21、\n【神经网络实现人脸识别任务】\n22、\n【Python文本解析器】\n23、\n【Python3 & OpenCV 视频转字符动画】\n24、\n【Python3 实现淘女郎照片爬虫 】\n25、\n【Python3实现简单的FTP认证服务器】\n26、\n【基于 Flask 与 MySQL 实现番剧推荐系统】\n27、\n【Python 实现端口扫描器】\n28、\n【使用 Python 3 编写系列实用脚本】\n29、\n【Python 实现康威生命游戏】\n30、\n【川普撞脸希拉里(基于 OpenCV 的面部特征交换) 】\n31、\n【Python 3 实现 Markdown 解析器】\n32、\n【Python 气象数据分析 -- 《Python 数据分析实战》】\n33、\n【Python实现键值数据库】\n34、\n【k-近邻算法实现手写数字识别系统】\n35、\n【ebay在线拍卖数据分析】\n36、\n【Python 实现英文新闻摘要自动提取 】\n37、\n【Python实现简易局域网视频聊天工具】\n38、\n【基于 Flask 及爬虫实现微信娱乐机器人】\n39、\n【Python实现Python解释器】\n40、\n【Python3基于Scapy实现DDos】\n41、\n【Python 实现密码强度检测器】\n42、\n【使用 Python 实现深度神经网络】\n43、\n【Python实现从excel读取数据并绘制成精美图像】\n44、\n【人机对战初体验:Python基于Pygame实现四子棋游戏】\n45、\n【Python3 实现可控制肉鸡的反向Shell】\n46、\n【Python打造漏洞扫描器 】\n47、\n【Python应用马尔可夫链算法实现随机文本生成】\n48、\n【数独游戏的Python实现与破解】\n49、\n【使用Python定制词云】\n50、\n【Python开发简单计算器】\n51、\n【Python 实现 FTP 弱口令扫描器】\n52、\n【Python实现Huffman编码解压缩文件】\n53、\n【Python实现Zip文件的暴力破解 】\n54、\n【Python3 智能裁切图片】\n55、\n【Python实现网站模拟登陆】\n56、\n【给Python3爬虫做一个界面.妹子图网实战】\n57、\n【Python 3 实现图片转彩色字符】\n58、\n【自联想器的 Python 实现】\n59、\n【Python 实现简单滤镜】\n60、\n【Flask 实现简单聊天室】\n61、\n【基于PyQt5 实现地图中定位相片拍摄位置】\n62、\n【Python实现模板引擎】\n63、\n【Python实现遗传算法求解n-queens问题】\n64、\n【Python3 实现命令行动态进度条】\n65、\n【Python 获取挂号信息并邮件通知】\n66、\n【Python实现java web项目远端自动化更新部署】\n67、\n【使用 Python3 编写 Github 自动周报生成器】\n68、\n【使用 Python 生成分形图片】\n69、\n【Python 实现 Redis 异步客户端】\n70、\n【Python 实现中文错别字高亮系统】\n 最后：\n 以上项目列表希望可以给你在Python学习中带来帮助~\n作者：实验楼\n链接：\nhttps://www.\njianshu.com/p/b577a1655\n144\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"},
{"title": "Python 有那么神吗？", "description": "简单远程控制电脑（当然微信应该更好些）：【Python】利用邮件远程控制自己电脑 Python字符动画： 效果： 【Python】视频转字符动画 表白小软件：Python仿制抖音表白小软件", "article": "原文不定期更新：\n2018-11-05补充内容4，GAN生成短视频\n2019-02-18补充一些个人开源的小项目代码链接（GitHub上都给出了介绍页链接）：\n（1）微信小助手\nCharlesPikachu/WechatHelper\n（2）一些实用工具集\nCharlesPikachu/Tools\n（3）免费代理获取\nCharlesPikachu/FreeProxy\n3. 2019-06-11\n 更多新的小项目可以关注我的Github动态/我的微信公众号\nCharlesPikachu - Overview\n譬如最近的：\n部分网站模拟登录：\nhttps://\ngithub.com/CharlesPikac\nhu/DecryptLogin\n颜值预测V2：\nhttps://\ngithub.com/CharlesPikac\nhu/isBeauty\nCNNLifeGame：\nhttps://\ngithub.com/CharlesPikac\nhu/CNNLifeGame\nFaster RCNN复现：\nhttps://\ngithub.com/DetectionBLW\nX/FasterRCNN.pytorch\nFPN复现：\nhttps://\ngithub.com/DetectionBLW\nX/FPN.pytorch\n4. 2019-12-14\n更新优化了一下坦克大战游戏版本，升级到v0.2。\n为什么没有呢？反正我用着感觉挺舒服的，想干嘛就干嘛。\n本回答内容包括：\n写写小游戏\n让电脑自己来玩小游戏\n写写爬虫\n写写深度学习/机器学习有趣的小玩意\n其他无厘头但有趣的事情\n写写小游戏？\n比如坦克大战：\n坦克大战\nhttps://www.zhihu.com/video/1188976781536120832\n介绍：\n震惊，博主终于更新了坦克大战小游戏！！！\n源代码在这（里面还有其他一些小游戏）：\nCharlesPikachu/Games\n写完小游戏能不能让电脑自己玩呢？\n当然也可以啊！\n（1）比如AI贪吃蛇（因为跑完时间有点久，就上传一段视频吧）：\nhttps://www.zhihu.com/video/1015221318500904960\n400多分的时候（懒得跑下去了【可能是因为太绿了】，应该有几率可以占满屏幕的）：\n源代码在这（该项目会持续增加一些AI玩游戏的例子）：\nCharlesPikachu/AIGames\n（2）DQN玩Chrome的那个彩蛋游戏\n2018-08-24简单补坑（能跑2k左右吧，等我完成了Flag再上视频）：\nDQN玩T-Rex Rush(上)\n写写爬虫？\n比如想下载一些音乐和视频，但又懒得下载客户端，那就自己写个音乐下载器和视频下载器：\n源代码在这：\nCharlesPikachu/Music-Downloader\nCharlesPikachu/Video-Downloader\n当然你也可以爬爬QQ空间来偶尔怀个旧：\nPython爬取QQ空间信息（下）\n当然也可以是微信：\nPython简单分析微信好友\n没书看的时候可以爬爬豆瓣：\nPython与豆瓣读书\n分析分析知乎自己粉丝的构成：\nPython爬取并简单分析知乎用户粉丝构成\n等等。\n写点有趣的深度学习/机器学习代码？\n（1）风格迁移\nPython简单实现图像风格迁移\n梵高笔下的老北京：\n其他：\n（2）颜值预测\nPython实现颜值预测\n周末了，来测下自己的颜值如何？\n（3）生成动漫头像\n【Python】利用GAN生成动漫头像\n（4）利用GAN网络生成短视频\n只有源代码：\nCharlesPikachu/VideoGan\n（5）生成会跳舞的小姐姐\n效果和介绍：\n用神经网络来生成会跳舞的小姐姐呀~\n源代码在这：\nhttps://\ngithub.com/CharlesPikac\nhu/DanceNet\n等等。\n或者干点其他无厘头的事情？\n生成小姐姐：\n【Python+VBA】在Excel中生成小姐姐\n简单远程控制电脑（当然微信应该更好些）：\n【Python】利用邮件远程控制自己电脑\nPython字符动画：\n效果：\nhttps://www.zhihu.com/video/1015227123690237952\n【Python】视频转字符动画\n表白小软件：\nPython仿制抖音表白小软件\n欢迎关注我的微信公众号：Charles的皮卡丘，不定期分享有趣好玩的Python项目以及大量的学习资源。\n最后再声明一下：\n代码仅供学习交流，禁止其他用途。"},
{"title": "再见，Python！你好，Go语言", "description": "比起大家熟悉的 Python，Go 语言其实有很多优良特性，很多时候都可以代替 Python，他已经在很多任务中使用 Go 语言替代了 Python。那么 Go 语言到底有着什么样的独特魅力", "article": "各位亲爱的开发者们，为了给大家分享更多精彩的技术干货，给大家创造更加纯净的开发者交流环境，请移步至\ncsdn平台华为云专区\n哦，点击传送门关注：\nhttps://\nblog.csdn.net/devcloud\n【小宅按】Go 语言诞生于谷歌，由计算机领域的三位宗师级大牛 Rob Pike、Ken Thompson 和 Robert Griesemer 写成。由于出身名门，Go 在诞生之初就吸引了大批开发者的关注。诞生十年以来，已经涌出了很多基于 Go 的应用。就在不多久之前，知乎也舍弃了 Python，转 用Go 重构推荐系统 。\n谷歌前员工 Jake Wilson 认为，比起大家熟悉的 Python，Go 语言其实有很多优良特性，很多时候都可以代替 Python，他已经在很多任务中使用 Go 语言替代了 Python。那么 Go 语言到底有着什么样的独特魅力？它有哪些胜于 Python 的地方呢？让我们一起来了解一下吧！\n2019 年程序员最想学习的编程语言\n出身名门的 Go 语言\n对于一门只有十年历史的新语言，Go 的发展势头相当迅猛，容器界的扛把子 Docker 就是用 Go 写的，国内也有不少团队广泛使用 Go。近日，HackerRank 在社区发起了程序员技能调查，来自 100 多个国家、超过 70000 名开发者参与其中。调查结果显示，2019 年，程序员最想学习的编程语言 Top 3 分别是 Go、Kotlin 和 Python，其中 Go 以 37.2% 的比例排在首位。\n但 Go 要想撼动编程界的常青树 Java 二十多年的地位无疑难度颇大。据 HackerRank 数据显示，2018 年，Java 在开发者最受欢迎的编程语言排行榜中仍然排名第 2，Python 排名第 4，Go 排名第 13，距离第一名 JavaScript 还有不小的差距。\n但对本文作者 Jack Wilson 来说，Go 语言虽然“年纪尚小”，但已经拥有很多非常优秀的特性。\nGo 语言到底好在哪？\n在很多任务上，我已经用 Go 语言代替了 Python，举几个例子：\n处理储存在 S3 上的云端日志\n在 S3 上的 bucket 和 / 或 region 之间移动 TB 级别大小的文件\n匹配本地的数据库记录和 S3 上的文件，以保证文件处于同步状态\n这些任务大多是一次性的，所以使用脚本语言操作就会比较合适。这些任务需要快速地编程，而代码用过一次一般就舍弃了。一般来说，这种任务的需求都比较新颖、比较专，其代码很少需要复用。下面就来介绍一下，针对这种任务为什么可以用 Go 语言来替代 Python。\n拥有编译器很方便\n我经常在写 Python 时犯很低级的错误。我会给变量或函数命错名，或向它们传递错误的参数。这样的错误用调试工具可以找出一部分，但这种工具一般需要专门设置。我从来没很方便地配置过 pylint，而且我也不喜欢用那些很重的、配置起来更麻烦的 IDE。最惨的情况是，你可能会不小心打错变量名，而这种错误又不太容易发现。你的脚本可能会跑好几个小时才遇上这个错误，然后一切都崩溃了，你又得从头开始跑这个脚本。这种错误大部分都可以靠单元测试检出，但单元测试很少能覆盖 100% 的代码，而且我并不想浪费时间去给一个只用一次的脚本写单元测试。而带编译器的语言就可以解决以上所有问题。\n编译器可以检测出你犯的所有低级错误。\n出于这点原因，我在写长达几百行的代码时，更倾向于使用 Go 这类语言。\n开发速度\n然而，需要编译的语言的一个缺点是，一般你的开发速度会下降。这点在 C/C++ 和 Java 等语言上体现得尤其明显。而 Go 是一个非常简单的语言，我发现它的开发速度并没有被拖慢多少。不要误会，我的意思并不是说它比 Python 还快，而是想说，\n用 Go 语言没有比 Python 慢很多，一般达到使用 Python 开发速度的 85% 还是没问题的。\n相对于拥有编译器能避免的那些低级错误来说，我认为牺牲 15% 的开发速度还是很值的。\n更好的并行性\n你可能已经知道，\nGo 语言就是为并行而生的\n。在我的团队里经常会需要并行程序，因为我们要在 S3 上操作我们数据库中大量的数据。如果该任务是 IO 密集型的（实际上很多任务都是），我们就可以很容易地部署 Python 线程。但如果任务是 CPU 密集型的，用 Python 就比较不方便了，因为有全局解释器锁的存在。我非常享受在 Go 语言中简单代码不用修改就能直接多线程运行的爽快感。不知你在 Python 中有没有遇到过这种问题：直接复制粘贴的多线程代码却完全不工作。在 Go 语言中就不会有此问题。\n部署简单\n我比较喜欢把所有依赖放在单个二进制文件里。我经常在 EC2 服务器上运行自己的脚本，好让环境更加接近我们在 S3 上的服务器。如果用 Python 的话，我需要保证所有需要的包都在服务器上装好，而且我的同事不能在服务器上装任何可能产生冲突的包。虚拟环境可以解决大部分问题，但我还是觉得用 Go 语言更方便。我一般是在 Mac 和 Linux 上交叉编译我的代码，将其拷贝到远程服务器上，然后就可以任其运行了。我的代码所需要的所有依赖都在一个二进制文件里。\n风格一致\n一开始，Go 语言的格式化工具 gofmt 实在是让我抓狂，尤其是它在代码缩进时要求使用 tab 键而不是空格键。我觉得这简直是疯了。但是我用了一段时间后，就开始“真香”了。写代码时，我在格式上可以天马行空，格式化工具会帮我完成一切。我的所有代码风格都是一致的，即使我是在写不同的项目。这是因为\n格式化是标准 Go 工具的一个特性\n。但我如果想在 Python 中实现这一点，就要费些劲儿了。我需要正确地配置 pylint 工具，并要保证在每一个项目中都使用它。\n更便捷的工具\nGofmt 只是 Go 语言众多工具中的一个小例子。所有我喜欢用的编辑器——VSCode，vim 和 Sublime Text 中，都有 Go 语言相应的扩展，让我能够方便地享受到 Go 工具的优点。这样，我就能获得写 Java 时的那种智能体验，却不需要真正使用一个 IDE。我在用 Python 时从未获得过这种体验。\nGo 语言当然也有缺点\n我每次看到批评 Go 语言的文章时，里面讲的几乎都是 Go 语言对关键特性的缺失，比如泛型。我倒是认为没有泛型没什么影响——你会发现，使用map和切片（Slice）就能实现多得惊人的操作。但是我在使用 Go 语言的过程中遇到了很多其他问题。\n缺乏灵活性\n首先，\nGo 语言可能是我用过的语言里最“固执”的语言\n了。比如，它除了会强迫你使用 tab 而不是空格键缩进（假设你用了 gofmt 工具），会强迫你使用特定的文件组织结构，还会强迫你在 GOPATH 环境变量中编程，如此等等。这种语言有太多难以改变的特性了。\nGo 语言简单易学的原因之一恐怕就是你不能改变这些特性\n。如果你不愿意将所有首字母大写的变量名 export 一遍，那真是抱歉了。幸运的是，Go 的这些特性倒是没有触犯我的原则底线，但是如果有人认为里面的某些要求根本无法理喻，我也能够理解。相比之下 Python 就灵活多了。\n库支持有点差劲\n在这方面把 Go 语言和 Python 做比较有些不公平。Go 的出现比 Python 晚很多，但当我发现有些功能 Go 居然不支持的时候，还是觉得很困惑。我甚至发现 StackOverflow 上很多人 po 出了本应该作为内置功能的代码段，而且大家都需要该功能，纷纷将代码复制粘贴到自己的项目下。这类功能不应该嵌入到语言内部吗？说到这里，我想到了近几年的两个例子：\n给切片排序（幸运的是在 Go 1.8 版本中这点方便多了）\nMath.round 只支持整数，不能进行浮点数的取整（比如你想找一个最接近 0.5 的整数，Go 语言就无法完成）。甚至在 Go 1.10 版本之前，根本没有 math.round 函数\n当然，这些问题的原因有一部分是 Go 语言没有泛型，另一部分是因为 Go 的开发者们只给 Go 的标准库中添加最最必要的功能。\n这两点我都理解，但是在遇到很小的问题却需要自己写代码解决时还是感到烦恼。希望随着 Go 语言的发展，它的问题会变得越来越少。\nGo 和 Python 你更喜欢谁？欢迎留言交流！\n作者介绍：\nJake Wilson，现任 SketchUp web team 技术经理，研究范围包括 HTML5、WebGL、Google Closure、Typescript、Java Redis 后端开发等，从事软件开发、硬件、产品、创业和激励方面的工作。他曾就职于 \nhttp://\nBoxuno.com\n、\nhttp://\nMonolla.com\n、谷歌等公司。在谷歌，他曾参与 Goole+、chrome、Webmaster Tools 等项目。\n更多精彩内容，请滑至顶部点击右上角关注小宅哦~\n来源：\nAI前线\n   译者：李志  作者：Jack Wilson  \n原文链接"},
{"title": "初学 Python 需要安装哪些软件？", "description": "以把二进制程序从硬盘载入到内存中并运行。但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。执行Python就需要用到Python解释器，按版本划分", "article": "Python这几年热度逐渐上升，在很多高校Python也被列为通识课程，之所以如此受欢迎正是由于它的高效、简洁、易用、强大的第三方库等优点。如今在web开发、人工智能、大数据等方便应用非常广泛。不管你是否喜欢，不管怎么吐槽，如果想要从事人工智能，依然很难绕过Python，虽然这两年julia、Go被炒得也很热，但是在人工智能方面依然无法撼动Python的地位。\n目录\nPython解释器\nIDE\npip代理\n虚拟环境\nPython解释器\n编程语言都会涉及编译器或者解释器，使用C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。运行该程序的时候，就可以把二进制程序从硬盘载入到内存中并运行。但是对于Python而言，python源码不需要编译成二进制代码，它可以直接从源代码运行程序。执行Python就需要用到Python解释器，按版本划分，Python解释系可以分为：\n2.x\n3.x\n2.x版本目前已经不再进行维护，所以目前大多数项目都是使用3.x，我个人比较推荐用3.6.x版本，3.7.2是目前最新的版本，但是使用过程中会有这样那样的错误，会存在不兼容等问题，而3.5.x及以下的版本也存在一些问题：\n前缀f格式化字符串在3.6.x之后才开始支持\n安装工具包时3.5.x安装相关依赖容易失败\n安装步骤：\n下载解释器\nPython Releases for Windows\n双击安装\n记得勾选pip，这是Python的包管理工具，会经常用到\nIDE\nIDE(Integrated Development Environment, 集成开发环境)，目前Python的IDE有很多，vs code、eclipse、atom、anaconda、IDEA等等，我个人不太推荐使用上述这些IDE，当然如果十分喜欢这些IDE也可以。对于开发Python，我只推荐pycharm和jupyter notebook两款。毋庸置疑，这是Python最强大的IDE。跳转、关联第三方库、速度、集成度、debug等等，可以说pycharm在Python开发中大多数方面表现的都很优秀，而vs code、eclipse、anaconda、atom只是在某一个或几个方面表现还可以。首先vs code关联第三方库、函数提示等方面很慢、服务器下容易卡顿，eclipse需要额外配置Python插件，anaconda集成太多包，有很多是自己用不到的，太臃肿了，atom没用过，不过也不感兴趣，所以，我觉得使用这些IDE还不如配置一下vim。如果说不喜欢每种语言安装一个IDE，喜欢像eclipse这样支持不同语言的IDE，我支持使用IDEA，这和pycharm属于同一家的产品，很多特性有共通之处。\npycharm优点：\n功能丰富\n提示速度快\n强大的书签和跳转功能\n高效的debug\n学生可以注册免费使用专业版\n...\npycharm安装步骤：\n下载pycharm\n如果没有购买专业版，可以下载社区版免费使用：\nhttp://www.\njetbrains.com/pycharm/d\nownload/#section=windows\n如果有学校的邮箱，可以注册教育版，和专业版没什么区别：\nDownload PyCharm Edu: Python IDE to Learn Programming by JetBrains\n进行安装\n双击可执行文件、选择安装目录进行安装就行了。\n配置解释器\nsetting->Project->Project Interpreter\n在红框位置选择上面安装的Python解释器\n要检查一下，因为Python默认是生成一个虚拟环境，使用虚拟环境中的解释器\njupyter notebook优点：\n交互式调试\n随时切换Markdown和code，边做笔记边写代码\njupyter notebook安装步骤：\n打开cmd\n用pip安装\npip install jupyter notebook\npip代理\npip是Python的包管理工具，无论是自己再cmd、终端下安装还是使用pycharm这些IDE安装包，都会调用pip。\n默认的代理是从pypi上下载并安装包，速度会比较慢，所以需要配置一下pip的代理，这样速度会得到大大的提升，如图中所示，利用默认的下载速度之后几百k，配置代理后可达到2.1M/s。\npip代理配置步骤：\n创建pip文件夹\n在个人目录下创建一个pip的目录，比如C:\\Users\\li，\n创建代理文件\n进入C:\\Users\\li\\pip目录，创建名为[pip.ini]的文件，打开把下面这段文字复制进去并保存：\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n虚拟环境\nPython和其它编程语言一样，面临一个移植问题，如果想把开发完成的一个项目一直到其他电脑、节点或者把项目打成docker镜像，都需要对开发环境重新配置，需要重新安装项目中使用到的第三方工具包，如果一个个比对着安装必然会很麻烦，而我们用系统环境时pip安装的包都被安装进了Python路径下site-packages里面，如果生成requirement.txt时也会把site-packages下的所有包都会包含进去，这就是为什么使用到虚拟环境的原因，能够针对不同项目创建一个独立的环境，这样便于后期的移植。\nPython虚拟环境管理工具主要有以下两种：\nvirtualenv\npipenv\n上述两个工具都可以使用pip进行安装：\npip install virtualenv\npip install pipenv\nvirtualenv和pipenv该怎么选择？我觉得这根据个人喜好。\nvirtualenv更加悠久，老化一些，使用步骤如下：\n创建虚拟环境\nvirtualenv test_env\n激活虚拟环境\ntest_env\\Scripts\\activate\n生成requirement\n激活虚拟环境后就可以进入虚拟独立的环境进行开发，如果开发完成之后想一直到另外一个系统：\npip freeze > requirement.txt\n这样就把虚拟环境里的包和版本读取到requirement.txt里，如果想在另一个系统配置安装这些包可以使用pip：\npip install -r requirement.txt\npipenv更加强大一些，pipenv之于Python就相当于Php之于Composer、Nodejs之于npm、Golang之于dep，pipenv相当于virtualenv和pip的合体，用两点说明pipenv对比于virtualenv的优势：\nvirtualenv每次开发完都要手动执行一个pip freeze > requirement.txt 把项目最新的环境读取到requirement中，如果忘记了就不能获取最新的配置环境，而pipenv可以实时监测环境的改变，把最新的环境读取到Pipfile。\nvirtualenv需要先激活虚拟环境，然后用pip配置，而pipenv可以直接使用pipenv进行配置环境\npipenv使用步骤：\n创建\npipenv check\n这是目录下会生成Pipfile。\n启动虚拟环境\npipenv shell\n安装第三方包\npipenv install **\n退出虚拟环境\nexit\n查看所有安装包\npip list\n查看包依赖关系\npipenv graph\n查看虚拟环境路径\npipenv --venv\n卸载安装包\npipenv uninstall\n以上就是两款常用的虚拟环境管理工具，相比而言pipenv更加强大，而我个人用virtualenv更久一些，所以也习惯用virtualenv，每个人可以根据自己的喜好进行选择。\n福利\n我整理了一些计算机视觉、Python、强化学习、优化算法等方面的电子书籍、学习资料，同时还打包了一些我认为比较实用的工具，如果需要请关注公众号【平凡而诗意】，回复相应的关键字即可获取~\n更多我的作品\nJackpop：有哪些堪称「神器」，却鲜为人知的APP？\nJackpop：Windows 下有什么用过之后就离不开的冷门软件？\nJackpop：你读过哪些令你有跪感的书？\nJackpop：你的研究生导师是什么样的？\n如果觉得有帮助，记得关注一下哦，也可以关注公众号“平凡而诗意”，会定期分享计算机视觉、机器学习、实用工具、学习资料等方面的内容，回复关键字也可以获取“福利”哦   ( ੭ ˙ᗜ˙ )੭"},
{"title": "编程零基础应当如何开始学习 Python？", "description": "一. Python基础 Python基础01 Hello World! Python基础02 基本数据类型 Python基础03 序列 Python基础04 运算", "article": "零基础学编程，用python入门是个不错的选择，虽然国内基本上还是以c语言作为入门开发语言，但在国外，已经有很多的学校使用python作为入门编程语言。此外，python在机器学习，人工智能领域也非常流行，算得上是算法工程师的标配编程语言。\n下面的内容由浅入深，建议按照先后顺序阅读学习。如果你觉得内容不错，希望别做松鼠党，收藏了就不了了之，坚持读完，有条件的最好是购买书籍阅读效果更好。本文分享的内容和文末推荐的书籍均出自vamei君。\n一. Python基础\nPython基础01 Hello World!\nPython基础02 基本数据类型\nPython基础03 序列\nPython基础04 运算\nPython基础05 缩进和选择\nPython基础06 循环\nPython基础07 函数\nPython基础08 面向对象的基本概念\nPython基础09 面向对象的进一步拓展\nPython基础10 反过头来看看\n二. Python进阶\nPython进阶01 词典\nPython进阶02 文本文件的输入输出 \nPython进阶03 模块 \nPython进阶04 函数的参数传递 \nPython进阶05 循环设计 \nPython进阶06 循环对象 \nPython进阶07 函数对象 \nPython进阶08 错误处理 \n三. Python深入 \n到现在为止，Python学习已经可以告一段落。下面的部分，我想讨论Python的高级语法和底层实现。这一部分的内容并不是使用Python所必须的。但如果你想从事一些大型的Python开发(比如制作Python工具、写一个框架等)，你会希望对这一部分内容有所的了解。 \nPython深入01 特殊方法与多范式\nPython深入02 上下文管理器\nPython深入03 对象的属性\nPython深入04 闭包\nPython深入05 装饰器\nPython深入06 内存管理\n四. Python标准库 \nPython标准库的重要性在于：\n标准库是Python的一个组成部分。\nPython的哲学是一个问题只有一个最好的解决方法。这些标准库为许多问题提供了一个标准的解决方案。\nPython标准库——走马观花\nPython标准库的学习准备\nPython标准库01 正则表达式 (re包)\nPython标准库02 时间与日期 (time, datetime包)\nPython标准库03 路径与文件 (os.path包, glob包)\nPython标准库04 文件管理 (部分os包，shutil包)\nPython标准库05 存储对象 (pickle包，cPickle包)\nPython标准库06 子进程 (subprocess包)\nPython标准库07 信号 (signal包)\nPython标准库08 多线程与同步 (threading包)\nPython标准库09 进程信息 (部分os包)\nPython标准库10 多进程初步 (multiprocessing包)\nPython标准库11 多进程探索 (multiprocessing包)\nPython标准库12 数学与随机数 (math包，random包)\nPython标准库13 循环器 (itertools)\nPython标准库14 数据库 (sqlite3)\n最后推荐知名博主vamei君的书，非常非常值得推荐的一本书。是对上述内容的一个整理提炼与扩充。\n附《从Python开始学编程》作者简介：\n张腾飞， 笔名 Vamei，中国科学技术大学学士，南洋理工大学博士。著有《从Python开始学编程》等书，并写作 Java、网络协议、数据分析等方面的教程。他的博客访问量超过800万。现从事智能农业领域的创新创业，任睿畜科技首席技术官。2019年2月28日夜因抑郁症去世。\n在朋友圈看到他去世的消息，震惊又难过，RIP！"},
{"title": "有编程基础学python怎么赚点小钱？", "description": "2019年最新web前端开发入门知识点 Python自学课程视频： Python入门教程完整版（懂中文就能学会） python入门必备指南 python6天摇身一变成大神 python网络爬虫第一天", "article": "800左右算是要求很低了，光一项爬虫，做好开发抓一些新闻证券的信息基本上月入就3-5k了。渠道自己可以去淘宝上找，或者让是猪八戒找一些兼职。具体的下文说，这是之前回答过的一个问题：\npython精通后能赚多少？平均情况。普通智商，刚毕业朝九晚五工作，每天4到5小时学多久精通？\nPython自由职业可以做什么：\n1.爬虫\n很多人入门Python的必修课之一就是web开发和爬虫。但是这两项想要赚钱的话，就必须知道开发什么爬什么数据才能赚钱。如果你都不知道的话问题也不大的，可以开个网店，或者猪八戒做服务外包。\n这里呢，还是需要找到好的项目，举个舒服的例子就是：帮一些证券大佬抓取一些财经新闻或者是舆情相关的数据，开发玩了之后每个月要保证爬虫不挂的话基本上可以收入3-5k。自己买个云主机的话，一个月要两三百的成本，自己还能做别的事情。\n2.量化交易\n用python来完成量化交易是很方便的，方然不涉及到高频交易，对于新手来说，这边比较推荐的JionQuant，新手教程和在线Python策略开发环境我个人认为都是比较优化的，做Quant其实就是一个做数据挖掘的过程。不同的策略就是你手中能用的模型，选股，择时，资金管理就是你所要做的特征工程。不需要纠结是用均线策略或者是BOLL，找到策略适应的股和择时才是关键。\n要追求稳定的收益的话，可以去考虑各种虚拟币交易市场搬砖，编程能力较弱的朋友可以考虑一下bots，统计逃离虽然也能稳定盈利但显然不合适个人了，一般需要HFT支持。\n3.代写程序或者是外包\n某宝上有不少的代写程序的，物美价廉，几百块就能搞定一套基于LAMP的xx管理系统，看看买家评论就会知道，绝大部分都是学生的大作业或者是毕设。\n这些能转多少钱呢？首先是不要帮别人写论文，这是吃力不讨好的事情，基本上后期你就会处于一直改稿的阶段。一般本科毕设都是偏工程研发的，这类门槛低，通用的代码很多，基本上找到开源的改一改就能完成任务。硕士毕业的有很多偏机器学习的，实现一个overfitting的算法实现，基本上也就是1-2天的功夫，前者1-2K，后者2-3k。\n4.白帽\npython是黑客的第一语言，还用多说吗？这边灰产不说了。只要爬虫公里足够强的话，刷个阅读排名点赞都是可以的。毕竟说透了都是模拟请求，只不过是有些简单HTTP Get请求。有些是通过Ajax提交的Post请求，还有就是写Socket请求，然后顺一下时间中不同请求的时间和依赖关系。\nPython相关学习的资源\n文章相关：\n为什么要学习Python编程语言？哪些人适合学习Python？\n非计算机专业想学一门编程语言，选什么好？\npython和java自学哪个好？\n2019年最新web前端开发入门知识点\nPython自学课程视频：\nPython入门教程完整版（懂中文就能学会）\npython入门必备指南\npython6天摇身一变成大神\npython网络爬虫第一天\npython网络爬虫第二天\n上述是课程学习均有网盘的资源，就是含有课件、课程笔记以及源码的资源。但是放网盘的话就会被和谐。有需要的留言或者私信我吧。"},
{"title": "干货！python爬虫100个入门项目", "description": "拉钩模拟登录--已失效 Bilibili模拟登录 对于python爬虫初学者，可以先看看爬虫需要哪些知识：如何入门 Python 爬虫？ python网络爬虫知识架构 资源来源：interesting-python", "article": "爬取糗事百科\n爬取妹子图\nPython 岗位分析报告\nSelenium介绍\n抖音App视频抓包\n \nBilibili 用户\nBilibili 视频\nBilibili 小视频\nBing美图爬虫\nB站760万视频信息爬虫\n博客园(node.js)\n百度百科(node.js)\n北邮人水木清华招聘\n百度云网盘\n琉璃神社爬虫\nBoss 直聘\n贝壳网找房爬虫\n \n暗网爬虫(Go)\n \n豆瓣读书\n豆瓣爬虫集\n豆瓣害羞组\n豆瓣图书广度爬取\nDNS记录和子域名\nDHT网络磁力种子爬虫\n抖音\n爱丝APP图片爬虫\n \n京东\n京东搜索+评论\n京东商品+评论\n机票\n煎蛋妹纸\n煎蛋妹纸selenium版本\n今日头条，网易，腾讯等新闻\n计算机书籍控图书\n \nQQ空间\nQQ 群\n清华大学网络学堂爬虫\n去哪儿\n前程无忧Python招聘岗位信息爬取分析\n \nsoundcloud\nStackoverflow 100万问答爬虫\nShadowsocks 账号爬虫\nspider163 网易云音乐爬虫\n时光网电影数据和海报爬虫\n \ntumblr\n下载tumblr喜欢内容\nTuShare\n天猫双12爬虫\nTaobao mm\nTmall 女性文胸尺码爬虫\n淘宝直播弹幕爬虫(node)\n天涯论坛文章\n天眼查爬虫\n \n乌云公开漏洞\n微信公众号\n“代理”方式抓取微信公众号文章\n网易新闻\n网易精彩评论\n微博主题搜索分析\n网易云音乐\n新.网易热评\n唯品会商品\n \nZOL 手机壁纸爬虫\n知乎(python)\n知乎(php)\n知网\n知乎妹子\n自如实时房源提醒\n中国大陆高校列表爬虫\n \n游戏直播行业真的如你想象般暴利？\n \n五一不看人人人人人人，哪儿耍合适？\n \n大碗宽面 VS 律师函警告，情感分析吴亦凡自黑式圈粉！\n \n没经验没学历的外教为啥能拿1.4W+的高薪？\n \n大胆，都是哪些程序员在反对996？！\n \n儿科医生的眼泪，全被数据看见了\n \n用大数据扒一扒蔡徐坤的真假流量粉\n \n北上广深租房图鉴\n \n六万条数据全面解析，城市春节禁放烟花爆竹真的有用吗？\n \n十万条评论告诉你，给《流浪地球》评1星的都是什么心态？\n \n开年表情包局部富有指南，盘它！\n \n看完这篇分析，楼下的Tony和Kevin都改名了！\n \n回复“实习僧”CTO之换种姿势爬取实习僧网站\n \n【20G】Kaggle数据集强势分析“绝地求生”，攻略吃鸡！\n \n50行代码教你打造一个公众号文章采集器\n \n《我是大侦探》到底怎么了？(上：数据爬取篇)\n \n《我是大侦探》到底怎么了？（下：情感分析篇）\n \n帮了个小忙|破解“实习僧”网站字体加密\n \n“小忙”连载篇|实习僧网站数据分析\n \nFacebook模拟登录\n微博网页版模拟登录\n知乎模拟登录\nQQZone模拟登录\nCSDN模拟登录--已恢复\n淘宝爬虫--重构中\nBaidu模拟登录一\n果壳爬虫程序\nJingDong 模拟登录和自动申请京东试用\n163mail--已恢复\n拉钩模拟登录--已失效\nBilibili模拟登录\n \n对于python爬虫初学者，可以先看看爬虫需要哪些知识：\n如何入门 Python 爬虫？\npython网络爬虫知识架构\n资源来源：\ninteresting-python\n，\nawesome-spider\n，\nawesome-python-login-model\nEND！\n此资源持续更新~~欢迎点赞收藏关注！"},
{"title": "当Python遇上微信，可以这么玩", "description": "有兴趣的朋友可以加上可视化的展示，我这里用基于python的Echarts（有机会再细讲） 先安装了pip install echarts-python 展示比例一般使用百分比圆饼表吧", "article": "代码放在这里：\nwzyonggege/python-wechat-itchat\n词云那里可以换成小黄人图片\n---------------------------------------------------------------------------------------------------\n0. itchat\n最近研究了一些微信的玩法，我们可以通过网页版的微信\n微信网页版\n，扫码登录后去抓包爬取信息，还可以post去发送信息。\n然后发现了\nitchat\n这个开源项目，\n作者是\n@LittleCoder\n，已经把微信的接口完成了，大大的方便了我们对微信的挖掘，以下的功能也通过itchat来实现。\n安装itchat这个库\npip install itchat\n\n先来段简单的试用，实现微信的登录，运行下面代码会生成一个二维码，扫码之后手机端确认登录，就会发送一条信息给‘filehelper’，这个\nfilehelper\n就是微信上的文件传输助手。\nimport\n \nitchat\n\n\n\n# 登录\n\n\nitchat\n.\nlogin\n()\n\n\n# 发送消息\n\n\nitchat\n.\nsend\n(\nu\n'你好'\n,\n \n'filehelper'\n)\n\n\n除了登录和发送消息我们还可以这么来玩，往下走～\n1. 微信好友男女比例\n想统计下自己微信里好友的性别比例，当然也是很简单，先获取好友列表，统计列表里性别计数\nimport\n \nitchat\n\n\n\n# 先登录\n\n\nitchat\n.\nlogin\n()\n\n\n\n# 获取好友列表\n\n\nfriends\n \n=\n \nitchat\n.\nget_friends\n(\nupdate\n=\nTrue\n)[\n0\n:]\n\n\n\n# 初始化计数器，有男有女，当然，有些人是不填的\n\n\nmale\n \n=\n \nfemale\n \n=\n \nother\n \n=\n \n0\n\n\n\n# 遍历这个列表，列表里第一位是自己，所以从\"自己\"之后开始计算\n\n\n# 1表示男性，2女性\n\n\nfor\n \ni\n \nin\n \nfriends\n[\n1\n:]:\n\n    \nsex\n \n=\n \ni\n[\n\"Sex\"\n]\n\n    \nif\n \nsex\n \n==\n \n1\n:\n\n        \nmale\n \n+=\n \n1\n\n    \nelif\n \nsex\n \n==\n \n2\n:\n\n        \nfemale\n \n+=\n \n1\n\n    \nelse\n:\n\n        \nother\n \n+=\n \n1\n\n\n\n# 总数算上，好计算比例啊～\n\n\ntotal\n \n=\n \nlen\n(\nfriends\n[\n1\n:])\n\n\n\n# 好了，打印结果\n\n\nprint\n \nu\n\"男性好友：\n%.2f%%\n\"\n \n%\n \n(\nfloat\n(\nmale\n)\n \n/\n \ntotal\n \n*\n \n100\n)\n\n\nprint\n \nu\n\"女性好友：\n%.2f%%\n\"\n \n%\n \n(\nfloat\n(\nfemale\n)\n \n/\n \ntotal\n \n*\n \n100\n)\n\n\nprint\n \nu\n\"其他：\n%.2f%%\n\"\n \n%\n \n(\nfloat\n(\nother\n)\n \n/\n \ntotal\n \n*\n \n100\n)\n\n\n好看看结果：\n（好吧，暴露了我男性友人较多的真相～～）\n好像不够直观，有兴趣的朋友可以加上可视化的展示，我这里用基于python的\nEcharts\n（有机会再细讲） \n先安装了\npip install echarts-python\n\n展示比例一般使用百分比圆饼表吧\n# 使用echarts，加上这段\n\n\nfrom\n \necharts\n \nimport\n \nEchart\n,\n \nLegend\n,\n \nPie\n\n\n\nchart\n \n=\n \nEchart\n(\nu\n'\n%s\n的微信好友性别比例'\n \n%\n \n(\nfriends\n[\n0\n][\n'NickName'\n]),\n \n'from WeChat'\n)\n\n\nchart\n.\nuse\n(\nPie\n(\n'WeChat'\n,\n\n              \n[{\n'value'\n:\n \nmale\n,\n \n'name'\n:\n \nu\n'男性 \n%.2f%%\n'\n \n%\n \n(\nfloat\n(\nmale\n)\n \n/\n \ntotal\n \n*\n \n100\n)},\n\n               \n{\n'value'\n:\n \nfemale\n,\n \n'name'\n:\n \nu\n'女性 \n%.2f%%\n'\n \n%\n \n(\nfloat\n(\nfemale\n)\n \n/\n \ntotal\n \n*\n \n100\n)},\n\n               \n{\n'value'\n:\n \nother\n,\n \n'name'\n:\n \nu\n'其他 \n%.2f%%\n'\n \n%\n \n(\nfloat\n(\nother\n)\n \n/\n \ntotal\n \n*\n \n100\n)}],\n\n              \nradius\n=\n[\n\"50%\"\n,\n \n\"70%\"\n]))\n\n\nchart\n.\nuse\n(\nLegend\n([\n\"male\"\n,\n \n\"female\"\n,\n \n\"other\"\n]))\n\n\ndel\n \nchart\n.\njson\n[\n\"xAxis\"\n]\n\n\ndel\n \nchart\n.\njson\n[\n\"yAxis\"\n]\n\n\nchart\n.\nplot\n()\n\n\n登登登登～\n2. 好友个性签名词云\n获取好友列表的时候，返回的json信息中还看到了有个性签名的信息，脑洞一开，把大家的个性签名都抓下来，看看高频词语，还做了个词云。\n# coding:utf-8\n\n\nimport\n \nitchat\n\n\n\n# 先登录\n\n\nitchat\n.\nlogin\n()\n\n\n\n# 获取好友列表\n\n\nfriends\n \n=\n \nitchat\n.\nget_friends\n(\nupdate\n=\nTrue\n)[\n0\n:]\n\n\nfor\n \ni\n \nin\n \nfriends\n:\n\n    \n# 获取个性签名\n\n    \nsignature\n \n=\n \ni\n[\n\"Signature\"\n]\n\n\nprint\n \nsignature\n\n\n先全部抓取下来 \n打印之后你会发现，有大量的span，class，emoji，emoji1f3c3等的字段，因为个性签名中使用了表情符号，这些字段都是要过滤掉的，写个正则和replace方法过滤掉\nfor\n \ni\n \nin\n \nfriends\n:\n\n\n# 获取个性签名\n\n    \nsignature\n \n=\n \ni\n[\n\"Signature\"\n]\n.\nstrip\n()\n.\nreplace\n(\n\"span\"\n,\n \n\"\"\n)\n.\nreplace\n(\n\"class\"\n,\n \n\"\"\n)\n.\nreplace\n(\n\"emoji\"\n,\n \n\"\"\n)\n\n\n# 正则匹配过滤掉emoji表情，例如emoji1f3c3等\n\n    \nrep\n \n=\n \nre\n.\ncompile\n(\n\"1f\\d.+\"\n)\n\n    \nsignature\n \n=\n \nrep\n.\nsub\n(\n\"\"\n,\n \nsignature\n)\n\n    \nprint\n \nsignature\n\n\n接来下用jieba分词，然后制作成词云，首先要安装jieba和wordcloud库\npip install jieba\npip install wordcloud\n\n代码\n# coding:utf-8\n\n\nimport\n \nitchat\n\n\nimport\n \nre\n\n\n\nitchat\n.\nlogin\n()\n\n\nfriends\n \n=\n \nitchat\n.\nget_friends\n(\nupdate\n=\nTrue\n)[\n0\n:]\n\n\ntList\n \n=\n \n[]\n\n\nfor\n \ni\n \nin\n \nfriends\n:\n\n    \nsignature\n \n=\n \ni\n[\n\"Signature\"\n]\n.\nreplace\n(\n\" \"\n,\n \n\"\"\n)\n.\nreplace\n(\n\"span\"\n,\n \n\"\"\n)\n.\nreplace\n(\n\"class\"\n,\n \n\"\"\n)\n.\nreplace\n(\n\"emoji\"\n,\n \n\"\"\n)\n\n    \nrep\n \n=\n \nre\n.\ncompile\n(\n\"1f\\d.+\"\n)\n\n    \nsignature\n \n=\n \nrep\n.\nsub\n(\n\"\"\n,\n \nsignature\n)\n\n    \ntList\n.\nappend\n(\nsignature\n)\n\n\n\n# 拼接字符串\n\n\ntext\n \n=\n \n\"\"\n.\njoin\n(\ntList\n)\n\n\n\n# jieba分词\n\n\nimport\n \njieba\n\n\nwordlist_jieba\n \n=\n \njieba\n.\ncut\n(\ntext\n,\n \ncut_all\n=\nTrue\n)\n\n\nwl_space_split\n \n=\n \n\" \"\n.\njoin\n(\nwordlist_jieba\n)\n\n\n\n# wordcloud词云\n\n\nimport\n \nmatplotlib.pyplot\n \nas\n \nplt\n\n\nfrom\n \nwordcloud\n \nimport\n \nWordCloud\n\n\nimport\n \nPIL.Image\n \nas\n \nImage\n\n\n\n# 这里要选择字体存放路径，这里是Mac的，win的字体在windows／Fonts中\n\n\nmy_wordcloud\n \n=\n \nWordCloud\n(\nbackground_color\n=\n\"white\"\n,\n \nmax_words\n=\n2000\n,\n \n                         \nmax_font_size\n=\n40\n,\n \nrandom_state\n=\n42\n,\n\n                         \nfont_path\n=\n'/Users/sebastian/Library/Fonts/Arial Unicode.ttf'\n)\n.\ngenerate\n(\nwl_space_split\n)\n\n\n\nplt\n.\nimshow\n(\nmy_wordcloud\n)\n\n\nplt\n.\naxis\n(\n\"off\"\n)\n\n\nplt\n.\nshow\n()\n\n\n运行代码\n这。。好像有点丑，根据wordcloud用法，我可以找一张图来生成配色方案，我这里找了一张微信的logo\n修改一下代码\n# wordcloud词云\n\n\nimport\n \nmatplotlib.pyplot\n \nas\n \nplt\n\n\nfrom\n \nwordcloud\n \nimport\n \nWordCloud\n,\n \nImageColorGenerator\n\n\nimport\n \nos\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nPIL.Image\n \nas\n \nImage\n\n\n\n\nd\n \n=\n \nos\n.\npath\n.\ndirname\n(\n__file__\n)\n\n\nalice_coloring\n \n=\n \nnp\n.\narray\n(\nImage\n.\nopen\n(\nos\n.\npath\n.\njoin\n(\nd\n,\n \n\"wechat.jpg\"\n)))\n\n\nmy_wordcloud\n \n=\n \nWordCloud\n(\nbackground_color\n=\n\"white\"\n,\n \nmax_words\n=\n2000\n,\n \nmask\n=\nalice_coloring\n,\n\n                         \nmax_font_size\n=\n40\n,\n \nrandom_state\n=\n42\n,\n\n                         \nfont_path\n=\n'/Users/sebastian/Library/Fonts/Arial Unicode.ttf'\n)\n\\\n    \n.\ngenerate\n(\nwl_space_split\n)\n\n\n\nimage_colors\n \n=\n \nImageColorGenerator\n(\nalice_coloring\n)\n\n\nplt\n.\nimshow\n(\nmy_wordcloud\n.\nrecolor\n(\ncolor_func\n=\nimage_colors\n))\n\n\nplt\n.\nimshow\n(\nmy_wordcloud\n)\n\n\nplt\n.\naxis\n(\n\"off\"\n)\n\n\nplt\n.\nshow\n()\n\n\n\n# 保存图片 并发送到手机\n\n\nmy_wordcloud\n.\nto_file\n(\nos\n.\npath\n.\njoin\n(\nd\n,\n \n\"wechat_cloud.png\"\n))\n\n\nitchat\n.\nsend_image\n(\n\"wechat_cloud.png\"\n,\n \n'filehelper'\n)\n\n\n嗯～好像还可以，这是Mac下生成的，附一个win10下生成的\n3. 微信自动回复\n接着来实现一个类似qq上的自动回复，原理就是接收到消息，就发消息回去，同时发一条给文件助手，就可以在文件助手中统一查看消息。\n代码很简单，来看看\n#coding=utf8\n\n\nimport\n \nitchat\n\n\n\n# 自动回复\n\n\n# 封装好的装饰器，当接收到的消息是Text，即文字消息\n\n\n@itchat.msg_register\n(\n'Text'\n)\n\n\ndef\n \ntext_reply\n(\nmsg\n):\n\n    \n# 当消息不是由自己发出的时候\n\n    \nif\n \nnot\n \nmsg\n[\n'FromUserName'\n]\n \n==\n \nmyUserName\n:\n\n        \n# 发送一条提示给文件助手\n\n        \nitchat\n.\nsend_msg\n(\nu\n\"[\n%s\n]收到好友@\n%s\n 的信息：\n%s\n\\n\n\"\n \n%\n\n                        \n(\ntime\n.\nstrftime\n(\n\"%Y-%m-\n%d\n %H:%M:%S\"\n,\n \ntime\n.\nlocaltime\n(\nmsg\n[\n'CreateTime'\n])),\n\n                         \nmsg\n[\n'User'\n][\n'NickName'\n],\n\n                         \nmsg\n[\n'Text'\n]),\n \n'filehelper'\n)\n\n        \n# 回复给好友\n\n        \nreturn\n \nu\n'[自动回复]您好，我现在有事不在，一会再和您联系。\n\\n\n已经收到您的的信息：\n%s\n\\n\n'\n \n%\n \n(\nmsg\n[\n'Text'\n])\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nitchat\n.\nauto_login\n()\n\n\n    \n# 获取自己的UserName\n\n    \nmyUserName\n \n=\n \nitchat\n.\nget_friends\n(\nupdate\n=\nTrue\n)[\n0\n][\n\"UserName\"\n]\n\n    \nitchat\n.\nrun\n()\n\n\n\n运行后会保持登录状态，开启自动回复模式，手机上查看：\n当然，除了文字Text信息，还可以接收图片（表情包算图片），语音，名片，地理位置，分享和类型为Note的信息（就是有人提示类的消息，例如撤回消息），把装饰器写成下面形式即可接受，大家可以试试\n@itchat.msg_register(['Map', 'Card', 'Note', 'Sharing', 'Picture'])\n\n4. 最后\n除了上面这些，还可以做到管理微信群，自动添加好友，还可以加入机器人回复功能，有时间会补上。\n再次感谢\nitchat\n作者\n@LittleCoder"},
{"title": "学习Python的建议", "description": "尤其是没掌握排查BUG技巧时。 如果初学者接触的第一门语言是Python，学习曲线则会平滑得多，掌握一些基本语法和Python内置的数据结构，已经可以上手写一些小工具或者小型应用", "article": "Python是最容易入门的编程语言，没有之一。如果初学者接触的第一门语言是C或者C++，对他们来说最难的不是语法，而是容易出现内存泄漏、指针等问题。有时候排查这些问题对初学者的打击很大，尤其是没掌握排查BUG技巧时。\n如果初学者接触的第一门语言是Python，学习曲线则会平滑得多，掌握一些基本语法和Python内置的数据结构，已经可以上手写一些小工具或者小型应用。这对初学者来说，非常重要。因为学习的过程是一个突破舒适区的过程，会面临很多痛苦，如果学习过程得不到激励，很容易半途而废，类似我们开玩笑说的「从入门到放弃」。Python还有很多优点：上手快，第三方库丰富，资料丰富，很容易做出“可见可得”的应用。比如你要拿C或者C++做web服务，这上手门槛就有点高了。所以很多工科学生，甚至是科班学生会问学了C/C++到底有什么用，因为想上手做一些“可见可得”的应用太难。Python就大不同，你想搞Web开发？上来一个Flask框架立马就撸。想搞点数据分析？上来一个Panda+数据可视化，撸起来轻松愉快甚有快感。想抓取什么数据？你自己基于request撸一个小爬虫采集点网站信息，app信息都不是什么难事。 \n也是因为这样，学习Python的过程几乎接近“无痛”，有很好的学习正反馈过程，学一点知识就能做一点小东西，能看得到自己成长和进步。安利了这么多好处，来看看学Python分几个阶段吧。\n1.基础知识\nPython最基本的语言特性和语法:\n变量 \n数据类型与数据结构 \n输入和输出 \n运算符、表达式、语句 \n控制流(顺序控制，选择控制和循环控制) \n面向过程编程\n面向对象编程 \n异常处理\n组织代码 \n标准库、第三方库\n针对面向对象这一块需要重点的讲一下，为什么会有面向对象？以及我们如何设计面向对象系统？这个思考的过程有助于你理解面向对象编程思想。\n可以说「一切皆对象」这句话普适性是很强的，大家都在玩的王者农药，里面每一个对战英雄，每一个野怪，每一张地图都是通过面向对象的思想构建起来的。如果一开始你觉得太复杂，大可把用「分而治之」的思想把复杂的对象break down，分解成多个简单合理的对象。任何复杂的系统都可以由若干个简单可靠的系统组成，多个简单可靠的系统有序地组织起来是可以实现强大功能的。举个例子，还拿农药来说，”英雄“是可以作为一个基类的对吧，每个英雄都有血条，移动速度，AD，AP，物防，法扛等等。李白平A后裔一下，这是对象之间的通信（或者说交互）。后裔放大打中李白，李白眩晕，这一系列的触发过程都可以通过面向对象来建模。\n在掌握了语法特点，掌握了面向对象的思想之后，我们应该能够在控制台（windows或者mac的命令行）里边实现一个有意思的程序。这个程序应该解决现实生活中的一个实际问题。比如出现一个职位的发布和管理系统。有以下功能。我们可以录入职位信息。保存到文件上。我们还可以加载职位信息。按多种条件去查询，比如按关键字按城市。按薪资范围。按商圈工作年限等等。\n在做这个的过程中，自己需要设计一个很好的面向对象系统。也把Python里常用的语言基本特性都用到了。达到这个阶段算是勉强及格了吧，不过仅仅是在语言掌握层面。如果想当一个合格的研发工程师，还需要掌握很多其他技能。\n2. 进阶的阶段\n现在的开发大部分是基于web的，比如app要调web接口，pc端肯定也要调web接口，所以我们不能光在控制台里面玩。这个时候需要了解，http协议和Python web开发。我们可以重做前面提到的求职发布系统，学习基于Python web如何实现。这个时候你需要实现若干个接口：\n用户端：\n用户注册\n用户登录\n请求首页刷出默认的职位列表\n筛选职位列表\n根据城市\n根据关键字\n根据薪酬\n根据工作商圈\n管理后台：\n登录\n发布职位\n更新职位\n删除职位\n为了实现以上接口，你需要弄清楚什么是GET，什么是POST请求，什么场景下用GET，什么场景用POST。你还需要明白一个Python web开发框架，要明白一个http请求到了web框架之后，框架做了什么事情，如何在里面实现业务逻辑。哪些数据是服务共享的，哪些数据是用户/请求独享的。\n此外，应该学会Python如何操作数据库实现增删改查，大部分的任务都离不开增删改查。比如我提到的发布职位就是create的过程，更新就是update，还有删除是delete，读是read。江湖有一个戏称CRUD boy。\n如果能顺利度过进阶阶段，你应该能举一反三实现其他类似系统了。比如现在很火的分销，拼团，还有新闻Feeds等等。\n好像我没怎么提数据结构和算法，这个要看个人追求。如果你要在最短时间内学会Python开发，恐怕是没时间学好数据结构和算法了，能掌握自带的数据结构用法就行。如果你的学习时间充足，我的建议是一定要学数据结构和算法。为了以后长期的发展，为了人民币，一定要学好数据结构和算法，我简直苦口婆心地劝啊。\n3. 工业界经验\n最后一个阶段是实际的工业经验。这个阶段，你应该对公司用的基础架构，如RPC，数据库缓存消息系统中间件，烂熟于心。同时应该掌握最基本的系统设计的技巧。知道如何根据一个实际需求，设计一个高可用，高性能高扩展性的系统。\n实际上我觉得第一个阶段是最容易的，第二个阶段会碰到一些坑，有时候不好解决。在第二个阶段，你可能需要比较好的自学能力，或者有一个好的学长导师。第三个阶段需要比较体系化的训练和思考。\n如果说你的系统设计能力ok，甚至经验丰富，再加上你不错的算法，你肯定有一份好工作，薪资可能说多了显浮夸，但优秀的应届生很多人超过30w，甚至50w已经是常态了。工作3-5年的过百万的也大有人在。\n这个时代，程序员虽然辛苦了一点，但无疑碰上最好的时代了。\nPS：辛苦是因为知识更新很快，行业发展也很快，逼着程序员也要往前走。保持学习才是从业者的基本素养，而不是掌握某门语言某门技术。\n有问题可以加卫星探讨。\nwx: hepulaocai\n厚脸皮🐵一波\n凯威讲堂"},
{"title": "Python 的开发效率真的比 Java高吗？", "description": "则动态语言维护起来可能反而更加省心。 实际上，Python开发的中型、大型项目很多，包括各类底层库、框架、大型系统等等。Python的系统库自然也是用Python开发的。Python的生态系统非常优秀", "article": "多说一句，用Python开发项目的，可以试试pylint之类的工具，还是能检查出一些常见的问题的，当然还是那句话，测试（TDD）为主\n======================================================\n统计了一下两个主要负责的项目的行数，只计.py文件，不计空行，计注释和docstring\n一个是开源的VLCP\nhubo1016/vlcp\n源代码约45000行，单元测试约3500行，集成测试1411行，开发三年左右了，最近升到了Python 3.5+\n另一个是公司内部使用的项目，代码约23000行，集成测试7000行，单元测试700行左右，Python 3.6+，这个项目包括web前端、Python后端等多个组件，CI相关的shell脚本有一千行左右\n这两个项目个人认为都是很成功的，也不难维护，以后一个为例，小的新需求一般2小时到一天就能上线，大的功能版本有时候要开发一个月，后端是两到三人的小团队。\n======================================================\n总是看到说Python不能开发大型项目的说法，对这个问题我是这样理解的：\n从结论上来说，觉得Python开发项目不好维护，可能有两个方面的原因：1. 不熟悉Python的特性，沿用了Java等静态语言的开发模式和思路 2. 设计水平还不到家，走了弯路\n尤其是，我们后面会提到，\n如果设计水平不够，或者开发时没有严守设计，动态语言代码劣化得会比静态语言快得多。但反过来，如果设计优秀，开发时严守设计，则动态语言维护起来可能反而更加省心。\n实际上，Python开发的中型、大型项目很多，包括各类底层库、框架、大型系统等等。Python的系统库自然也是用Python开发的。Python的生态系统非常优秀，其实也是Python工程能力出众的表现。\n再比如说有人举Google的例子，Guido亲自编写的项目后来用Java重写了，我们来看一下官方的说法（来自Gerrit官方网站）：\nGoogle Mondrian\nGoogle developed \nMondrian\n, a Perforce based code review tool to facilitate peer-review of changes prior to submission to the central code repository. Mondrian is not open source, as it is tied to the use of \nPerforce\n and to many Google-only services, such as \nBigtable\n. Google employees have often described \nhow useful Mondrian and its peer-review process is\n to their day-to-day work.\n……\nThe Rietveld fork\nGerrit Code Review started as a simple set of patches to Rietveld, and was originally built to service AOSP. This quickly turned into a fork as we added access control features that \nGuido van Rossum did not want to see complicating the Rietveld code base. As the functionality and code were starting to become drastically different\n, a different name was needed. Gerrit calls back to the original namesake of Rietveld, \nGerrit Rietveld\n, a Dutch architect.\nGerrit 2.x rewrite\nGerrit 2.x is a complete rewrite of the Gerrit fork, changing the implementation from Python on Google App Engine, to Java on a J2EE servlet container and a SQL database.\n以及一个第三方的资料（引用自\nGerrit: Google-style code review meets git\n）\nMondrian \nhas been a huge success inside Google\n, Pearce said. \"Almost every engineer uses this as their daily thing.\" But Mondrian is heavily dependent on Google's internal infrastructure, including the in-house \nBigtable\n non-relational table store and the proprietary \nPerforce\n revision control system. Google is a huge Perforce shop, and has built its own highly-customized IT infrastructure, including Perforce-dependent tools.\n……\nShawn Pearce, who \npreviously reimplemented git in Java\n as JGit, and is now at Google, took on the project; the result is \nGerrit Code Review\n, now used to track \npublic proposed changes to Android\n. Android's applications are \nwritten in Java\n, so writing the new tool in that language should make it more accessible to would-be contributors among Android developers.\n也就是说：\nGuido用Python开发了这个项目，并且取得了巨大的成功\n后来这个项目被一个显然是Java专家的人接手了\n大量的业务逻辑发生了变更，后来整个用Java重写了一遍\n这个我认为显然不是Python的问题，而是项目leader的个人差异的问题，后来接手的人并不认可Guido的思路，重新按自己的思路发展了这个项目，导致了一些难以解决的设计冲突，最终决定重写将它理顺。如果Python开发大型项目有问题，为什么这个项目在Guido在的时候就是好好的，从Google内部迁移到Google App Engine的时候也没有出什么问题？将这个一个结果归到语言的身上，显然是看Guido走了之后的甩锅行为。\n对于我个人来说，我最近几年的所有的项目都是用Python开发的，开源的有VLCP，不开源的有公司的若干内部系统，在上线之后的迭代中，从没有产生过动态语言难以重构的感想。事实上，因为我很少开发Java，我本身也很少使用IDE的refactoring功能，以前编写C++的时候也没有用过，有些代码是直接用没有装额外插件的vim（只有语法高亮）编写的。\n可以先配合阅读我以前写过的几篇文章：\n灵剑：Python函数接口的一些设计心得\n灵剑：语言特性与对设计的影响\n在做程序员的道路上，你掌握了什么概念或技术使你感觉自我提升突飞猛进？\n对于一个项目来说，\n能用\n的代码很多，\n正确\n的代码往往只有一种或者少数几种。\n什么是正确的代码？\n代码的逻辑结构精确反映了业务的结构。代码的逻辑层级精确反映了业务在不同层次上的抽象。\n业务中的不变性成为框架性的基础；业务中灵活多变的部分成为顶层代码、DSL、配置或者插件，从而能够方便地修改\n代码有非常好的一致性，相同的业务对象用相同的类型表示，同类的业务对象用相同的接口表示，相同的业务逻辑用同一段代码实现，相似的业务逻辑用相同的抽象模型+不同的参数实现，独立的业务逻辑用独立的接口和模块实现。\n业务模型中的保证和约束与代码中的假定完全一致，比如说，永远不假定某个网络请求一定会成功，永远不传入一个哪怕只是理论上可能超出允许范围的值。\n可以看出，正确代码的定义和语言没有什么关系，它完全取决于代码与业务的结构关系，取决于代码是否与业务的抽象同构。因此，要写出正确的代码，首先必须要能正确地理解业务，做出对业务的优秀的抽象模型，然后基于模型做出代码模块、类和接口的设计，关键在于建模，而建模本质上来说是个数学问题。许多人可能推崇用编程语言思考，比如Thinking in Java，Thinking in C++，在我看来，其实应该首先Thinking in Mathematics，然后思考相应的数学模型如何用编程语言最佳地表示。国内常见的产品经理不懂技术，架构设计不懂业务的情况，对于做出正确的设计来说是非常糟糕的。\n实际上，用任何常见的语言都能写出正确的代码，但这些正确的代码的设计不尽相同，有时候会跟语言特性有关，并不是Java所有的语言特性Python都支持，那么Java中正确的代码并不是逐字翻译过来就是Python中正确的代码，那只能叫做\n能用\n的代码。原因在于虽然数学建模是相似的，但编程语言的表意方式不同，有时候需要将相应的模型转化为不同的编程概念。\n对于正确的代码来说，使用动态类型语言和静态类型语言开发效率是接近的，静态类型语言的某些\n限制\n会轻微地成为写出和维护正确代码的障碍。\n注意我用限制而不是功能来描述静态类型。\n举个例子来说，一个接口有三个成员函数，某个过程A使用其中前两个，而某个过程B使用其中后两个。实际上我们可以发现，实际过程A需要的并不是这个接口，而是只包含前两个成员函数的某个“子接口”，类似地，过程B需要的也是另一个不同的子接口。但是像Java这样的语言因为接口必须声明，所以通常为了方便，将它们合成一个接口来使用。但未来，真的不会出现只有前两个成员函数、而没有第三个成员函数的类型吗？这就是类型与抽象捆绑在一起导致的限制。相对来说，Go将类型与接口彻底分开，就是一个很有用的设计，虽然接口仍然要明确定义出来才能使用，不如动态语言方便，但因为提供了类型检查，算是一个权衡过的方案。而对动态语言来说，用到的就是接口限制的一部分，没有用到的就不是，也就是duck type，这个duck type是跟着代码实现一起变化的，优势就在于实现变更时，duck type随着实现一起变更，而不用单独维护；甚至，同一个参数可以在不同条件下依赖不同的成员函数，例如某个接口可以自动检测传入的参数是哪一个接口版本，从而自动实现兼容老版本的代码。\n对于正确的代码来说，业务模型已经理清，需要的只是将业务模型映射到接口，然后分别实现每个接口。任何编程语言都可以轻易做到这个。对于动态语言来说，因为不需要写出类型，也可以充分利用动态特性，编码量会小一些，但静态语言也可以靠自动补全来弥补这个劣势。动态语言没有静态类型检查，但如果业务逻辑清晰，接口定义明确，类型检查的作用并不是不可或缺的：比如，某个接口传入的参数是用户名，一个熟悉业务逻辑的人一定会知道用户名的类型是字符串；调用这个接口的人也一定会把某个用户名传进去，如果他传了用户ID，那肯定是编码的时候很不认真才会犯这种错误。这种错误也不是光靠类型系统就能纠正的，如果用户有UUID，UUID也是字符串，类型检查就发现不了问题了。\n在业务逻辑发生变化（需求变更）的时候，动态语言在维护正确的代码时有一定优势\n有几方面的原因：\n通过充分利用动态特性和duck type，能更容易将新的业务逻辑融合到老的框架中，而尽量不变更老的业务代码。\n比如说，在上层代码不变的情况下，将底层实现迁移到新的库或者组件，比如从ZooKeeper迁移到etcd，在这个过程中，许多由上层业务逻辑保存的对象的类型都会发生改变，如果以前没有做好依赖倒置的设计，现在可能就需要重新修改许多代码。反过来，如我们以前说过的，动态语言的duck type天生就是一种接口依赖，只要保存的对象和以前有相同的接口，就完全不需要修改代码，我们只需要在新的etcd适配层上，实现和以前zookeeper接口完全相同的功能即可。\n业务逻辑发生整体调整的时候，有时需要将某一段实现从一个模块移动到另一个模块中，在静态语言中一般通过IDE的refactoring功能进行。而在动态语言中，直接将类和函数复制到另一个文件中就可以了。\n有人可能会问，那调用方怎么办，调用老的位置的模块的代码不就不能用了吗？但实际上，如果是因为功能迁移导致的实现移动，老的代码仍然调用这个接口本来就是有问题的，因为业务上这段逻辑应该已经发生变化了，要么这时候不应该调用了，要么这时候应该调用的是一个新接口，然后从新接口中再来调用这个迁移过的功能。如果只是无脑将调用方都改到新的地址，可能会导致代码的调用层次与业务逻辑不同构，让正确的代码降格为能用的代码。\n不过，因为静态语言有IDE加持，可以充分利用refactoring的功能，大部分问题也都是可以弥补的，但必须要看到：对于动态语言来说，在维护正确的代码的时候，这些工作本身就是不必须的。\n开发出正确的代码是很困难的\n实际上，由于优秀的架构师很少，大部分架构师根本不合格，许多公司并没有正确的代码，只有能用的代码，这些项目也有一些特征：\n设计里充满了各种因为主观喜好而添加进去的设计模式和接口，完全对应不上实际的业务；实际的业务中本来清晰的逻辑，被拆到了各种乱七八糟的地方，通过奇奇怪怪的hack完成\n找不出一个能用简洁、一致的语言，清晰描述出业务逻辑模型的人。有的人只知道自己做的一点点东西，有的人能列举出一堆业务场景，但是形成不了模型\n代码依赖很多实际业务中并不一定成立的假定（客户一定不会同时访问XXX和XXX，输入的XXX都是XXX），许多假定已经被证明是无效的，然后通过调用者的代码逻辑hack过去\n三天两头出业务逻辑bug，修修补补，谁也没法保证代码运行的效果和需求一致，甚至拿出一个输入，有可能每个人理解它“应该”的输出都是不一样的\n经常要在推倒重写和把代码修改得更丑之间艰难抉择\n代码里有一大堆谁也说不上是什么用，就是不敢删的东西\n如果有的人一直都在维护这样的代码，那他就会以为动不动就重构是理所当然的事情，就无法理解为什么动态语言也可以用来开发项目。\n要开发出正确的代码，以下的条件都必须具备：\n要有一个精确的业务模型和分层级的业务抽象\n要有清晰的业务模型映射到代码实现的方案，并在组员中达成一致\n必须有精通前两点的人为代码质量把关，严格拒绝所有与设计不符的代码\n发现设计错误的时候，要勇于改正，哪怕会因此变动大量代码\n为了让第四点有底气，必须有自动化的测试系统来提高开发测试的效率，保障代码正确率和测试覆盖率，\n这一点对于动态语言尤为重要\n。\n实际上，即使是静态语言，如果你只在上线之前才简单手工测一下，你根本就是在撞大运。没有时间根本不是借口，无非就是懒惰而已。\n动态语言较容易改对，但更容易改错\n我们前面分析了动态语言在修改维护上实际上有一定的优势，但是反过来，如果没有一个优秀、强大的leader来为代码质量把关，动态语言劣化起来会比静态语言快得多，这一般来自于一些缺乏自律的程序员：\n动态语言普遍没有访问级别检查（private，protected），一个缺乏自律的程序员为了实现逻辑，会轻易选择调用没有开放的内部接口和成员，而不是仔细设计外部接口，从而严重破坏设计\n动态语言改变接口很容易，一个缺乏自律的程序员会在没有经过批准的情况下，擅自为设计好的接口添加额外的参数，以不符合设计的方式实现某些逻辑，从而严重破坏设计\n动态语言一般不需要明确定义类的成员字段，可以随意为对象添加字段。一个缺乏自律的程序员会擅自通过自己新添加的字段来传递某些数据，而不通过接口参数，或者将不属于某个对象的数据保存在对象上，从而严重破坏设计\n动态语言一般可以通过一些高级的动态特性实现特殊的效果。一个缺乏自律的程序员可能会在没有必要的情况下，仅仅因为个人的兴趣而擅自使用这些动态特性实现一些破坏可读性和接口假设的特性，从而严重破坏设计\n为了图方便，一个缺乏自律的程序员可能会将新增加的逻辑添加在比较顺手的地方，而不是与设计层级相符的地方，从而严重破坏设计。这一点静态语言也难以避免。\n我们可以注意到，这些全部都是主观原因、故意操作，完全可以通过自律和code review来避免。如果这样的破坏没有得到遏制，代码就会迅速劣化，从正确的代码变成能用的代码，从能用的代码变成难用的代码，从难用的代码变成不可用的代码。\n能用的代码，如果不积极改造为正确的代码，往往会被迫进一步劣化，因为设计错误，某些需求无法实现，就会做出更奇怪、错得更离谱的设计，这一点在动态语言上也尤为明显。\n静态类型语言代码也会劣化，但由于语言本身的限制，一般劣化得比较慢而不明显，但如果仔细研究那些能用的代码，通常早就已经千疮百孔了，这些劣化往往是下一次需求变动时候引起重大困难的原因。所以某种意义上来说，静态语言更适合维护那些能用的代码，减缓他们劣化的速度。\n总结\n无论是静态语言还是动态语言，项目是否可维护，都主要取决于业务模型、设计、代码是否正确\n动态语言在维护正确代码时略有优势，但静态语言经过IDE加持之后差别不大\n如果没有强有力的leader控制局面，动态语言进火葬场的速度的确非常快，但不是动态语言的错\n多说一句Java，我认为Data Class、getter、setter这些真的是特别糟糕，原生的Array和Map又不给力，开发效率上要提上来，可能还是需要有一套行之有效的开发规范和开发工具的，说实话，我是有点用不来这玩意。Go，除了没有异常恶心点，其他还可以。"},
{"title": "Python 应该怎么学？", "description": "猜出题目意思 还可以做一个Python机器人 用Python控制机器人自动杀怪！！ 从贪心算法，DFS搜索算法，到动态规划算法 Python只是一个表达方式，重要的是编程和算法思维", "article": "通过玩游戏学！！\n打匹配上分！！\n补充1：\n文章最后介绍了5分钟，从安装Python到做游戏的全过程\n补充2：\n编程语言和框架太多：纯小白，如何规划，成为高手_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili\n我录了视频，讲编程语言和学习路线的选择，零基础到编程高手\n会了条件 循环 变量 等基本概念\n就可以用Python这把工具\n直接做有趣的事的鸭\n做中学什么的最有成就感了呢\n首先是codingame这个网站\n来一场打匹配上分吧！！！\n来一场两分钟的代码对决\n一道题出来\n十个人PK\n结束了还可以看别人代码学习\n啊啊啊啊啊！！\n太棒了！！\n匹配队伍，开始代码对决\n三种模式：\n比谁最快\n比谁代码最短\n比谁能根据数据，猜出题目意思\n还可以做一个Python机器人\n用Python控制机器人自动杀怪！！\n从贪心算法，DFS搜索算法，到动态规划算法\nPython只是一个表达方式，重要的是编程和算法思维\n随着你的Python机器人不断通关，你的编程水平突飞猛进\n推荐第二款Python游戏\n极客战记codecombat\n一关一关打\n从啥都不会\n通关就会Python语法了\n通过写代码来玩游戏哦！\n一关一关打，循序渐进\n还有网页制作，游戏开发的拓展关卡"},
{"title": "Python有做大型游戏的潜力吗？", "description": "NeoX 和 Messiah，都使用 Python 作为脚本语言。 你最近所了解的比较火的挂着猪厂旗号的，也都是 Python 写的。 一些项目组甚至不需要分出人力去维护引擎部分", "article": "岂止是有潜力，简直是很合适！\n猪厂两大游戏客户端引擎，NeoX 和 Messiah，都使用 Python 作为脚本语言。\n你最近所了解的比较火的挂着猪厂旗号的，也都是 Python 写的。\n一些项目组甚至不需要分出人力去维护引擎部分，因为引擎本身比较稳。\n也就是说，程序绝大部分时间都可以专注用 Python 写逻辑，保持创造力。\n还有就是 Python 写各种工具，编辑器，不是一般的爽。PyQt 在手天下我有。\n还能和项目代码无缝衔接。\n————————\n服务端：\n也是纯 Python。\n因此很多代码可以服务端客户端共用，尤其是数据结构定义，序列化等。\n用过的才知道前后端用同一种语言有多方便。\n同一套 Excel 配表，用 Python 写的工具转成 py 文件，然后服务端和客户端都用这个。\n同一个类，服务端用，客户端也用，还需要啥数据格式转换啊（滑稽）。\n————————\n效率问题：\n运行效率大部分情况下都不是问题，开发效率却可以提升几个数量级。\n————————\n静态类型语言 vs 动态类型语言：\n这是个有争议的话题。\n个人看法这是一种 trade-off，牺牲逻辑的严谨性，以及架构，来换取开发效率。\n这样做当然很多弊端，只是在目前这个阶段，开发效率比什么都重要，真的。\n（项目组都要解散了你跟我说你的代码更好看？）\n————————\n多线程：\n客户端逻辑没有必要。\n游戏项目从来都不是计算密集型的，逻辑本来就够复杂了，多线程会进一步增加复杂度，得不偿失。\n（一般情况下不需要，要用的话祝你好运）\n————————\nHotfix：\n网络游戏正在逐渐成为一种服务，成为每个人的日常娱乐方式。\n服务的稳定也变得越来越重要，如果隔三差五就得停服修bug，客户端动不动就得整包更新，会严重影响玩家体验。\n而用 Python 进行热更是语言原生支持的，意味着实现成本很低，风险低，操作也很方便。\n————————\n最后的废话：\n不要想当然，不要听风就是雨，实践出真知。"},
{"title": "为什么要学 Python？", "description": "那 Pony ORM - Use Pure Python to Speak to Your Data 这种用Python黑魔法做出来的ORM你用过吗？Django", "article": "有人说我不好好说话，那就改一下言辞。不过还是要把这句放最前面：\n『学XX有什么用，我会XX，不也挺好的吗』这种话从CS学生嘴里说出来真是不应该。\n我上大学的时候，学校只教C++和Java。因为Linux玩过一段时间被叫去写网站，接触了PHP。当时对PHP惊为天人：语言简洁，能直接写网站，带字符串处理。这种感觉就是题主所说的『神器感』，那段时间天天和同学介绍PHP，介绍它有多强大。\n后来对Python有了『神器感』，对Django有了『神器感』，对flask有了『神器感』，对scala有了『神器感』，对go有了『神器感』。再后来，对C++有了『神器感』，对Java有了『神器感』。我现在接触过的语言只有这些了，实在没精力再学习其他语言，如果让我回到大学，那么多闲暇时间足够我学多少东西啊！\n说白了，任何一个语言，稍微深入地学习一下而不是看知乎上『学习XX有什么用』的问题回答，你都会很快有『神器感』，因为任何一门语言如果流行到你听说过名字，一定是有一个区别其他语言的比较优势。\n真正有求知欲的人，看到一门简单并且上手很快的语言怎么都会去学习一下的。你学Java，没问题啊，基于JVM的语言那么多。scala，closure，还有一大堆知名语言的JVM实现，一个一个学习一下又如何呢？只会Java，那么就好好研究下JVM，看看byte code，理解JVM GC机制和ref counting的区别，理解它的JIT机制。\n你说用过spring和ibatis，那 \nPony ORM - Use Pure Python to Speak to Your Data\n 这种用Python黑魔法做出来的ORM你用过吗？Django Admin site这种建站神器用过吗？再不济，web.py和flask这种快速建站工具试过吗？\n你说学过多线程，那你知道工业界很少用多线程，多是纤程、协程了吗？你知道go把goroutine做成语言特性是多牛逼吗？"},
{"title": "现在为什么 Python 这么火？", "description": "influxDB 等都有相应的 Python API。况且，Python 上手其实挺容易的。正所谓，“人生苦短百般味，Python 编程不怕累”。", "article": "以前只学数学的时候从来不写代码，只用过 C++ 写一些数值计算。\n等后来接触到了 Python，发觉 Python + GItHub 社区的各种开源工具包就好比一个军火库，里面什么武器都有，完全取决于使用者怎么组装这些武器。例如：\n数值计算工具：NumPy，SciPy；\n符号计算工具：SymPy；\n机器学习工具：Scikit-Learn，XGBoost，lightGBM，catBoost，PySpark；\n深度学习工具：TensorFlow，PyTorch；\n时间序列工具：FbProphet；\n数据分析工具：Pandas；\n地图分析工具：folium；\nweb开发工具：Django，Flask；\n可视化工具：matplotlib；\n图计算工具：networkx。\n另外，各种数据库例如 Redis，MySQL，influxDB 等都有相应的 Python API。况且，Python 上手其实挺容易的。正所谓，“\n人生苦短百般味，Python 编程不怕累\n”。"},
{"title": "两个撩妹的python项目", "description": "叹一句，好久没见过这么温情幽默的广告了！ 作为一个python的学习者，让我萌生了用python画社会人的想法。 看这个图像可以发现，佩奇由各种曲线、类抛物线、类圆、类椭圆等组成", "article": "这两天刷爆朋友圈的莫过于一则「啥是佩奇」的视频短片，看完之后不由的感叹一句，好久没见过这么温情幽默的广告了！\n作为一个python的学习者，让我萌生了用python画社会人的想法。\n看这个图像可以发现，佩奇由各种曲线、类抛物线、类圆、类椭圆等组成。这里提到的“类”，是小猪佩奇的构图精髓，一种手绘风格，而不是标准刻板的线条。\n思路如下：选好画板大小，设置好画笔颜色，粗细，定位好位置，依次画鼻子，头、耳朵，眼睛，腮，嘴，身体，手脚，尾巴。\n环境\n语言：python3.7\n编辑器：Pycharm\n具体代码如下：\nfrom turtle import *\n\ndef nose(x,y):#鼻子\n    penup()#提起笔\n    goto(x,y)#定位\n    pendown()#落笔，开始画\n    setheading(-30)#将乌龟的方向设置为to_angle/为数字（0-东、90-北、180-西、270-南）\n    begin_fill()#准备开始填充图形\n    a=0.4\n    for i in range(120):\n        if 0<=i<30 or 60<=i<90:\n            a=a+0.08\n            left(3) #向左转3度\n            forward(a) #向前走a的步长\n        else:\n            a=a-0.08\n            left(3)\n            forward(a)\n    end_fill()#填充完成\n\n    penup()\n    setheading(90)\n    forward(25)\n    setheading(0)\n    forward(10)\n    pendown()\n    pencolor(255,155,192)#画笔颜色\n    setheading(10)\n    begin_fill()\n    circle(5)\n    color(160,82,45)#返回或设置pencolor和fillcolor\n    end_fill()\n\n    penup()\n    setheading(0)\n    forward(20)\n    pendown()\n    pencolor(255,155,192)\n    setheading(10)\n    begin_fill()\n    circle(5)\n    color(160,82,45)\n    end_fill()\n\n\ndef head(x,y):#头\n    color((255,155,192),\"pink\")\n    penup()\n    goto(x,y)\n    setheading(0)\n    pendown()\n    begin_fill()\n    setheading(180)\n    circle(300,-30)\n    circle(100,-60)\n    circle(80,-100)\n    circle(150,-20)\n    circle(60,-95)\n    setheading(161)\n    circle(-300,15)\n    penup()\n    goto(-100,100)\n    pendown()\n    setheading(-30)\n    a=0.4\n    for i in range(60):\n        if 0<=i<30 or 60<=i<90:\n            a=a+0.08\n            lt(3) #向左转3度\n            fd(a) #向前走a的步长\n        else:\n            a=a-0.08\n            lt(3)\n            fd(a)\n    end_fill()\n\n\ndef ears(x,y): #耳朵\n    color((255,155,192),\"pink\")\n    penup()\n    goto(x,y)\n    pendown()\n    begin_fill()\n    setheading(100)\n    circle(-50,50)\n    circle(-10,120)\n    circle(-50,54)\n    end_fill()\n\n    penup()\n    setheading(90)\n    forward(-12)\n    setheading(0)\n    forward(30)\n    pendown()\n    begin_fill()\n    setheading(100)\n    circle(-50,50)\n    circle(-10,120)\n    circle(-50,56)\n    end_fill()\n\n\ndef eyes(x,y):#眼睛\n    color((255,155,192),\"white\")\n    penup()\n    setheading(90)\n    forward(-20)\n    setheading(0)\n    forward(-95)\n    pendown()\n    begin_fill()\n    circle(15)\n    end_fill()\n\n    color(\"black\")\n    penup()\n    setheading(90)\n    forward(12)\n    setheading(0)\n    forward(-3)\n    pendown()\n    begin_fill()\n    circle(3)\n    end_fill()\n\n    color((255,155,192),\"white\")\n    penup()\n    seth(90)\n    forward(-25)\n    seth(0)\n    forward(40)\n    pendown()\n    begin_fill()\n    circle(15)\n    end_fill()\n\n    color(\"black\")\n    penup()\n    setheading(90)\n    forward(12)\n    setheading(0)\n    forward(-3)\n    pendown()\n    begin_fill()\n    circle(3)\n    end_fill()\n\n\ndef cheek(x,y):#腮\n    color((255,155,192))\n    penup()\n    goto(x,y)\n    pendown()\n    setheading(0)\n    begin_fill()\n    circle(30)\n    end_fill()\n\n\ndef mouth(x,y): #嘴\n    color(239,69,19)\n    penup()\n    goto(x,y)\n    pendown()\n    setheading(-80)\n    circle(30,40)\n    circle(40,80)\n\ndef body(x,y):#身体\n    color(\"red\",(255,99,71))\n    penup()\n    goto(x,y)\n    pendown()\n    begin_fill()\n    setheading(-130)\n    circle(100,10)\n    circle(300,30)\n    setheading(0)\n    forward(230)\n    setheading(90)\n    circle(300,30)\n    circle(100,3)\n    color((255,155,192),(255,100,100))\n    setheading(-135)\n    circle(-80,63)\n    circle(-150,24)\n    end_fill()\n\n\ndef hands(x,y):#手\n    color((255,155,192))\n    penup()\n    goto(x,y)\n    pendown()\n    setheading(-160)\n    circle(300,15)\n    penup()\n    setheading(90)\n    forward(15)\n    setheading(0)\n    forward(0)\n    pendown()\n    setheading(-10)\n    circle(-20,90)\n\n    penup()\n    setheading(90)\n    forward(30)\n    setheading(0)\n    forward(237)\n    pendown()\n    setheading(-20)\n    circle(-300,15)\n    penup()\n    setheading(90)\n    forward(20)\n    setheading(0)\n    forward(0)\n    pendown()\n    setheading(-170)\n    circle(20,90)\n\ndef foot(x,y):#脚\n    pensize(10)\n    color((240,128,128))\n    penup()\n    goto(x,y)\n    pendown()\n    setheading(-90)\n    forward(40)\n    setheading(-180)\n    color(\"black\")\n    pensize(15)\n    fd(20)\n\n    pensize(10)\n    color((240,128,128))\n    penup()\n    setheading(90)\n    forward(40)\n    setheading(0)\n    forward(90)\n    pendown()\n    setheading(-90)\n    forward(40)\n    setheading(-180)\n    color(\"black\")\n    pensize(15)\n    fd(20)\n\ndef tail(x,y):#尾巴\n    pensize(4)\n    color((255,155,192))\n    penup()\n    goto(x,y)\n    pendown()\n    seth(0)\n    circle(70,20)\n    circle(10,330)\n    circle(70,30)\n\ndef setting():          #参数设置\n    pensize(4)\n    hideturtle()        #使乌龟无形（隐藏）\n    colormode(255)      #将其设置为1.0或255.随后 颜色三元组的r，g，b值必须在0 .. cmode范围内\n    color((255,155,192),\"pink\")\n    setup(840,500)\n    speed(10)\n\ndef main():\n    setting()           #画布、画笔设置\n    nose(-100,100)      #鼻子\n    head(-69,167)       #头\n    ears(0,160)         #耳朵\n    eyes(0,140)         #眼睛\n    cheek(80,10)        #腮\n    mouth(-20,30)       #嘴\n    body(-32,-8)        #身体\n    hands(-56,-45)      #手\n    foot(2,-177)        #脚\n    tail(148,-155)      #尾巴\n    done()\n\nif __name__ == '__main__':\n    main()\n从代码来看，我们可以发现，主要用到了turtle库，它是python内置的一个比较有趣味的模块，俗称「海龟绘图」，它是基于tkinter模块打造的，提供了一些简单的绘图工具。\n如果你想了解turtle库更多信息，可以访问官方文档：\nhttps://\ndocs.python.org/3/libra\nry/turtle.html\n.\n总结：通过trutle库实现基本的圆、椭圆、曲线等，难点在于，如何定位每个部分的位置（画之前可以先画个草图）。\n利用turtle库，我还画过玫瑰花，作为一个python学习者，还不赶快把这么牛逼的撩妹技能学到手。后台回复「玫瑰花」就可以获得源码。\n今天的两个小项目适合入门学习者练手，光跑一遍程序，就会让你对python上瘾，还等什么呢？赶紧操练起来吧。"},
{"title": "python如何画出漂亮的地图？", "description": "推荐一个超好用的python包folium, 专门用于地理数据可视化，官方英文教程教程点击这里，查看本文源代码请点击这里。 使用方法很简单，操作如下： 导入包，创建一副世界地图import", "article": "推荐一个超好用的python包\nfolium\n, 专门用于\n地理数据可视化\n，官方英文教程教程\n点击这里\n，查看本文源代码请\n点击这里\n。\n使用方法很简单，操作如下：\n导入包，创建一副世界地图\nimport folium\nimport pandas as pd\n\n# define the world map\nworld_map = folium.Map()\n\n# display world map\nworld_map\n2. 输入经纬度，尺度，在这里我们以旧金山（37.7749° N, 122.4194° W）为例。\n# San Francisco latitude and longitude values\nlatitude = 37.77\nlongitude = -122.42\n\n# Create map and display it\nsan_map = folium.Map(location=[latitude, longitude], zoom_start=12)\n\n# Display the map of San Francisco\nsan_map\n更改地图显示，默认为'OpenStreetMap'风格，我们还可以选择'Stamen Terrain', 'Stamen Toner'等。\n# Create map and display it\nsan_map = folium.Map(location=[latitude, longitude], zoom_start=12,tiles='Stamen Toner')\n3. 读取数据集（旧金山犯罪数据集）\n# Read Dataset \ncdata = pd.read_csv('https://cocl.us/sanfran_crime_dataset')\ncdata.head()\n4. 在地图上显示前200条犯罪数据\n# get the first 200 crimes in the cdata\nlimit = 200\ndata = cdata.iloc[0:limit, :]\n\n# Instantiate a feature group for the incidents in the dataframe\nincidents = folium.map.FeatureGroup()\n\n# Loop through the 200 crimes and add each to the incidents feature group\nfor lat, lng, in zip(cdata.Y, data.X):\n    incidents.add_child(\n        folium.CircleMarker(\n            [lat, lng],\n            radius=7, # define how big you want the circle markers to be\n            color='yellow',\n            fill=True,\n            fill_color='red',\n            fill_opacity=0.4\n        )\n    )\n\n# Add incidents to map\nsan_map = folium.Map(location=[latitude, longitude], zoom_start=12)\nsan_map.add_child(incidents)\n5. 添加地理标签\n# add pop-up text to each marker on the map\nlatitudes = list(data.Y)\nlongitudes = list(data.X)\nlabels = list(data.Category)\n\nfor lat, lng, label in zip(latitudes, longitudes, labels):\n    folium.Marker([lat, lng], popup=label).add_to(san_map)    \n    \n# add incidents to map\nsan_map.add_child(incidents)\n6. 统计区域犯罪总数\nfrom folium import plugins\n\n# let's start again with a clean copy of the map of San Francisco\nsan_map = folium.Map(location = [latitude, longitude], zoom_start = 12)\n\n# instantiate a mark cluster object for the incidents in the dataframe\nincidents = plugins.MarkerCluster().add_to(san_map)\n\n# loop through the dataframe and add each data point to the mark cluster\nfor lat, lng, label, in zip(data.Y, data.X, cdata.Category):\n    folium.Marker(\n        location=[lat, lng],\n        icon=None,\n        popup=label,\n    ).add_to(incidents)\n\n# add incidents to map\nsan_map.add_child(incidents)\n7. 读取geojson文件，可视化旧金山市10个不同Neighborhood的边界\nimport json\nimport requests\n\nurl = 'https://cocl.us/sanfran_geojson'\nsan_geo = f'{url}'\nsan_map = folium.Map(location=[37.77, -122.4], zoom_start=12)\nfolium.GeoJson(\n    san_geo,\n    style_function=lambda feature: {\n        'fillColor': '#ffff00',\n        'color': 'black',\n        'weight': 2,\n        'dashArray': '5, 5'\n    }\n).add_to(san_map)\n\n#display map\nsan_map\n8. 统计每个区域的犯罪事件数目\n# Count crime numbers in each neighborhood\ndisdata = pd.DataFrame(cdata['PdDistrict'].value_counts())\ndisdata.reset_index(inplace=True)\ndisdata.rename(columns={'index':'Neighborhood','PdDistrict':'Count'},inplace=True)\ndisdata\n9. 创建Choropleth Map （颜色深浅代表各区犯罪事件数目）\nm = folium.Map(location=[37.77, -122.4], zoom_start=12)\nfolium.Choropleth(\n    geo_data=san_geo,\n    data=disdata,\n    columns=['Neighborhood','Count'],\n    key_on='feature.properties.DISTRICT',\n    #fill_color='red',\n    fill_color='YlOrRd',\n    fill_opacity=0.7,\n    line_opacity=0.2,\n    highlight=True,\n    legend_name='Crime Counts in San Francisco'\n).add_to(m)\nm\n10. 创建热力图\nfrom folium.plugins import HeatMap\n\n# let's start again with a clean copy of the map of San Francisco\nsan_map = folium.Map(location = [latitude, longitude], zoom_start = 12)\n\n# Convert data format\nheatdata = data[['Y','X']].values.tolist()\n\n# add incidents to map\nHeatMap(heatdata).add_to(san_map)\n\nsan_map\n本文源代码Jupyter notebook地址：\nJupyter Notebook Viewer\nGitHub地址：\ngaonanlee/Visualization-Practice\n最后，folium还可以用来创建动态热力图，动态路径图等，具体可参考Medium上的一篇文章。\nSpatial Visualizations and Analysis in Python with Folium\n实现效果如下图所示 (直接从Medium上抱过来的图，详细代码请点击上述链接）。\n我的其他回答\n哪些 Python 库让你相见恨晚？\n时间序列数据如何插补缺失值？\n机器学习中的因果关系: 从辛普森悖论（常见的统计学谬误）谈起\n让我们跑一个最简单的GAN网络吧！（附Jupyter Notebook 代码）\n欢迎大家关注我的\n机器学习笔记\n专栏，我将用小白也能听懂的语言，为大家讲述机器学习中那些有趣好玩的知识 (●'◡'●)\n机器学习笔记"},
{"title": "Python学习资料总结", "description": "Python中的变量、引用、拷贝和作用域 Python的迭代器和生成器 Python爬虫：一些常用的爬虫技巧总结 Python“不为人知的”特性 Python进阶必读汇总 Python渗透测试工具合集", "article": "因为对Python还蛮感兴趣的，所以总结一下Python学习资料，包括三部分：\n可以学习Python的地方：\n如果你也想学Python的话，那么可以在这些地方进行学习；\nPython可以做的事情：\n分享一些Python可以开发的一些项目；\n关于Python的一些文章：\n把平时看到的一些关于Python的文章进行了整理，对于Python学习者来说是非常不错滴；\n一、可以学习Python的地方\n这个是我在百度经验看到别人总结的，觉得还不错，直接拿过来用了~\n1、Vamei老师：\n【python快速教程】\n2、廖雪峰老师：\n【python教程】\n3、实验楼：\n【Python基础+项目实战课程】\n4、\n《笨办法学 Python》\n：这本书绝对是最简单的学习 Python 的方法，本书的 HTML 在线版是完全免费的。\n5、\nPython Weekly\n：每周更新，包括Python相关的文章、教程、演讲、书籍、项目、工作等。\n6、\nPython challenge\n：用Python编程技能解决33个谜题，闯关。\n7、\nPython官方文档\n：官网，去找资料吧！\n二、Python可以做的事\n1、Python可以开发诸如：聊天室、博客、计算器…之类，我们在学校一开发就必定想到的一些小应用；\n放上几个教程吧，如果想学可以看看：\nPython聊天室\nFlask开发轻博客\n说明：Flask 是一个用于 Python 的微型网络开发框架。\nPython开发简单计算器\n2、如果是个比较喜欢玩游戏的人，那么Python也是可以开发游戏滴：2048、打飞机……你能想到的一些小游戏都是可以滴~\nPython代码实现2048\npygame开发打飞机游戏\n3、当然，也是可以用Python来做一些比较酷的事情滴，比如破解验证码啊，自动填写调查问卷啊，爬虫啊……\nPython 破解验证码\nPython自动填问卷星\n基于python的网络小爬虫\nPython 图片转字符画\n4、肯定也是可以用来做一些实用有趣的开发\n使用 Python 3 编写系列实用脚本\nPython3 色情图片识别\nPython实现3D建模工具\n神经网络实现手写字符识别系统\n基于PyQt5 实现地图中定位相片拍摄位置\nPython 实现端口扫描器\nPython3 实现火车票查询工具\n高德API+Python解决租房问题\n……\n很多啦，就不列举了！\n三、关于Python的一些文章\n最后，我把我平时看到的一些关于Python的文章总结一下吧：\n值得关注的10个python语言博客\nPython 有哪些好的学习资料或者博客？\nPython 程序员经常犯的 10 个错误\nPython程序员都会喜欢的6个库 \npython机器学习入门资料梳理\nPython性能优化的20条建议\nPython中的变量、引用、拷贝和作用域\nPython的迭代器和生成器\nPython爬虫：一些常用的爬虫技巧总结\nPython“不为人知的”特性\nPython进阶必读汇总\nPython渗透测试工具合集\nPython 中 import 的机制与实现\npython之线程、进程和协程\n震惊小伙伴的单行代码—Python篇\n从底层理解Python的执行\n以上，就是我总结的一些Python学习资料啦，希望对Python学习者能有所帮助！"},
{"title": "1198元学习python爬虫合适吗？", "description": "懒人目录： 入门Python需要下载什么软件 入门Python从哪里学起 优质的自学资源分享 一、入门Python需要下载的软件 Python和PyCharm。Mac还是Windows根据自己的本选", "article": "我是完全自学的，看完这条回答你就不用花钱学了。一千多的课程也就是基础课，并不会给你有多深入。如果要是学基础的话，看看下面的学习线路图以及相关的学习方法足够了。贴一个我之前自学的路径图和方法。\n小白学Python需要先找到自己的学习目的。说小一点的，想实现爬一个网站。大一点，未来想做数据方面的工作。不管是小目的还是大的，都必须弄清楚。只有清楚的看到目标才知道当下学的是什么。\n懒人目录：\n入门Python需要下载什么软件\n入门Python从哪里学起\n优质的自学资源分享\n一、入门Python需要下载的软件\nPython和PyCharm。Mac还是Windows根据自己的本选。\n至于其他编程相关软件：火狐浏览器、谷歌浏览器、文件搜索利器Everything、局域网通信软件飞秋、虚拟机VMwareworkstation full、Linux版Mysql、Windows版MySQL、数据库客户端Navicat、自动化测试selenium、代码版本管理器Git、代码编辑器Sublime Text、文本编辑器Ty.pora；\n以上内容，我这边是都有的网盘的，但是一放上来就会被举报。所以大家还是自己去网上找，至于配置问题很多小伙伴会看不懂。可以看看下面这个文章：\n初学 Python 需要安装哪些软件？\n以上内容不用全部都下载，需要什么下载什么就可以。不想涉及web的话，是不用安装PS的。下面就分享一下，Python的职业发展还有学习路线图。\n二、入门Python从哪里学起\n入门的话，是要从了解Python开始学起来。先知道它在什么领域可以做什么。文章篇幅过长，有需要的建议慢慢看。首先来看一下，\nPython的职业发展路径：\n简化一下之后的图：\n根据职业成长路径图总结的下面的知识点：\n作者：传智播客\n链接：\nhttps://www.\nzhihu.com/question/3018\n37911/answer/700013802\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1.Python基础\n计算机组成原理：\n计算机组成部分、操作系统分类、B/S和C/S架构、理解软件与硬件的区别\nPython变量以及开发环境：\n字符串、数字、字典、列表、元祖等\n流程控制语句：\n程序的执行顺序，顺序执行、循环执行、选择执行\n函数：\n定义函数、调用函数、函数的嵌套、递归函数\n文件的基本操作：\n文件的打开、编辑、关闭\n面向对象编程：\n类对象、实例对象、定义类、实例化对象\n异常处理：\n学会捕捉异常、自定义异常\n模块和包：\n理解模块和包的概念并学会使用\n飞机大战游戏制作：\n自己独立完成飞机大战游戏\n2.开发框架\n大部分后台的业务都会使用到web框架来开发，可以提高工作效率。Python当中常用的web框架是Django、Flask、Tornado等。\nDjango框架：\nGit源代码管理、Redis缓存、VUE介绍、Vue基本语法、ES6语法、VUE 生命周期、Django框架介绍、Django模型、ORM及数据库操作、视图及模板、Django中间件\n3.数据库\n只说最常用的三种类型数据库，都是网站业务后端使用率很高的。Mysql、Mongodb，Redis；这三种数据库分别是关系型数据库，文档型数据库还有内存型的数据库。需要学的就是如何使用并且设计，最后是优化。\n4.前端知识\nHTML的学习：\nHTML的文档结构、快速创建HTML方法\nCSS：\nCSS的使用\nPS的简单应用：\nPhotoshop的基本使用、取色、图层\nJavaScript的学习：\nJavaScript的基本语法\njQuery的学习：\njQuery的使用\nVue框架：\n框架的使用以及注意点\n5.web服务器\nFlask web框架的使用：\n模板与表单、数据库的使用、单元测试、第三方扩展与部署、Redis缓存使用、GIT版本控制、云服务器的使用、验证码的收发、网站项目开发实战\nDjango web框架的使用：\n框架的使用方法、模型介绍、ORM以及数据库操作、视图以及模板、Django中间件、Django REST Framework、网站项目开发实战\n6.Linux操作系统\nNginx是在Linux服务器上运行的，所以需要学习Linux系统。\nLinux命令：\nUbuntu操作系统介绍与使用、Linux命令使用、Linux命令选项的使用、远程登录和远程拷贝、vim编辑器使用、Ubuntu软件安装和软件卸载\n上述针对目的为使用Python做网站开发所需要的知识点。如果有需要爬虫方面的，或者是数据方面的细分知识点。留言或者私信我~~\n三、优质的自学资源分享\nPython学习教程：\nPython入门教程完整版（懂中文就能学会）\nPython全栈快速搭建Web服务器\nPython进阶之Django框架\nbootstrap商业网站实战1\nbootstrap商业网站实战2\n以上全部内容，均有配套资料。内含有PPT课件，课程笔记和源码。有需要的可以评论找我。因为一放网盘就会被举报。\nPython每个阶段课后习题（按照顺序）：\nPython基础知识习题\nPython有关变量、数据类型以及运算符的习题\nPython函数相关的练习题\nPython中判断语句以及循环语句的习题\nPython字符串操作的相关函数习题\nPython中列表、元祖和字典的习题\nPython函数的闭包、装饰器等练习题\nPython中文件操作的相关习题\nPython异常相关的全部笔试题\nPython中模块的所含内容习题\nPython面向对象习题，笔试内容\nPython封装、继承和多态以及类方法等习题\nhttps://www.\nzhihu.com/question/3018\n37911/answer/700013802\n关注一下我呗，后续会有更多精彩。"},
{"title": "Python 有什么奇技淫巧？", "description": "Jackpop：请问自学Python有必要买课程吗？ Jackpop：Python调试工具之pdb Jackpop：一文教你配置得心应手的Python 后续分享会以公众号和个人主页为主", "article": "谈到奇技淫巧，我认为这款神器当之无愧。\n在程序开发过程中，代码的运行往往会和我们预期的结果有所差别。于是，我们需要清楚代码运行过程中到底发生了什么？代码哪些模块运行了，哪些模块没有运行？输出的局部变量是什么样的？很多时候，我们会想到选择使用成熟、常用的IDE使用断点和watches调试程序，或者更为基础的print函数、log打印出局部变量来查看是否符合我们预期的执行效果。但是这些方法都有一个共同的弱点--效率低且繁琐，本文就介绍一个堪称神器的Python调试工具PySnooper，能够大大减少调试过程中的工作量。\n装饰器\n装饰器（Decorators）是Python里一个很重要的概念，它能够使得Python代码更加简洁，用一句话概括：装饰器是修改其他函数功能的函数。PySnooper的调用主要依靠装饰器的方式，所以，了解装饰器的基本概念和使用方法更有助于理解PySnooper的使用。在这里，我先简单介绍一下装饰器的使用，如果精力有限，了解装饰器的调用方式即可。\n对于Python，一切都是对象，一个函数可以作为一个对象在不同模块之间进行传递，举个例子，\ndef\n \none\n(\nfunc\n):\n\n    \nprint\n(\n\"now you are in function one.\"\n)\n\n    \nfunc\n()\n\n\n​\n\n    \n\ndef\n \ntwo\n():\n\n    \nprint\n(\n\"now you are in function two\"\n)\n\n\n​\n\n    \n\none\n(\ntwo\n)\n\n\n​\n\n\n# 输出\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \none\n.\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \ntwo\n.\n其实这就是装饰器的核心所在，它们封装一个函数，可以用这样或那样的方式来修改它。换一种方式表达上述调用，可以用\n@+函数名\n来装饰一个函数。\ndef\n \none\n(\nfunc\n):\n\n    \nprint\n(\n\"now you are in function one.\"\n)\n\n    \ndef\n \nwarp\n():\n\n        \nfunc\n()\n\n    \nreturn\n \nwarp\n\n\n​\n\n\n​\n\n\n@one\n\n\ndef\n \ntwo\n():\n\n    \nprint\n(\n\"now you are in function two.\"\n)\n\n\n​\n\n    \n\ntwo\n()\n\n\n​\n\n\n# 输出\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \none\n.\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \ntwo\n.\n此外，在调用装饰器时还可以给函数传入参数：\ndef\n \none\n(\nfunc\n):\n\n    \nprint\n(\n\"now you are in function one.\"\n)\n\n    \ndef\n \nwarp\n(\n*\nargs\n):\n\n        \nfunc\n(\n*\nargs\n)\n\n    \nreturn\n \nwarp\n\n\n​\n\n\n​\n\n\n@one\n\n\ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \nprint\n(\n\"now you are in function two.\"\n)\n\n    \nprint\n(\n\"x value is \n%d\n, y value is \n%d\n\"\n \n%\n \n(\nx\n,\n \ny\n))\n\n\n​\n\n    \n\ntwo\n(\n5\n,\n \n6\n)\n\n\n​\n\n\n# 输出\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \none\n.\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \ntwo\n.\n\n\n>>>\n \nx\n \nvalue\n \nis\n \n5\n,\n \ny\n \nvalue\n \nis\n \n6\n另外，装饰器本身也可以接收参数，\ndef\n \nthree\n(\ntext\n):\n\n    \ndef\n \none\n(\nfunc\n):\n\n        \nprint\n(\n\"now you are in function one.\"\n)\n\n        \ndef\n \nwarp\n(\n*\nargs\n):\n\n            \nfunc\n(\n*\nargs\n)\n\n        \nreturn\n \nwarp\n\n    \nprint\n(\n\"input params is {}\"\n.\nformat\n(\ntext\n))\n\n    \nreturn\n \none\n\n\n​\n\n\n​\n\n\n@three\n(\ntext\n=\n5\n)\n\n\ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \nprint\n(\n\"now you are in function two.\"\n)\n\n    \nprint\n(\n\"x value is \n%d\n, y value is \n%d\n\"\n \n%\n \n(\nx\n,\n \ny\n))\n\n\n​\n\n    \n\ntwo\n(\n5\n,\n \n6\n)\n\n\n​\n\n\n# 输出\n\n\n>>>\n \ninput\n \nparams\n \nis\n \n5\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \none\n.\n\n\n>>>\n \nnow\n \nyou\n \nare\n \nin\n \nfunction\n \ntwo\n.\n\n\n>>>\n \nx\n \nvalue\n \nis\n \n5\n,\n \ny\n \nvalue\n \nis\n \n6\n上面讲述的就是Python装饰器的一些常用方法。\nPysnooper\n调试程序对于大多数开发者来说是一项必不可少的工作，当我们想要知道代码是否按照预期的效果在执行时，我们会想到去输出一下局部变量与预期的进行比对。目前大多数采用的方法主要有以下几种：\nPrint函数\nLog日志\nIDE调试器\n但是这些方法有着无法忽视的弱点：\n繁琐\n过度依赖工具\n\"PySnooper is a poor man's debugger.\"\n有了PySnooper，上述问题都迎刃而解，因为PySnooper实在太简洁了，目前在github已经10k+star。\n前面花了一段篇幅讲解装饰器其实就是为了PySnooper做铺垫，PySnooper的调用就是通过装饰器的方式进行使用，非常简洁。\nPySnooper的调用方式就是通过\n@pysnooper.snoop\n的方式进行使用，该装饰器可以传入一些参数来实现一些目的，具体如下：\n参数描述\nNone输出日志到控制台filePath输出到日志文件，例如'log/file.log'prefix给调试的行加前缀，便于识别watch查看一些非局部变量表达式的值watch_explode展开值用以查看列表/字典的所有属性或项depth显示函数调用的函数的snoop行\n安装\n使用pip安装，\npip install pysnooper \n或者使用conda安装，\nconda install -c conda-forge pysnooper\n使用\n先写一个简单的例子，\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \npysnooper\n\n\n​\n\n\n​\n\n\n@pysnooper.snoop\n()\n\n\ndef\n \none\n(\nnumber\n):\n\n    \nmat\n \n=\n \n[]\n\n    \nwhile\n \nnumber\n:\n\n        \nmat\n.\nappend\n(\nnp\n.\nrandom\n.\nnormal\n(\n0\n,\n \n1\n))\n\n        \nnumber\n \n-=\n \n1\n\n    \nreturn\n \nmat\n\n\n​\n\n\n​\n\n\none\n(\n3\n)\n\n\n​\n\n\n# 输出\n\n\n​\n\n\nStarting\n \nvar\n:\n..\n \nnumber\n \n=\n \n3\n\n\n22\n:\n17\n:\n10.634566\n \ncall\n         \n6\n \ndef\n \none\n(\nnumber\n):\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n7\n     \nmat\n \n=\n \n[]\n\n\nNew\n \nvar\n:\n.......\n \nmat\n \n=\n \n[]\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n8\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n9\n         \nmat\n.\nappend\n(\nnp\n.\nrandom\n.\nnormal\n(\n0\n,\n \n1\n))\n\n\nModified\n \nvar\n:\n..\n \nmat\n \n=\n \n[\n-\n0.4142847169210746\n]\n\n\n22\n:\n17\n:\n10.634566\n \nline\n        \n10\n         \nnumber\n \n-=\n \n1\n\n\nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n2\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n8\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n9\n         \nmat\n.\nappend\n(\nnp\n.\nrandom\n.\nnormal\n(\n0\n,\n \n1\n))\n\n\nModified\n \nvar\n:\n..\n \nmat\n \n=\n \n[\n-\n0.4142847169210746\n,\n \n-\n0.479901983375219\n]\n\n\n22\n:\n17\n:\n10.634566\n \nline\n        \n10\n         \nnumber\n \n-=\n \n1\n\n\nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n1\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n8\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n9\n         \nmat\n.\nappend\n(\nnp\n.\nrandom\n.\nnormal\n(\n0\n,\n \n1\n))\n\n\nModified\n \nvar\n:\n..\n \nmat\n \n=\n \n[\n-\n0.4142847169210746\n,\n \n-\n0.479901983375219\n,\n \n1.0491540468063252\n]\n\n\n22\n:\n17\n:\n10.634566\n \nline\n        \n10\n         \nnumber\n \n-=\n \n1\n\n\nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n0\n\n\n22\n:\n17\n:\n10.634566\n \nline\n         \n8\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n17\n:\n10.634566\n \nline\n        \n11\n     \nreturn\n \nmat\n\n\n22\n:\n17\n:\n10.634566\n \nreturn\n      \n11\n     \nreturn\n \nmat\n\n\nReturn\n \nvalue\n:\n..\n \n[\n-\n0.4142847169210746\n,\n \n-\n0.479901983375219\n,\n \n1.0491540468063252\n]\n这是最简单的使用方法，从上述输出结果可以看出，PySnooper输出信息主要包括以下几个部分：\n局部变量值\n代码片段\n局部变量所在行号\n返回结果\n也就是说，把我们日常DEBUG所需要的主要信息都输出出来了。\n上述结果输出到控制台，还可以把日志输出到文件，\n@pysnooper.snoop\n(\n\"debug.log\"\n)\n在函数调用过程中，PySnooper还能够显示函数的层次关系，使得一目了然，\n@pysnooper.snoop\n()\n\n\ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \nz\n \n=\n \nx\n \n+\n \ny\n\n    \nreturn\n \nz\n\n\n​\n\n\n​\n\n\n@pysnooper.snoop\n()\n\n\ndef\n \none\n(\nnumber\n):\n\n    \nk\n \n=\n \n0\n\n    \nwhile\n \nnumber\n:\n\n        \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n        \nnumber\n \n-=\n \n1\n\n    \nreturn\n \nnumber\n\n\n​\n\n\n​\n\n\none\n(\n3\n)\n\n\n​\n\n\n# 输出\n\n\nStarting\n \nvar\n:\n..\n \nnumber\n \n=\n \n3\n\n\n22\n:\n26\n:\n08.185204\n \ncall\n        \n12\n \ndef\n \none\n(\nnumber\n):\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n13\n     \nk\n \n=\n \n0\n\n\nNew\n \nvar\n:\n.......\n \nk\n \n=\n \n0\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n15\n         \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n    \nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n0\n\n    \nStarting\n \nvar\n:\n..\n \ny\n \n=\n \n3\n\n    \n22\n:\n26\n:\n08.186202\n \ncall\n         \n6\n \ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \n22\n:\n26\n:\n08.186202\n \nline\n         \n7\n     \nz\n \n=\n \nx\n \n+\n \ny\n\n    \nNew\n \nvar\n:\n.......\n \nz\n \n=\n \n3\n\n    \n22\n:\n26\n:\n08.186202\n \nline\n         \n8\n     \nreturn\n \nz\n\n    \n22\n:\n26\n:\n08.186202\n \nreturn\n       \n8\n     \nreturn\n \nz\n\n    \nReturn\n \nvalue\n:\n..\n \n3\n\n\nModified\n \nvar\n:\n..\n \nk\n \n=\n \n3\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n16\n         \nnumber\n \n-=\n \n1\n\n\nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n2\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n15\n         \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n    \nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n3\n\n    \nStarting\n \nvar\n:\n..\n \ny\n \n=\n \n2\n\n    \n22\n:\n26\n:\n08.186202\n \ncall\n         \n6\n \ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \n22\n:\n26\n:\n08.186202\n \nline\n         \n7\n     \nz\n \n=\n \nx\n \n+\n \ny\n\n    \nNew\n \nvar\n:\n.......\n \nz\n \n=\n \n5\n\n    \n22\n:\n26\n:\n08.186202\n \nline\n         \n8\n     \nreturn\n \nz\n\n    \n22\n:\n26\n:\n08.186202\n \nreturn\n       \n8\n     \nreturn\n \nz\n\n    \nReturn\n \nvalue\n:\n..\n \n5\n\n\nModified\n \nvar\n:\n..\n \nk\n \n=\n \n5\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n16\n         \nnumber\n \n-=\n \n1\n\n\nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n1\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n15\n         \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n    \nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n5\n\n    \nStarting\n \nvar\n:\n..\n \ny\n \n=\n \n1\n\n    \n22\n:\n26\n:\n08.186202\n \ncall\n         \n6\n \ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \n22\n:\n26\n:\n08.186202\n \nline\n         \n7\n     \nz\n \n=\n \nx\n \n+\n \ny\n\n    \nNew\n \nvar\n:\n.......\n \nz\n \n=\n \n6\n\n    \n22\n:\n26\n:\n08.186202\n \nline\n         \n8\n     \nreturn\n \nz\n\n    \n22\n:\n26\n:\n08.186202\n \nreturn\n       \n8\n     \nreturn\n \nz\n\n    \nReturn\n \nvalue\n:\n..\n \n6\n\n\nModified\n \nvar\n:\n..\n \nk\n \n=\n \n6\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n16\n         \nnumber\n \n-=\n \n1\n\n\nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n0\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\n22\n:\n26\n:\n08.186202\n \nline\n        \n17\n     \nreturn\n \nnumber\n\n\n22\n:\n26\n:\n08.186202\n \nreturn\n      \n17\n     \nreturn\n \nnumber\n\n\nReturn\n \nvalue\n:\n..\n \n0\n从上述输出结果可以看出，函数one与函数two的输出缩进层次一目了然。\n除了缩进之外，PySnooper还提供了参数\nprefix\n给debug信息添加前缀的方式便于识别，\n@pysnooper.snoop\n(\nprefix\n=\n\"funcTwo \"\n)\n\n\ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n    \nz\n \n=\n \nx\n \n+\n \ny\n\n    \nreturn\n \nz\n\n\n​\n\n\n​\n\n\n@pysnooper.snoop\n(\nprefix\n=\n\"funcOne \"\n)\n\n\ndef\n \none\n(\nnumber\n):\n\n    \nk\n \n=\n \n0\n\n    \nwhile\n \nnumber\n:\n\n        \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n        \nnumber\n \n-=\n \n1\n\n    \nreturn\n \nnumber\n\n\n​\n\n\n​\n\n\none\n(\n3\n)\n\n\n​\n\n\n# 输出\n\n\nfuncOne\n \nStarting\n \nvar\n:\n..\n \nnumber\n \n=\n \n3\n\n\nfuncOne\n \n22\n:\n28\n:\n14.259212\n \ncall\n        \n12\n \ndef\n \none\n(\nnumber\n):\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n13\n     \nk\n \n=\n \n0\n\n\nfuncOne\n \nNew\n \nvar\n:\n.......\n \nk\n \n=\n \n0\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n15\n         \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n\nfuncTwo\n     \nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n0\n\n\nfuncTwo\n     \nStarting\n \nvar\n:\n..\n \ny\n \n=\n \n3\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \ncall\n         \n6\n \ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nline\n         \n7\n     \nz\n \n=\n \nx\n \n+\n \ny\n\n\nfuncTwo\n     \nNew\n \nvar\n:\n.......\n \nz\n \n=\n \n3\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nline\n         \n8\n     \nreturn\n \nz\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nreturn\n       \n8\n     \nreturn\n \nz\n\n\nfuncTwo\n     \nReturn\n \nvalue\n:\n..\n \n3\n\n\nfuncOne\n \nModified\n \nvar\n:\n..\n \nk\n \n=\n \n3\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n16\n         \nnumber\n \n-=\n \n1\n\n\nfuncOne\n \nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n2\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n15\n         \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n\nfuncTwo\n     \nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n3\n\n\nfuncTwo\n     \nStarting\n \nvar\n:\n..\n \ny\n \n=\n \n2\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \ncall\n         \n6\n \ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nline\n         \n7\n     \nz\n \n=\n \nx\n \n+\n \ny\n\n\nfuncTwo\n     \nNew\n \nvar\n:\n.......\n \nz\n \n=\n \n5\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nline\n         \n8\n     \nreturn\n \nz\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nreturn\n       \n8\n     \nreturn\n \nz\n\n\nfuncTwo\n     \nReturn\n \nvalue\n:\n..\n \n5\n\n\nfuncOne\n \nModified\n \nvar\n:\n..\n \nk\n \n=\n \n5\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n16\n         \nnumber\n \n-=\n \n1\n\n\nfuncOne\n \nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n1\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n15\n         \nk\n \n=\n \ntwo\n(\nk\n,\n \nnumber\n)\n\n\nfuncTwo\n     \nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n5\n\n\nfuncTwo\n     \nStarting\n \nvar\n:\n..\n \ny\n \n=\n \n1\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \ncall\n         \n6\n \ndef\n \ntwo\n(\nx\n,\n \ny\n):\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nline\n         \n7\n     \nz\n \n=\n \nx\n \n+\n \ny\n\n\nfuncTwo\n     \nNew\n \nvar\n:\n.......\n \nz\n \n=\n \n6\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nline\n         \n8\n     \nreturn\n \nz\n\n\nfuncTwo\n     \n22\n:\n28\n:\n14.260211\n \nreturn\n       \n8\n     \nreturn\n \nz\n\n\nfuncTwo\n     \nReturn\n \nvalue\n:\n..\n \n6\n\n\nfuncOne\n \nModified\n \nvar\n:\n..\n \nk\n \n=\n \n6\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n16\n         \nnumber\n \n-=\n \n1\n\n\nfuncOne\n \nModified\n \nvar\n:\n..\n \nnumber\n \n=\n \n0\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n14\n     \nwhile\n \nnumber\n:\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nline\n        \n17\n     \nreturn\n \nnumber\n\n\nfuncOne\n \n22\n:\n28\n:\n14.260211\n \nreturn\n      \n17\n     \nreturn\n \nnumber\n\n\nfuncOne\n \nReturn\n \nvalue\n:\n..\n \n0\n参数\nwatch\n可以用于查看一些非局部变量，例如，\nclass\n \nTest\n():\n\n    \nt\n \n=\n \n10\n\n\n​\n\n\n​\n\n\ntest\n \n=\n \nTest\n()\n\n\n​\n\n\n​\n\n\n@pysnooper.snoop\n(\nwatch\n=\n(\n\"test.t\"\n,\n \n\"x\"\n))\n\n\n​\n\n\n# 输出\n\n\nStarting\n \nvar\n:\n..\n \nnumber\n \n=\n \n3\n\n\nStarting\n \nvar\n:\n..\n \ntest\n.\nt\n \n=\n \n10\n\n\nStarting\n \nvar\n:\n..\n \nx\n \n=\n \n10\n参数\nwatch_explode\n可以展开字典或者列表显示它的所有属性值，对比一下它和\nwatch\n的区别，\n#### watch_explode ####\n\n\nd\n \n=\n \n{\n\n    \n\"one\"\n:\n \n1\n,\n\n    \n\"two\"\n:\n \n1\n\n\n}\n\n\n​\n\n\n​\n\n\n@pysnooper.snoop\n(\nwatch_explode\n=\n\"d\"\n)\n\n\n​\n\n\n# 输出\n\n\nStarting\n \nvar\n:\n..\n \nnumber\n \n=\n \n3\n\n\nStarting\n \nvar\n:\n..\n \nd\n \n=\n \n{\n'one'\n:\n \n1\n,\n \n'two'\n:\n \n1\n}\n\n\nStarting\n \nvar\n:\n..\n \nd\n[\n'one'\n]\n \n=\n \n1\n\n\nStarting\n \nvar\n:\n..\n \nd\n[\n'two'\n]\n \n=\n \n1\n\n\n​\n\n\n#### watch ####\n\n\nd\n \n=\n \n{\n\n    \n\"one\"\n:\n \n1\n,\n\n    \n\"two\"\n:\n \n1\n\n\n}\n\n\n​\n\n\n​\n\n\n@pysnooper.snoop\n(\nwatch\n=\n\"d\"\n)\n\n\n​\n\n\n# 输出\n\n\nStarting\n \nvar\n:\n..\n \nd\n \n=\n \n{\n'one'\n:\n \n1\n,\n \n'two'\n:\n \n1\n}\n可以看出\nwatch_explode\n能够展开字典的属性值。\n另外还有参数\ndepth\n显示函数中调用函数的snoop行，默认值为1，参数值需要大于或等于1。\n更多我的作品 \nJackpop：请问自学Python有必要买课程吗？\nJackpop：Python调试工具之pdb\nJackpop：一文教你配置得心应手的Python\n后续分享会以公众号和个人主页为主，感兴趣的请关注公众号【平凡而诗意】，或者收藏个人主页~\n平凡而诗意"},
{"title": "Python 与 Excel 不得不说的事", "description": "//github.com/python-excelhttps://github.com/python-excel/tutorial/raw/master/python-excel", "article": "数据处理是 Python 的一大应用场景，而 Excel 则是最流行的数据处理软件。因此用 Python 进行数据相关的工作时，难免要和 Excel 打交道。\n如果仅仅是要以表单形式保存数据，可以借助 CSV 格式（一种以逗号分隔的表格数据格式）进行处理，Excel 也支持此格式。但标准的 Excel 文件（xls/xlsx）具有较复杂的格式，并不方便像普通文本文件一样直接进行读写，需要借助第三方库来实现。\n常用的库是 python-excel 系列：\nxlrd、xlwt、xlutils\nxlrd － 读取 Excel 文件\nxlwt － 写入 Excel 文件\nxlutils － 操作 Excel 文件的实用工具，如复制、分割、筛选等\n尽管这是目前被用得最多的 Excel 库，我还是很想吐槽为什么这三个包不能放在一个模块里……另外它们有个缺陷，就是只能处理 xls 文件。如果你想用新版本的 xlsx，可以考虑 openpyxl 和 xlsxwriter。\n不过今天只说说这三个。\n（更新：有人提到另外几个 Python 处理 Excel 的库，有些的确会比 python-excel 系列好用。之后会再做一篇对比，敬请期待。\n另外，关于为什么不用 VBA、Java、C#……处理 Excel。其实本文的出发点是对于 Python 使用者来说，操作 Excel 的一种基本方式，并非否定其他语言和方法。）\n安装\n安装的方法没啥特别的，只是得装三遍。可以下载安装包、下载代码压缩包、或者通过 pip 等。可参考 \n如何安装 Python 的第三方模块 - Crossin的编程教室 - 知乎专栏\n如果安装过之前推荐的 anaconda，那么就已经有了 xlrd 和 xlwt，但 xlutils 没有附带在安装包中，使用时仍需另行安装。\n读取\n结合一段简单的代码来看：\nimport\n \nxlrd\n\n\n# 打开 xls 文件\n\n\nbook\n \n=\n \nxlrd\n.\nopen_workbook\n(\n\"test.xls\"\n)\n\n\nprint\n \n\"表单数量:\"\n,\n \nbook\n.\nnsheets\n\n\nprint\n \n\"表单名称:\"\n,\n \nbook\n.\nsheet_names\n()\n\n\n# 获取第1个表单\n\n\nsh\n \n=\n \nbook\n.\nsheet_by_index\n(\n0\n)\n\n\nprint\n \nu\n\"表单 \n%s\n 共 \n%d\n 行 \n%d\n 列\"\n \n%\n \n(\nsh\n.\nname\n,\n \nsh\n.\nnrows\n,\n \nsh\n.\nncols\n)\n\n\nprint\n \n\"第二行第三列:\"\n,\n \nsh\n.\ncell_value\n(\n1\n,\n \n2\n)\n\n\n# 遍历所有表单\n\n\nfor\n \ns\n \nin\n \nbook\n.\nsheets\n():\n\n    \nfor\n \nr\n \nin\n \nrange\n(\ns\n.\nnrows\n):\n\n        \n# 输出指定行\n\n        \nprint\n \ns\n.\nrow\n(\nr\n)\n测试文件：\n输出结果：\n表单数量: 2\n表单名称: [u'Group.A', u'Group.B']\n表单 Group.A 共 7 行 3 列\n第二行第三列: 15.0\n[text:u'Rank', text:u'Team', text:u'Points']\n[number:1.0, text:u'Brazil', number:15.0]\n[number:2.0, text:u'Russia', number:12.0]\n...\n常用的方法：\nopen_workbook 打开文件\nsheet_by_index 获取某一个表单\nsheets 获取所有表单\ncell_value 获取指定单元格的数据\n写入\n还是看代码：\nimport\n \nxlwt\n\n\n# 创建 xls 文件对象\n\n\nwb\n \n=\n \nxlwt\n.\nWorkbook\n()\n\n\n# 新增一个表单\n\n\nsh\n \n=\n \nwb\n.\nadd_sheet\n(\n'A Test Sheet'\n)\n\n\n# 按位置添加数据\n\n\nsh\n.\nwrite\n(\n0\n,\n \n0\n,\n \n1234.56\n)\n\n\nsh\n.\nwrite\n(\n1\n,\n \n0\n,\n \n8888\n)\n\n\nsh\n.\nwrite\n(\n2\n,\n \n0\n,\n \n'hello'\n)\n\n\nsh\n.\nwrite\n(\n2\n,\n \n1\n,\n \n'world'\n)\n\n\n# 保存文件\n\n\nwb\n.\nsave\n(\n'example.xls'\n)\n生成文件：\n常用的方法：\nWorkbook 创建文件对象\nadd_sheet 新增一个表单\nwrite 在指定单元格写入数据\n修改\n很遗憾，并没有直接修改 xls 文件的方法。通常的做法是，读取出文件，复制一份数据，对其进行修改，再保存。\n在复制时，需要用到 xlutils 中的方法。\nfrom\n \nxlrd\n \nimport\n \nopen_workbook\n\n\nfrom\n \nxlutils.copy\n \nimport\n \ncopy\n\n\n# 打开文件\n\n\nrb\n \n=\n \nopen_workbook\n(\n\"example.xls\"\n)\n\n\n# 复制\n\n\nwb\n \n=\n \ncopy\n(\nrb\n)\n\n\n# 选取表单\n\n\ns\n \n=\n \nwb\n.\nget_sheet\n(\n0\n)\n\n\n# 写入数据\n\n\ns\n.\nwrite\n(\n0\n,\n \n1\n,\n \n'new data'\n)\n\n\n# 保存\n\n\nwb\n.\nsave\n(\n'example.xls'\n)\n修改后文件：\n特别要注意的是，选取读取表单时，要使用 sheet_by_index，而在选取写入表单时，则要用 get_sheet。不要问我为什么，我也很想知道这么设定的用意何在……\n时间转换\n如果表单中有时间格式的数据，通过处理之后，你会发现时间数据出了差错。\n输出单元格内容：\n[number:8888.0, xldate:42613.0]\n因为这里 xldate 有自己的格式定义。如果要使用正确的格式，必须转换：\nnew_date\n \n=\n \nxlrd\n.\nxldate\n.\nxldate_as_datetime\n(\ndate\n,\n \nbook\n.\ndatemode\n)\n\n\ndate 是对应单元格的数据，book 是打开的文件对象。\n另外，在打开文件时，加上参数 formatting_info=True，可以保证在时间数据在 copy 时保持原样。\n写入时间数据，则可通过此方法创建 excel 的时间对象：\nxlrd\n.\nxldate\n.\nxldate_from_datetime_tuple\n\n\n或者通过 xlwt.easyxf 指定时间格式：\nstyle\n \n=\n \nxlwt\n.\neasyxf\n(\nnum_format_str\n=\n'D-MMM-YY'\n)\n\n\nws\n.\nwrite\n(\n1\n,\n \n0\n,\n \ndatetime\n.\nnow\n(),\n \nstyle\n)\n\n\n具体细节及更多功能这里不展开说明。\n以上便是 Python 操作 Excel 文件的一些基本方法。实际使用过程中遇到问题或者需要了解更多功能，永远记住两个词：\nRTFM\n、\nSTFW\n：）\n参考资料：\nhttp://www.\npython-excel.org/\nhttps://\ngithub.com/python-excel\nhttps://\ngithub.com/python-excel\n/tutorial/raw/master/python-excel.pdf\n其他文章及回答：\n想用 Python 做数据分析？先玩玩这个再说 - Crossin的文章 - 知乎专栏\n用 Python 实现你的量化交易策略 - Crossin的文章 - 知乎专栏\n学习编程的过程中可能会走哪些弯路，有哪些经验可以参考？ - Crossin 的回答\n你是如何自学 Python 的？ - Crossin 的回答\n编程初学者如何使用搜索引擎 - Crossin的文章 - 知乎专栏\n如何直观地理解程序的运行过程？- Crossin的文章 - 知乎专栏\n如何在 Python 中使用断点调试 - Crossin的文章 - 知乎专栏\nPython 抓取网页乱码原因分析 - Crossin的编程教室 - 知乎专栏\n极简 Github 上手教程 - Crossin的编程教室 - 知乎专栏\nCrossin的编程教室\n \n微信ID：crossincode\n论坛：\nCrossin的编程教室"},
{"title": "计算机二级 Python 怎么考？考什么？", "description": "基本要求 1. 掌握Python 语言的基本语法规则｡ 2. 掌握不少于2 个基本的Python 标准库｡ 3. 掌握不少于2 个Python 第三方库,掌握获取并安装第三方库的方法｡", "article": "2020.1.15更新：\n有同学想知道去哪里买最新版（2020版）教材，请查看官网推荐的教材：\nhttp://\nncre.neea.edu.cn/html1/\nreport/19124/257-1.htm\n＝＝＝＝＝＝＝＝＝＝\n2020.1.8更新：有同学问我的公共基础那10分是怎么拿到的，应该客观的说，这几年的题目好像变了，可能有的题不是以前的题库里面的，有的是新题，但是估计新题占到3个或者4个，因此背题库还是有方法的。我当时用的app好像是“计算机二级通”，可以刷选择题，错题本的功能，非常爽！只有安卓版本，而且免费！\n＝＝＝＝＝＝＝\n作为第一批吃螃蟹的人，下面的教程将有助于大家顺利通过Python二级考试。\n今天各地区开始发布2019年3月份的二级成绩，大家有过的留个言～【评论里出现2个优秀，1个及格】\n2019年1月10日更新：大家别光收藏，动动手指麻烦帮忙点个赞。谢谢亲们！\n有同学反应封面不一样了，大家如果是考2019年的话，教材参考下面这2个图：\n（1）全国计算机等级考试二级教程——Python语言程序设计(2019年版)\n（2）高教版 Python语言程序设计冲刺试卷（含线上题库）第2版\n===============\n以下是之前的回答：\n昨天查了成绩，→优秀。\n祝大家也能取得好成绩！\n想要考\n二级office\n的同学戳这里：  \nhttps://www.\nzhihu.com/question/3068\n91507/answer/559322832\n——————————————————————————— \n前几天是计算机二级考试刚刚过去（这是第一次全国范围内的python进入计算机二级考试范畴），本着以考促学的理念，作者较为系统的学习了计算机二级Python科目。下面分享的是本人在复习期间总结的资料，在一定程度上能对大家的学习与备考起到辅助作用。\n1.备考教材推荐\n推荐之前要说明一个情况，首先这2本教材是教育部考试中心推荐的2本教材，当然这个可能没有一定的说服性，其次需要说明的是，第1本教材的作者（嵩天）就是推动整个计算机二级python科目成立的关键人物，最后需要说明的是嵩天是国家精品课程《Python语言程序设计》的主讲老师。换句话说，计算机二级考什么？怎么考？基本上嵩天这个团队都是整个趋势的领导者，或者叫做“命题人”。另外而言，python作为新兴的二级科目，开始的考试内容不可能太难，因为一样新东西想要获得推广，其本身是不可能具有很高的门槛的。总而言之，无论是要想拿一个二级证，还是想要好好学习python的都可以跟着嵩天老师的步伐，一步一个脚印，一步一个阶梯，循序渐进，融会贯通，举一反三。\n（1）全国计算机等级考试二级教程——Python语言程序设计(2018年版)\n（2）高教版Python语言程序设计冲刺试卷\n这里需要多说两句，学习的顺序是怎样的：我个人建议\n先看下面推荐的视频，然后再看教材1，最后看教材2，看教材2的同时在\nhttp://\npython123.io\n网站完成相关的练习\n，这样基本上达到了知识吸收、系统训练、学以致用的效果。\n2.备考视频教程推荐\n该门课程由北京理工大学的\n嵩天、黄天羽\n和\n礼欣老师\n倾力打造，在2017年被评为\n国家精品在线开放课程\n，目前是\n第7次\n开课，累计超过17W人次选课，吸引了\n6k+次评论\n并获得\n4.8分的好评（满分5分）\n，课程质量由此可知。\n视频地址：\nhttps://www.\nicourse163.org/learn/BI\nT-268001\n（需要全套下载链接的同学可以去下面的公众号回复“二级”，因为知乎不让放这个链接）\n3.学习网站推荐\n（0）计算机二级官网（必收藏）：\nhttp://\nncre.neea.edu.cn/\n \n（1）\nhttps://\npython123.io/\n（2）\nhttp://www.\nrunoob.com/python3/pyth\non3-tutorial.html\n（3）\nhttps://www.\npython.org/\n4.错题总结（110页PDF）\n5. 教材编程题答案（涵盖教材95%的课后答案）\n该答案由作者亲自编写，未必完善，但是提供一个思路，也算功德无量。\n查看公众号: \n读研札记\n ，后台回复 “二级”。\n或者戳这里：\n【电脑技巧】第31期：(新)计算机二级Python备考指导\n=======================\n6.备考大纲\n全国计算机等级考试考试大纲(2019年版） - 中国教育考试网\n全国计算机等级考试二级Python 语言程序设计考试大纲(2018 年版)\n基本要求\n1. 掌握Python 语言的基本语法规则｡\n2. 掌握不少于2 个基本的Python 标准库｡\n3. 掌握不少于2 个Python 第三方库,掌握获取并安装第三方库的方法｡\n4. 能够阅读和分析Python 程序｡\n5. 熟练使用IDLE 开发环境,能够将脚本程序转变为可执行程序｡\n6. 了解Python 计算生态在以下方面(不限于)的主要第三方库名称:网络爬虫､数据分析､数\n据可视化､机器学习､Web 开发等｡\n考试内容\n一､Python 语言基本语法元素\n1. 程序的基本语法元素:程序的格式框架､缩进､注释､变量､命名､保留字､数据类型､赋值\n语句､引用｡\n2. 基本输入输出函数:input()､eval()､print()｡\n3. 源程序的书写风格｡\n4. Python 语言的特点｡\n二､基本数据类型\n1. 数字类型:整数类型､浮点数类型和复数类型｡\n2. 数字类型的运算:数值运算操作符､数值运算函数｡\n3. 字符串类型及格式化:索引､切片､基本的format()格式化方法｡\n4. 字符串类型的操作:字符串操作符､处理函数和处理方法｡\n5. 类型判断和类型间转换｡\n三､程序的控制结构\n1. 程序的三种控制结构｡\n2. 程序的分支结构:单分支结构､二分支结构､多分支结构｡\n3. 程序的循环结构:遍历循环､无限循环､break 和continue 循环控制｡\n4. 程序的异常处理:try-except｡\n四､函数和代码复用\n1. 函数的定义和使用｡\n2. 函数的参数传递:可选参数传递､参数名称传递､函数的返回值｡\n3. 变量的作用域:局部变量和全局变量｡\n五､组合数据类型\n1. 组合数据类型的基本概念｡\n2. 列表类型:定义､索引､切片｡\n3. 列表类型的操作:列表的操作函数､列表的操作方法｡\n4. 字典类型:定义､索引｡\n5. 字典类型的操作:字典的操作函数､字典的操作方法｡\n六､文件和数据格式化\n1. 文件的使用:文件打开､读写和关闭｡\n2. 数据组织的维度:一维数据和二维数据｡\n3. 一维数据的处理:表示､存储和处理｡\n4. 二维数据的处理:表示､存储和处理｡\n5. 采用CSV 格式对一二维数据文件的读写｡\n七､Python 计算生态\n1. 标准库:turtle 库(必选)､random 库(必选) ､time 库(可选)｡\n2. 基本的Python 内置函数｡\n3. 第三方库的获取和安装｡\n3. 脚本程序转变为可执行程序的第三方库:PyInstaller 库(必选)｡\n4. 第三方库:jieba 库(必选)､wordcloud 库(可选)｡\n5. 更广泛的Python 计算生态,只要求了解第三方库的名称,不限于以下领域:网络爬虫､数\n据分析､文本处理､数据可视化､用户图形界面､机器学习､Web 开发､游戏开发等｡\n 考试方式\n 上机考试,考试时长120 分钟,满分100 分｡\n1. 题型及分值\n单项选择题40 分(含公共基础知识部分10 分)｡\n操作题60 分(包括基本编程题和综合编程题)｡\n2. 考试环境\nWindows 7 操作系统,建议Python 3.4.2 至Python 3.5.3 版本,IDLE 开发环境｡\n7.指定教材\n全国计算机等级考试教材目录（2019年版） - 中国教育考试网\n8.提示\n计算机二级采取的是\nPython3\n，大家记得学语法或者是买书籍务必看清楚版本，不要白白浪费时间。\n9.考试题型与介绍\n（1）选择题1-10为公共基础题（10分），11-40为python题（30分）\n（2）编程题共6道，其中1-3为基本编程题（5分+5分+5分），4-5为简单应用题（10分+15分），6为综合编程题（20分）。\n具体来说，今年的选择题前面10道公共基础题比较难（题库中出现的原题很少，都是些新的数据题，有的名词都没有见过），不建议花大量时间复习；11-40的python选择题题目不是很难，只要对python的语法有清晰的认识，基本都能做出来，即使有难的，也是需要计算几步而已，计算的时候小心一点，有的题目可能有陷阱，这种题目不超过3道。\n最后再说说编程题，1-3的考试方法是填空，意思是题目给你一个.py文件，其中的代码框架已经给你，你只需要在其中空白的位置填1到2个关键词就行，前面3个题目都是这种填空（注意有的题目要求文件中给出代码框架不能修改，有的可以修改，请务必看清楚题目），注意，最好填完运行下，看看是否满足题目意思，比如今年的一个题目是要求随机抽一个手机品牌，这道题目的关键点在于你要使用seed()函数覆盖原来的给定的种子seed(1)，因为要求“\n随机\n”，假如你只用了random，结果是不会随机的，因为seed(1)这个种子控制了random必然出现的是同一个结果，所以自己为了保险起见，可以自己多调试几次；再来说说4-5题是简单应用题，这2个题目也不难，比如就是分段函数用if等待，或者是turtle画图的函数，这些只要搞清楚，turtle画图的角度，长度，画笔等等基本都没问题。\n可以说，最难的是最后一道题目，要想获得优秀或者及格，这道题目基本奠定了整体，只要你这道题没做出来，估计前面再错的比较多，那就有点危险了；好了，再说说这道题是怎么出的，一般是分词或者是排序，或者是整理数据，文件io之类的，这种题目需要比较扎实的基础，如果想要优秀，毋庸置疑，这道题目必须做对；一般情况下，题目会给出基本的代码框架，一般的这道题目是可以修改代码的（按照自己的思路，当然具体要求还是要看题目给出），这种题目是结果导向的，也就是说只要运行结果对了，它就判对，但是如果你人工操作得到答案肯定是不行的，一方面，数据量大没法操作，另一方面，系统判分系统应该会识别你是否通过运行python得到结果，所以投机取巧的心态就不要有了。好好复习吧。\n10.计算机二级python考试真题及视频（2018年9月真题）\n由于知乎限制，链接没法直接放，查看公众号: \n读研札记\n ，后台回复 “\n二级\n”。\n最后的最后，祝大家备考顺利，最好是真真正正的学习一门编程语言！~over\n更多干货，关注“读研札记”公众号，分享一些学习与科研上的心得体会，多交几个朋友。"},
{"title": "30 个惊艳的Python开源项目", "description": "是该拿出时间来玩玩过去一年中可能错过的Python项目啦！ Python开源项目排行榜 第一名 家庭助理（v0.6+）：开源家庭自动化平台 在Python 3上运行[Github上11357颗星]", "article": "在过去的一年里，Mybridge AI 比较了近15000个开源Python项目，选择了前30名（概率只有0.2%）。\n这是一个竞争异常激烈的名单，精挑细选了2017年1月到12月之间发布的最佳开源Python库、工具和应用程序。Mybridge AI 通过考量受欢迎程度、参与度和新近度等指标来评估这些参选项目的质量。这些项目在\nGithub上得星的数量平均为3,707个\n。\n开源项目对于程序员来说可能大有裨益。通过阅读源代码并在现有项目之上构建一些东西。是该拿出时间来玩玩过去一年中可能错过的Python项目啦！\nPython开源项目排行榜\n第一名\n家庭助理（v0.6+）：开源家庭自动化平台\n在Python 3上运行\n[Github上11357颗星]\n。由Paulus Schoutsen提供\n第二名\nPytorch：强GPU加速Python中的Tensor和动态神经网络\n[Github上11019颗星]\n。由Adam Paszke 和pytorch团队其他成员提供\n第三名\nGrumpy：一个Python源代码反编译和运行\n[Github上8367颗星]\n。由Dylan Trotter和Google的其他成员提供\n第四名\nSanic：异步Python3.5+Web服务器加速\n[Github上8028颗星]\n。由Channel Cat和Eli Uriegas提供\n第五名\nPython—fire：从任意Python对象中自动生成命令行接口（CLIs）的库\n[Github上7775颗星]\n。由David Bieber和来自Google Brain（Google Brain是Google内部用于训练大规模深度神经网络的构架，它为用户提供了方便的API）的其他成员提供\n第六名\nspaCy(v2.0)：用Python和Cython实现工业强度的自然语言处理（NLP）\n[Github上7663颗星]\n。由Matthew Honnibal提供\n第七名\nPipenv：人类的Python开发工作流\n[Github上7273颗星]\n。由Kenneth Reitz提供\n第八名\nMicroPython：简单和高效的Python实现微控制和约束系统\n[Github上5728颗星]\n第九名\nProphet：生成具有线性或非线性增长的多重季节性的时间序列数据的高质量预测工具\n[Github上4369颗星]\n。由Facebook提供\n第十名\nSerpentAI：用Python编写的游戏代理框架。帮助创建Ais/Bots，可以玩任意游戏\n[Github上3411颗星]\n。由Nicholas Brochu提供\n第十一名\nDash：用纯Python编写的交互的、实时响应的Web应用程序\n[Github上3281颗星]\n。由Chris P提供\n第十二名\nInstaPy：Instagram Bot. Like/Comment/Follow自动化脚本。\n[Github上3179颗星]\n。由TImG提供\n第十三名\nApistar：一个快速的和有表现力的API框架。用于Python\n[Github上3024颗星]\n。由Tom Christie提供\n第十四名\nFaiss：有效相似性搜索和密集向量集群的库\n[Github上2717颗星]\n。由Matthijs Douze和来自Facebook研究院的其他成员提供\n第十五名\nMechanicalSoup：一个与网站自动化交互的Python库\n[Github上2244颗星]\n。\n第十六名\nBetter-exceptions：用Python编写的自动地漂亮的和有用的异常处理\n[Github上2121颗星]\n。由Qix提供\n第十七名\nFlashtext：从句子中提取关键词或替换句子中的关键词\n[Github上2019颗星]\n。由Vikash Singh提供\n第十八名\nMaya：用Python实现人类的日期时间\n[Github上1828颗星]\n。由Kenneth Reitz提供\n第十九名\nMimesis (v1.0)：Python库，有助于为不同的目的以不同的语言生成模拟数据。这些数据在软件开发和测试的不同阶段特别有用\n[Github上1732颗星]\n。由Líkið Geimfari 提供\n第二十名\n开放式无纸化：扫描、索引和归档所有的纸质文档。一个文档管理系统\n[Github上1717颗星]\n。由Tina Zhou提供\n第二十一名\nFsociety：黑客工具包。渗透测试框架\n[Github上1585颗星]\n。由Manis Manisso提供\n第二十二名\nLivePython：实时可视化跟踪Python代码\n[Github上1577颗星]\n。由Anastasis Germanidis提供\n第二十三名\nHatch：用于Python的现代项目、包和虚拟环境管理器\n[Github上1537颗星]\n。由Ofek Lev提供\n第二十四名\nTangent:用纯Python实现源到源的可调试导数\n[Github上1433颗星]\n。由Alex Wiltschko和来自Google Brain其他成员提供\n第二十五名\nClairvoyant：识别和监控短期股票走势的历史线索的Python程序\n[Github上1159颗星]\n。由Anthony Federico提供\n第二十六名\nMonkeyType：Python通过收集运行时类型生成静态类型注释的系统\n[Github上1143颗星]\n。由Instagram工程组的Carl Meyer提供\n第二十七名\nEel：一个小的Python库，用于制作简单的电子类HTML / js GUI应用程序\n[Github上1137颗星]\n。\n第二十八名\nSurprise v1.0：建立和分析推荐系统的Python scikit\n[Github上1103颗星]\n。\n第二十九名\nGain：获取每个人的Web爬行框架\n[Github上1009颗星]\n。由高久力提供\n第三十名\nPDFTabExtract: 一组从PDF文件中提取表的工具，有助于对扫描文档进行数据挖掘\n[Github上722颗星]\n。"},
{"title": "为什么很多人喜欢 Python？", "description": "但在深入CS学科的很多高级主题时，Python能发挥出更加强大无比的力量。而这来自于Python是个好胶水。 坦白讲，Python不算最好的胶水，至少Lua做胶水就比Python好，API好用", "article": "2005年中期，用了几天学完了Python，随后两天用了十几个小时写了编译原理的课程设计，这是我大学阶段所有课程设计里唯一没有延期的。\n后来逐渐发现Python的简单可以把我的思想从编程语言的细节里解放出来，更关注实际要解决的问题。\n就喜欢上了。\n既然有人点赞，就再补充点。\n很多人关注起Python就是因为简单易懂，做Web很方便。但在深入CS学科的很多高级主题时，Python能发挥出更加强大无比的力量。而这来自于Python是个好胶水。\n坦白讲，Python不算最好的胶水，至少Lua做胶水就比Python好，API好用。但Python再算上强大的标准库、数据结构、友好的转义后，就脱颖而出了。\n在科学计算领域，NumPy和SciPy的存在解放了很多人的思想束缚。其底层C模块，性能一流。\n而当你需要一流的性能与一流的可调试性时，Python C模块是最好的选择。封装虽然有些麻烦，但封装后可以在Python里调用实在太方便。一些已有的C/C++应用也可以通过将函数封装给Python调用，而极大的降低调试难度，提升单元测试覆盖率。\n2007年时我开始学Python的C模块编程，并在博客中放出了我的笔记。那时写了不少东西。封装libpcap后，做网络抓包，通信劫持，使得别人眼里，我俨然是个正经黑客。后来迷恋erlang期间，做了C node的Python封装，使得Python与Erlang可以互发消息，组建集群。搞硬件开发期间，封装了Cubieboard和RaspberryPi的GPIO、SPI等众多外设的Python接口，调试速度快到了云边。做USB通信期间，因为PyUSB不支持isochronous通信而自己重写了个libusb的Python封装，使得USB编程不再困难。做音视频识别的日子里，做了v4l2的Python封装，使得操作摄像头的控制精度达到了最高。\n相比于其他人，用上这些Python封装后，迭代速度数十倍的提高带来了系统进化速度的极大提高。比如我在音视频识别的研究期间，因为NumPy和我自己的封装，每天动则十几次甚至几十次的迭代，优化算法的各种参数。使得我在不到两年时间里，识别效果就超过可某大学教授12年的研究成果。识别速度更是超出对方两个数量级。\n对于各个领域的研究者，我是真心推荐Python的。用上NumPy和SciPy，你就拥有了极致的性能，顶级的可调式性，和产品级的稳定性。而这也使得Python的这套组合成为科学计算领域唯一能与matlab竞争的选择。\n过200赞我就专门写一篇文章介绍用Python做科学计算的几个实例。\n居然一个多小时就过200赞了。我的博客地址在 \nhttp://\ngashero.iteye.com/\n  ，我会用大约一周来写，写完后会把地址贴到这里。感谢大家的厚爱。\n人生苦短，快用Python！"},
{"title": "python操作Excel实现自动化报表", "description": "io/en/latest/ 二、安装python -m pip install xlrd xlwt xlutils 三、基本用法 python操作excel的相关工具包可以具体到操作指定单元格的填充样式、数值类型、数值大小等等", "article": "Excel作为日常办公最广泛使用的工具之一，学好它可以帮助我们节约时间，提升工作效率，学会灵活高效的使用excel有着十分重要的意义。\n本人觉得会使用大部分excel内置公式和以及VBA的就是高手了。\n不过比这更高级的是用程序操作excel，针对相似性很高或者重复性、繁琐的excel任务用一个程序可以实现一劳永逸，夸张的说：可以节省你的生命  哈哈。\n以下是python操作excel的介绍：\n一、工具包\n1.xlrd：从Excel电子表格中提取数据  doc地址：https://xlrd.readthedocs.io/en/latest/\n2.xlwt：将数据写入Excel电子表格   doc地址：https://xlwt.readthedocs.org/en/latest/\n3.xlutils：提供一组处理Excel文件的实用程序  doc地址：https://xlutils.readthedocs.io/en/latest/\n二、安装\npython -m pip install xlrd xlwt xlutils\n三、基本用法\npython操作excel的相关工具包可以具体到操作指定单元格的填充样式、数值类型、数值大小等等。然而python操作excel需要一定pandas数据处理功底，后续将补上章节：pandas数据处理技能\n1.从指定文件路径读取excel表格，进行一定操作，然后保存到另一个excel文件：result.xlsx\nimport xlwt\nimport xlrd\nfrom xlutils.copy import copy\nimport pandas as pd\nfrom pandas import DataFrame,Series\nimport os\nos.chdir('./')\n# 从指定文件路径读取excel表格\ndf = pd.read_excel('D:/mypaper/data/data.xlsx')\n# 查看df内容\n# 根据age算出出生年份，增加一列\nimport datetime\nimport os\nyear = datetime.datetime.now().year#获取当前系统时间对应的年份\ndf['birth'] = year-df['age']\ndf.to_excel('result.xlsx')#保存到当前工作目录，可以用os.getcwd()查看\n#查看下此时df的内容，可以看到已经生成了birth这一列\n乍看好像只用到了pandas，还没有用到上面介绍的三个工具包，下面介绍利用python操作excel底层\n2.单元格操作\n# 定义方法：读取指定目录下Excel文件某个sheet单元格的值\ndef excel_read(file_path,table,x,y):\n     data = xlrd.open_workbook(file_path)\n     table = data.sheet_by_name(table)\n     return table.cell(y,x).value\n\n# 定义方法：单元格值及样式\nwrite_obj_list = []\ndef concat_obj(cols,rows,value):\n    write_obj_list.append({'cols':cols,'rows':rows,'value':value,\\\n'style':xlwt.easyxf('font: name 宋体,height 280;alignment: horiz centre')})\n\n# 定义方法：合并单元格\ndef merge_unit(srows,erows,scols,ecols,value):\n    write_obj_list.append({'id':'merge','srows':srows,'erows':erows,'scols':scols,\\\n'ecols':ecols,'value':value,'style':xlwt.easyxf('font: name 宋体,height 280;alignment: horiz centre')})\n\n# 定义方法：更新excel\nexcel_update(file_path,write_obj_list,new_path):\n    old_excel = xlrd.open_workbook(file_path, formatting_info=True)\n    #管道作用\n    new_excel = copy(old_excel)\n    '''\n    通过get_sheet()获取的sheet有write()方法\n    '''\n    sheet1 = new_excel.get_sheet(0)\n    '''\n    1代表是修改第几个工作表里，从0开始算是第一个。此处修改第一个工作表\n    '''\n    for item in write_obj_list:\n        if 'id' not in item.keys():\n            if 'style' in item.keys():\n                sheet1.write(item['rows'], item['cols'], item['value'],item['style'])\n            else:\n                sheet1.write(item['rows'], item['cols'], item['value'])\n        else:\n            if 'style' in item.keys():\n                sheet1.write_merge(item['srows'],item['erows'],item['scols'], item['ecols'], item['value'],item['style'])\n            else:\n                sheet1.write_merge(item['srows'],item['erows'],item['scols'], item['ecols'], item['value'])\n    '''\n    如果报错 dict_items has no attributes sort\n    把syle源码中--alist.sort() 修改为----> sorted(alist) \n    一共修改2次\n    '''\n    new_excel.save(file_path)\n\n#参数详解\n# srows:合并的起始行数\n# erows:合并的结束行数\n# scols:合并的起始列数\n# ecols:合并的结束列数 \n# value:合并单元格后的填充值\n# style:合并后填充风格：\n#     font: name 宋体\n#     height 280;\n#     alignment: horiz centre\n#     ... 与excel操作基本保持一致\n\n注意:该方法仅仅是将需要直行的动作保存到一个list中，真正的动作还未执行,执行动作是发生在excel_update方法中\n最终调用excel_update方法，传入每个单元格需要进行的操作和填充值的write_obj_list以及文件保存路径file_path\n就可以在当前工作目录下生成想要的Excel结果文件。\n注意：\n1.write_obj_list支持用户自定义\n2.write_obj_list也可以是根据excel_read方法读取现有待修改的excel文件（可以维持原有表格的格式）而生成\npython操作excel还有很多其他的基本方法，因篇幅的限制不再陈述和演示，想要深入研究的可以点击上面的doc地址。\n学会python操作excel的单元格、并掌握上面的方法就可以基本实现excel的自动化报表操作了。\n如果您觉得有帮助的话，可以扫码，赞赏鼓励一下！谢谢！"},
{"title": "Python 打包成 exe，太大了该怎么解决？", "description": "他要求打包成exe文件，这当然不是什么难事。因为除了写Python的，绝大多数人电脑里都没有Python编译器，所以打包成exe，让用户（windows）双击就可以打开", "article": "这是一个很长的故事，嫌长的直接看最后的结论\n事情经过\n上周接了个需求，写了个小工具给客户，他要求打包成exe文件，这当然不是什么难事。因为除了写Python的，绝大多数人电脑里都没有Python编译器，所以打包成exe，让用户（windows）双击就可以打开，也算是必备技能了。\n直接用Pyinstaller，打开cmder:\npyinstaller -Fw E:\\test\\url_crawler.py\n（-F 是打包成一个文件，-w是不出现调试窗口，因为我的小工具里有GUI，所以不用默认的调试窗口）\n等了好久，终于完成打包，一看文件，嚯，200M！怪不得打包了这么久...\n上网查了下资料，有人说，Anaconda里内置了很多库，打包的时候打包了很多不必要的模块进去，要用纯净的Python来打包。\n有点道理，想着装虚拟机时间更长，准备拿出闲置的笔记本，重新装个Python来打包。\n可刚巧我最近在学flask的时候，用到pipenv，虽然还不懂pipenv的强大之处，但知道它是个管理虚拟环境和包的工具，于是想着能不能用pipenv来创建一个新的python编译器以运行pyinstaller进行打包。\n于是赶紧上网查了一下，pipenv pyinstaller，没有搜到有用的信息，干脆自己试一试，反正pipenv操作不麻烦。\n打开cmder:\n#建立虚拟环境\npipenv install\n#进入虚拟环境\npipenv shell\n#安装模块\npip install 小工具.py里面用到的模块\n#打包的模块也要安装\npip install pyinstaller\n#开始打包\npyinstaller -Fw E:\\test\\url_crawler.py\n打包完成，一看大小，11M！成功！\n后来因为客户改了需求，我又改了一下源代码，然后换了个目录用pipenv重新打包，结果打包完又变回200M！尝试了无数次，怎么也回不到过去的20M！我都怀疑之前的20M是我的幻觉了。\n不过无论如何要先交差，200M的“小“工具，用户体验肯定不行，所以我就用排除法，看看是哪个模块占的体积大，再想办法优化。最先怀疑的是GUI，我几乎毫不犹豫地认定是它，我用的是PySimpleGUI（强烈推荐，基于tkinter)，先把PySimpleGUI的内容注释掉，再进行打包，你们猜打包完有多大？\n198M！\n看来是我错怪他了，经过几次排除，发现了罪魁祸首就是：fake_useragent\n这个库是用来伪装请求头的，主要是我懒得复制user-agent，所以问题不大，把fake_useragent注释掉，自己手动粘贴一个user-agent就行了\n#from fake_useragent import UserAgent\n\n#ua = UserAgent()\n#headers = {'user-agent':ua.random}\nheaders = {'user-agent':'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.17 Safari/537.36'}\n不用fake_useragent，打包成exe是 14M，已经不错了，先交差再说\n之后经过了多次探索，多次放弃的边缘（反复删除创建环境），终于找到了完美打包的方法\n结论\n关键点就一个：\n要在虚拟环境里安装pyinstaller\n如果你没有在虚拟环境中安装pyinstaller，你同样可以使用pyinstaller命令，但是调用的是你系统原本的那个python编译器，内含很多关联库，导致即使在虚拟环境中，你打包的exe文件仍然非常大。\n另外一点要注意的是：要在虚拟环境里安装好你py文件中调用的库，不然打包出来也没法正常运行。\n最后再复习一下正确流程 (前提是安装好pipenv）：\n#建立虚拟环境\n\n\npipenv\n \ninstall\n\n\n#进入虚拟环境（上一步可省略,因为没有虚拟环境的话会自动建立一个）\n\n\npipenv\n \nshell\n\n\n#安装模块\n\n\npip\n \ninstall\n \nrequests\n \npyquery\n \npysimplegui\n \nfake_useragent\n\n\n#打包的模块也要安装\n\n\npip\n \ninstall\n \npyinstaller\n\n\n#开始打包\n\n\npyinstaller\n \n-\nFw\n \nE\n:\n\\\ntest\n\\\nurl_crawler\n.\npy\n点个赞支持一下呗！"},
{"title": "5个酷毙的Python工具", "description": "jupyter 写的 Python 教程。 地址：http://jupyter.org/ Anaconda Python 虽好，可总是会遇到各种包管理和 Python 版本问题", "article": "工欲善其事必先利其器，一个好的工具能让起到事半功倍的效果，Python社区提供了足够多的优秀工具来帮助开发者更方便的实现某些想法，下面这几个工具给我的工作也带来了很多便利，推荐给追求美好事物的你。\nPython Tutor\nPython Tutor 是由 Philip Guo 开发的一个免费教育工具，可帮助学生攻克编程学习中的基础障碍，理解每一行源代码在程序执行时在计算机中的过程。通过这个工具，教师或学生可以直接在 Web 浏览器中编写 Python 代码，并逐步可视化地运行程序。如果你不知道代码在内存中是如何运行的，不妨把它拷贝到Tutor里可视化执行一遍，加深理解。\n地址：\nhttp://www.\npythontutor.com/\nIPython\nIPython 是一个 for Humans 的 Python 交互式 shell，用了它之后你就不想再用自带的 Python shell 了，IPython 支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多实用功能和函数，同时它也是科学计算和交互可视化的最佳平台。在公众号【Pyhon之禅】回复 “ipython” 获取《IPython交互式编程和数据可视化教程》。\n地址：\nhttps://\nipython.org/\nJupyter Notebook\nJupyter Notebook 就像一个草稿本，能将文本注释、数学方程、代码和可视化内容全部组合到一个易于共享的文档中，以 Web 页面的方式展示。它是数据分析、机器学习的必备工具。在公众号【Pyhon之禅】回复 “jupyter” 给你看一个基于 jupyter 写的 Python 教程。\n地址：\nhttp://\njupyter.org/\nAnaconda\nPython 虽好，可总是会遇到各种包管理和 Python 版本问题，特别是 Windows 平台很多包无法正常安装，为了解决这些问题，Anaconda 出现了，Anaconda 包含了一个包管理工具和一个Python管理环境，同时附带了一大批常用数据科学包，也是数据分析的标配。之前在公众号有介绍过 Anaconda\n地址：\nhttps://www.\nanaconda.com/\nSkulpt\nSkulpt 是一个用 Javascript 实现的在线 Python 执行环境，它可以让你轻松在浏览器中运行 Python 代码。使用 skulpt 结合 CodeMirror 编辑器即可实现一个基本的在线Python编辑和运行环境。\n地址：\nhttp://www.\nskulpt.org/"},
{"title": "Python 这样 print 才够骚啊", "description": "操作 那么接下来就是学习 python 的正确姿势 在 Python 中print 函数中的 end 默认是 \\n 也就是说你在打印每个语句的时候", "article": "我们在玩 Python 的时候\n常常会使用到 print 这个函数\n主要用它来打印一些输出\n这样我们可以更加方便的知道\n程序的运行情况\n我们常常这样操作\n不过不是很骚\n有时候我们想更加直观的看到我们程序的运行进度\n比如你爬取某个文件的时候想看看它的下载进度啥的\n这次\n小帅b来告诉你print的一些骚操作\n那么接下来就是\n学习 python 的正确姿势\n在 Python 中print 函数中的 end 默认是 \\n\n也就是说你在打印每个语句的时候\n最后都以换行结尾\n比如这样\n这样的打印结果是这样的\n但是我们要的是\n在一行中打印就行并且能够一直刷新\n那么我们可以把 end 给改了\n默认是换行我们改成空字符试试看\n结果是这样的\n虽然是一行不过它是整块一起出来的\n没有刷新我们可以加个强制刷新\n因为 flush 默认为 False只有所有内容都有了然后一次性都打印出来\n而使用 True 就可以做到每次打印都及时显示出来\n使用 sleep 来看看显示效果\n不过对于一些百分比显示这样操作就不好了\n比如我们要显示这样的进度百分比\n想必你也想到了结果是这个鸟样\n我们希望的是\n数字一直变换就行了对吧\n这时候我们可以使用\n\\r\n这个转义字符\n它可以做到每次都回到开头\n我们试试看吧\n这里我们加入 \\r 之后\n就可以达到我们预想的那样啦\n当然了如果觉得自己搞一个这样的有点麻烦\n也有很多库满足你的需求比如\ntqdm\n秀\n又比如\nprogressbar\n效果是这样的\n以上这两个都是我挺喜欢用的库\n好了本期就分享到这\n我们下次见\npeace\n扫一扫学习 Python 没烦恼\n你拉到这里来\n是要给我点“赞”吗？"},
{"title": "Python与R、Matlab的对比", "description": "MATLAB OR Python中文，年代越近，由Matlab全面转向Python的建议就越多，更多人直言Python是未来的编程语言，在Python与Matlab的选择之上", "article": "作为一枚程序员，想要研究Python编程语言与数学学习（教学）的结合，就不能不了解以及比对一下其他数学学习与应用的解决方案，比如R语言、Matlab等数学软件。经过广泛的搜索了解了一下国外的反馈与趋势之后，最终的结论就是\nPython确实是未来\n。 \nPython与R语言的对比\nPython与R语言在数据分析领域的对比，DataCamp上有一篇引用率非常高的文章，\n数据分析选择R还是Python\n，不过这篇文章是2015年写的，我们先大致总结一下文章内容： \nR主要用于学术与研究，也开始迅速进入企业市场，越是接近统计学、研究、数据科学，你就会越偏爱R，而Python主要用于程序员想进入数据分析领域、掌握统计技能，以及其他开发人员进入数据科学领域。如果你的工作越接近工程环境，你会越偏爱Python。 \nR的社区生态主要是研究员，数据科学家、统计学家和量化研究员，而Python主要是程序员和开发者。 \nR学习门槛比较高，但是当你掌握了基础之后就学起来比较容易，R对程序员来说不难；Python可读性强，入门非常容易，被公认为非常不错的入门编程语言。\n在2015年前的Tiobe编程语言的排名上Python排名在第4或第5，R排在第17到13。而据2015数据分析领域，用R的研究员占58%，Python占42%，两者都用的占23.45%； \n在2013年，R转Python的有26%，Python转R的有18%，而新进入数据分析领域的有44%的人选择R，23%的人选择Python.\n从2015年之前的情况看来，正如作者所说，R和Python在数据分析领域确实平分秋色，难分伯仲，从数据中我们可以看出，虽然Python相比R更流行，在编程方面更有优势，但是在数据科学领域，选择使用R的人更多。\n但是翻到\n2018年的文章\n里看到2016、2017年的数据，情况下发生了逆转。在数据科学领域，2016年有34%的人选择Python，42%的人选择R，而到了2017年41%的人选择Python，36%的人选择R。在2017年的调查统计里数据科学家和工程师最流行的编程语言分别是JavaScript(58.7%，令人惊讶啊，可能与数据可视化有关？)、SQL（58%）、Python(45%)，而R（11.2%），Python在商业领域领域比较火，而R在学术和研究领域比较多，所以不那么流行吧。而在最近的Tiobe的排行榜上，与数据科学相关的编程语言Python、R、SQL、Matlab等涨幅都比较大，Python在整个编程语言的流行度也由2014年的2%猛增到2019年8.26%，跃居第3，成为2018年年度语言。\nPython、R、Scala在数据科学领域的流行包\n \nPython与Matlab的对比\n虽然不是学数学的，但是Matlab的大名可是如雷贯耳，与数学相关专业、相关行业的学生、工程师们基本一定会使用到它。MathWorks公司跟设计公司Adobe、三维软件公司Autodesk一样都是极其硬核的存在，旗下的产品不仅是学习必备，而且是工程（比工作听起来霸气）必备。我个人对Matlab的了解极其有限，Python与Matlab的对比我也只能像一个产品经理去广泛查阅专业意见来权衡利弊。我所得出的结论也只是基于掌握了Python的前提，断不敢用偏颇的立场去亵渎神器。 我们来看一下美国相关专业人员对两者的对比，只是粗略而不精准的翻译一下。\n 我是一名工程师，之前长期使用Matlab来处理复杂的数学运算都没有遇到什么大的问题，就在几个月前因为岗位需要学习了Python之后，我才意识到Matlab相比Python是多么的糟糕。之前需要我用Matlab花一整天处理的问题用Python只需数小时，Python的表现、流畅度让我惊讶。而且使用Python我可以做之前用Matlab做的任何事情，而且更优秀。因此我非常建议Matlab使用者转向Python。Python编程语言比Matlab更强大，能够联合非常多的外部工具模块，只需一个文件就可以调用非常多的库、函数、类，语法也更加简单，面向对象开发也更加方便，还能非常方便地调用C、C++、Fortran。Python是免费的，而且可以运行在更多平台上面。    ---Stackoverflow某工程师\n经过调查Matlab与Python的宿命之争在2011年就开始了，而且网上Matlab与Python的对比文章、评论非常之多。Matlab官方在2013年就开始拿Matlab和Python进行对比\n官方对比最是致命：MATLAB OR Python中文\n，年代越近，由Matlab全面转向Python的建议就越多，更多人直言Python是未来的编程语言，在Python与Matlab的选择之上，看了非常多的建议，已成一边倒的趋势。 有人列出了\nPython相对于Matlab的8大优势\n,我只粗略翻译一下这8大优势，详情大家可以去查看原文：  \nPython的代码相比于Matlab更简洁，可读性更强； \n和其他编程一样，Python都是从0开始计数，而Matlab不是； \nPython可以更好的支持哈希字典；\n面向对象开发让Python更简单、更优雅； \nPython免费且开源；  \nPython一个文件、模块里可以包含非常多的函数； \nPython支持import声明； \nPython支持更多图像处理的包和工具集  \n在PyCon 2017年的大会上，多位大佬提出科学家应该全面拥抱Python，在2015年开始Python在NASA的地位就开始遥遥领先IDL、Matlab和Fortran。由于这里我们只讨论Python和Matlab在数学上的对比，至于科学家转型Python的优势的细节，大家可以看\nDataCamp的雄文\n。    \n小结\n其实在写这篇文章之前，我就问过一下包括清华在内的学校以及一些数学专业的学生，Matlab和R还是占主流，但是经过一番调查发现在美国Python在数据科学、数学等方面好像渐成压倒性的优势。这也激励我要把用Python学数学的专栏给写下去。"},
{"title": "Python牛逼也没用", "description": "写这篇文章的起始原因是我公众号的读者不少人问我怎么用Python去做数据分析？实际数据分析工作中Python到底有多重要？用Python做数据分析需要哪些知识？ 后来想到在知乎上很多数据分析的话题下", "article": "有点标题党了。\n不过文章也有意义。\n写这篇文章的起始原因是我公众号的读者不少人问我怎么用Python去做数据分析？实际数据分析工作中Python到底有多重要？用Python做数据分析需要哪些知识？\n后来想到在知乎上很多数据分析的话题下，大家把Python位置捧得很高，貌似一个合格的数据分析师必须要要有Python这项技能才可以。今天我想泼一盆冷水。\n为什么这么说呢？因为自打我工作以来真枪实弹的干完之后，我发现在数据分析的工作中很多很多产生巨大价值的分析仅仅是使用Excel或者一些简单的分析工具就能完成的。\n而其实大家在没工作之前其实大多觉得：Python多牛逼啊，学会了R多厉害啊，确实Python和R很厉害，在做一些更深层的分析的时候非常好用，然并卵。\n就拿前段时间刚结束的一个项目来说：这个项目的目的是提高用户的次日留存从40%提升到60%，我们一共做了几件事情。第一步是先采集分析了用户的所有行为数据，与老的App对比；第二步是发现数据中的差异，寻找差异的原因；第三步寻找到原因之后开始研究相应的可解决的方案。\n开始的时候我们做了第一种解决方案某些指标涨了但是留存并没涨，所以我们又继续分析为什么行为数据涨了但是留存没涨，这样一步一步的深究原因找到最终的解决方案。\n整个流程中我要用的技术：SQL、Tableau、Excel，除此之外最重要的一个就是了解业务，向技术、测试、运营了解我们的数据现状。\n这个项目只用了两周的时间我们就把留存从40%的值提升到了65%，是不是感觉很震惊？\n当然这样的项目不止这一个，之前的营收项目同样也是一样，几乎没用到Python或者是R就可以把收入提高、把续费率提高，并不是说不好用，而是说大部分的时候根本用不到。\n最后我想用我前两天在知乎上回答了一个问题来给大家解答：怎么培养数据分析的能力？\n路人甲：怎么培养数据分析的能力？"},
{"title": "选Python还是Java？", "description": "这已经是月经贴了。其中关于Python和Java的问题大抵如下： Python和Java该如何选择 ？ 将来Python(Java)会不会替代Java(Python) ？ 零基础应该选择学习Python还是Java", "article": "抱歉啦，整个9月都在充电和赶进度。好久不冒泡了，今天还有公众号读者给我发了句淡淡的「好久没更新了」来催更，今天先「水」一篇非技术的吧。\n知乎上有很多关于语言选择的问题，这已经是月经贴了。其中关于Python和Java的问题大抵如下：\nPython和Java该如何选择 ？\n将来Python(Java)会不会替代Java(Python) ？\n零基础应该选择学习Python还是Java ？\n做web开发，用Python好还是Java好呢？\n这类问题过一段时间就得来一波，今天我就以这个为切入点和大家唠唠。\n我为啥要说这个话题？\n相信你们最近又看到一波「夸」Python的文章，引用了一些国外的数据，无非说Python现在很火，薪资很高，是未来的趋势balabala...\n不过我们要关注下带节奏的是谁：\nA: 培训机构营销号\n他们说的话可以信？\n那么Python在国内的发展情况如何？\n注：此文发布时间为 2017-09-28\n我最近4-5年是一个靠Python吃饭的一线开发者。在我认知里面，Python既是一个大众化的语言，也是一小搓儿开发者喜欢的语言。怎么说呢？\n每个开发者都应该学学Python这个胶水语言，后端开发者不会Python都不好意思出门和别人打招呼。事实上基本在每个公司都有Python的身影，只不过公司的核心业务、用户产品很少用Python来做。\n国内大一点的、使用Python做基础设施的公司1只手就可以数出来：豆瓣、知乎、美团、饿了么、搜狐（漏掉的欢迎补充）。 公司级别把Python作为核心的公司屈指可数，它更像是一波有「特殊」感情开发者的选择，这波人品味很挑剔，这个有点难描述，参照Pythonic这个词希望你成为的开发者吧。\nPython在国外环境要好得多，但是在国内一直在缓慢的赢得更多人的心，在我的感觉里还有点「病态」发展（这个就不展开了），增速是可预期的，不会出现井喷式的增长。\n职位就是那么多，但是由于那些无良培训机构和不明真相的吃瓜群众的引导和欺骗，再加上浮躁的社会的风气，进来了一大帮水货，企业相应的也就提高的招聘要求，让offer拿的更难了。和前端市场一样，很多人抱怨找不到工作，究其原因，无非是市场冷静客观下来优胜劣汰，能力不达标罢了。据我所知，只要你的能力匹配，Python高级工程师是非常受市场青睐的。\n造成Python市场不好的原因有哪些？\n政治。在我的第一个知乎Live「Python 工程师的入门和进阶」中也提过，我们都知道语言通常不是技术瓶颈，那为什么公司会有很强烈的技术选型因素？这其实是「政治」。BAT出来的人到其他小型公司做高管，他们为了站稳和站在核心位置会选择重构成自己熟悉和喜欢的技术栈，这些小型公司之后发展成细分领域排名很靠前的公司，就这样开枝散叶下去... 另外语言重构大部分是为了KPI和晋升。这些有话语权的人往往不会Python，只熟悉传统的PHP，Java，学习新的语言第一心里没底第二好累呀（有些人就靠现在会的那些东西准备度过下一个20年呢），这就造成一种「恶性」循环，其他语言的市场热度不会降下去，政治正确要比技术正确更重要，Python语言很难在这种环境里突破重围（另外一个角度，有眼光和魄力能把XX转成了Golang的也是凤毛菱角）。那么知乎、饿了么这些公司为什么选择Python？嘿嘿，除了创业早期为了显得逼格高（有时候这是创业营销的一种需要），他们的高管中有些是豆瓣出去的哦，所以你看到同样的现象，豆瓣出去的人做技术决策的结果选了Python。? \n招人难。国内找靠谱的Python工程师实在是太难了。会Python和真的靠它吃饭差别实在太大了，知乎Python话题下大部分充其量算是会用Python写脚本的人在强答罢了。你看我的同事或者我了解到的Python领域里面的开发者基本都是不用知乎也不回答Python问题的。我们知道，Python非常适合创业期完成产品快速试错和迭代，如果一个公司没有优秀的开发者坐镇，我还是不太相信用Python能坚持下去的，太多工程问题真的不是学院派能解决的，很多问题Google/SO是找不到的。那么用人荒造成了想选择Python为公司技术栈的公司望而却步，最后恶性循环大家都不太敢让核心系统用Python了。\n总有刁民拿性能说事儿。性能问题确实是存在的，但事实上绝大部分公司和产品真的不需要担心这点，也有人说Python没有大型网站的顶级的解决方案。其实不然，国内有豆瓣，国外有Instagram、Reddit等等成功的案例，我说了很多遍了，决定网站性能的主要因素是架构，然后是代码水平，最后才是语言。 但是很多对Python一知半解的人会放大这些问题，就被被吓跑了，并且拿着这些槽点去吓别人。\n技术环境不好。PyCON北京场都组织不起来，真的有干货的开发者都不出来活动，万事与Ta无关高高挂起，反观前端氛围真的很好。很多新人想入坑，但是没人带，没方向，没组织，外面尽是坏人，每天看到的都是类似于爬虫这种很low级别的技术文章，这种气氛下，未来真的青黄不接呀。\nPython or Java？\n终于到了正题了。我确实不用Java，不过工作和个人项目中我会用到Python，Golang，Lua，Javascript、CSS，以前做运维的时候还用过Perl和Ruby。很多年前看《程序员修炼之道》，作者建议每年至少学习一门新语言，每季度阅读一本技术书籍。非常有道理，我今年学的是Rust，明年准备学Swift。其实学习语言无非是语法、库和框架这三者，如果掌握正确的方法一个月就能开始用它写点东西了，没什么必要纠结学那个的问题，开发者的基本素养之一就是整个职业生涯里面都得不断学习，除非我不认同某个语言的设计哲学和语法，比如我个人是不喜欢Java的。学的时候可以带着问题来学，比如A语言和B语言相比有什么优劣，设计上为什么不同、它们只能有很么互相借鉴的地方，为什么？等等.. 以后在工作中可以针对不同的项目特点选择合适的语言。我爱Python，但是只在正确的时候用它，而不是一棒子打死无论什么场景都用某语言，要记住，用语言或 者框架来划分技术其实很幼稚。\n插个题外话，可能有的读者会问「那怎么不见你写/回答Golang、Rust等方面的文章/问题呀」？因为不自信，不想误人子弟，也不想强答。「自信」是什么呢？就是使用它的时候不担心有什么解决不了的问题，「天下我有」的感觉，大不了看源码，我C学的不好，但是不影响我带着问题读CPython的源码，不过离贡献C代码就差的很远了，我现在也没想着走这一步，所以对C语言的掌握程度就这样了，精力和天赋有限，就要正确规划，10个浅尝辄止不如1个融会贯通。如果没有经过4-5年的深入和实践，我真的不觉得能在某个领域指手画脚。\n说到选择。如果你没有强烈的对语言的认可或者不认可，单纯为了尽快养家糊口，选Java，因为市场需求量大，应用广泛，成熟案例多。如果你很理解「人生苦短我用Python」这句话，答案就不言而喻了，不过无论是否选择Python吃饭，甚至你不是一个职业的开发者（比如产品经理），我还是再建议你应该也要学学Python。\n之前在知乎看到过大概这样一句话「只会Python找工作很难」，我是认可的。通过观察和了解，我身边的大部分除了Python都能使用其他技术完成工作，比如前端、IOS、安卓等。无论Python还是Java都只是编程语言，工作中还需要具备很多其他的能力，拿Web开发来说（这里不考虑软技能和需求分析、沟通协作等方面的事情），HTTP/TCP、Linux、数据库、Web服务器、第三方库和框架、Web基础（HTML/CSS/JS/ES6) 、消息队列、分布式、虚拟化、RPC、缓存、搜索引擎、微服务、上线流程、趁手的开发工具、调试流程、分布式文件系统、安全等等，随便一想就这么多内容。当然最难的和最有价值的是工作经验。只会编程语言算什么？你有什么竞争力，你给个有点悟性的本科生2个月时间工作起来不会差很多。一定不要放大编程语言对于找工作的重要性。\n另外插个话题。应届生找工作对语言的要求并没有那么重要，反而数据结构、算法、计算机系统、Linux、计算机网络甚至英语这些基础更重要。希望还没有毕业的同学能够抓紧时间多多充电。多看书多时实践多刷题，少上知乎。\n欢迎大家关注我的 微信公众号「Python之美」  \nhttp://\nopen.weixin.qq.com/qr/c\node/?username=python_cn\n- by 知乎同步小助手"},
{"title": "如何看待风变编程的 Python 网课？", "description": "6节课掌握Python爬虫视频 6节课机器学习入门 Python练手项目视频如下： 【Python】2小时利用Python实现一个聊天器 Python从零基础到大牛项目实战", "article": "真的不值得，尤其是在看到我这条回答之后。你就会发现关注我就可以找到的全套课程，他们却收钱！\nPython自学基础知识如下：\nPython入门教程完整版（懂中文就能学会）\npython网络爬虫第一天\npython网络爬虫第二天\n6节课掌握Python爬虫视频\n6节课机器学习入门\n \nPython练手项目视频如下：\n【Python】2小时利用Python实现一个聊天器\nPython从零基础到大牛项目实战：抓取景点评论数量实现旅游景点推荐\n春运回家抢票无忧，Python大牛带你实现12306全自动抢票\nPython之微信开发神器\nPython之爬虫开发帝王\npython之大数据开发奇兵\n \n先打下基础，后用项目练习，只有课程还是不知道怎么学习的，可以看这个全套的学习线路图：\n2019年最新Python学习路线图（内含大纲+视频+工具+书籍+面试）\n \n有关学习Python的文章：\n你们都是怎么学 Python 的？\n要学 Python 需要怎样的基础？\nPython 学习完基础语法知识后，如何进一步提高？\nPython每个阶段课后习题（按照顺序）：\nPython基础知识习题\nPython有关变量、数据类型以及运算符的习题\nPython函数相关的练习题\nPython中判断语句以及循环语句的习题\nPython字符串操作的相关函数习题\nPython中列表、元祖和字典的习题\nPython函数的闭包、装饰器等练习题\nPython中文件操作的相关习题\nPython异常相关的全部笔试题\nPython中模块的所含内容习题\nPython面向对象习题，笔试内容\nPython封装、继承和多态以及类方法等习题\n量化交易文章也分享给你们：\nPython之量化交易学习第一天\nPython量化交易：策略创建运行流程\n应用history_bars实现股票合约历史行情数据获取\n使用Python获取股票合约数据（附源码）\n使用Python获取财务数据，量化交易的源码\nPython量化交易：回测交易接口\n量化交易：了解投资组合的市场价值和资金价值\nPython量化交易：策略评价指标\nPython量化交易：实现第一个股票策略\nPython量化交易：多因子策略与理论介绍\n \n以上全部学完了，发现还不够那么开始看书吧：\n操作系统和计算机组成原理：《深入理解计算机系统》\n算法和数据结构：《算法导论》\n数据库：《Mysql菜鸟入门系列》进阶的话--->《高性能Mysql》\n语言本身：《Python编程：从入门到实践》《Python核心编程》\n还有机器学习和金融等方面的书：\n这些是 Python 官方推荐的最好书籍（推荐）"},
{"title": "Python 编码为什么那么蛋疼？", "description": "像之前一样的修修补补已不能让Python变的更好，于是来了个大变革，Python3横空出世，不兼容python2,python3比python2做了非常多的改进，其中一个就是终于把字符串变成了unicode", "article": "在备编码相关的课件时，在知乎上看到本文得票最高的大神关于Python编码的回答\n大神的这段话说的太对了，搞Python不把编码彻底搞明白，总有一天它会猝不及防坑你一把。\n不过感觉这位大视的答案并没把编码问题真正写明白，所以在下再补充一些。 \n折腾编码问题，有很多次，我以为自已明白了，最终发现，那只不过是自圆其说而已，这一次，终于100%确定，动笔即不再改！\n看这篇文章前，你应该已经知道了为什么有编码，以及编码的种类情况\nASCII 占1个字节，只支持英文\nGB2312 占2个字节，支持6700+汉字\nGBK GB2312的升级版，支持21000+汉字\nShift-JIS 日本字符\nks_c_5601-1987 韩国编码\nTIS-620 泰国编码\n由于每个国家都有自己的字符，所以其对应关系也涵盖了自己国家的字符，但是以上编码都存在局限性，即：仅涵盖本国字符，无其他国家字符的对应关系。应运而生出现了万国码，他涵盖了全球所有的文字和二进制的对应关系，\nUnicode 2-4字节 已经收录136690个字符，并还在一直不断扩张中...\nUnicode 起到了2个作用：\n直接支持全球所有语言，每个国家都可以不用再使用自己之前的旧编码了，用unicode就可以了。(就跟英语是全球统一语言一样)\nunicode包含了跟全球所有国家编码的映射关系，为什么呢？后面再讲\nUnicode解决了字符和二进制的对应关系，但是使用unicode表示一个字符，太浪费空间。例如：利用unicode表示“Python”需要12个字节才能表示，比原来ASCII表示增加了1倍。\n由于计算机的内存比较大，并且字符串在内容中表示时也不会特别大，所以内容可以使用unicode来处理，但是存储和网络传输时一般数据都会非常多，那么增加1倍将是无法容忍的！！！\n为了解决存储和网络传输的问题，出现了Unicode Transformation Format，学术名UTF，即：对unicode中的进行转换，以便于在存储和网络传输时可以节省空间!\nUTF-8： 使用1、2、3、4个字节表示所有字符；优先使用1个字符、无法满足则使增加一个字节，最多4个字节。英文占1个字节、欧洲语系占2个、东亚占3个，其它及特殊字符占4个\nUTF-16： 使用2、4个字节表示所有字符；优先使用2个字节，否则使用4个字节表示。\nUTF-32： 使用4个字节表示所有字符；\n总结：\nUTF 是为unicode编码 设计 的一种 在存储 和传输时节省空间的编码方案。\n字符在硬盘上的存储 \n无论以什么编码在内存里显示字符，存到硬盘上都是2进制。\nascii编码\n(\n美国\n)\n：\n\n    \nl\n   \n0b1101100\n\n    \no\n   \n0b1101111\n\n    \nv\n   \n0b1110110\n\n    \ne\n   \n0b1100101\n\n\nGBK编码\n(\n中国\n)\n：\n\n    \n老\n   \n0b11000000\n \n0b11001111\n\n    \n男\n   \n0b11000100\n \n0b11010000\n\n    \n孩\n   \n0b10111010\n \n0b10100010\n\n\n\nShift_JIS编码\n(\n日本\n)\n：\n\n    \n私\n   \n0b10001110\n \n0b10000100\n\n    \nは\n   \n0b10000010\n \n0b11001101\n\n\n\nks_c_5601\n-\n1987\n编码\n(\n韩国\n)\n：\n\n    \n나\n   \n0b10110011\n \n0b10101010\n\n    \n는\n   \n0b10110100\n \n0b11000010\n\n\n\nTIS\n-\n620\n编码\n(\n泰国\n)\n：\n\n    \nฉัน\n  \n0b10101001\n \n0b11010001\n \n0b10111001\n\n\n...\n\n\n要注意的是\n，\n存到硬盘上时是以何种编码存的\n，\n再从硬盘上读出来时\n，\n就必须以何种编码读\n，\n要不然就乱了\n。。\n编码的转换 \n虽然国际语言是英语 ，但大家在自己的国家依然说自已的语言，不过出了国， 你就得会英语\n编码也一样，虽然有了unicode and utf-8 ， 但是由于历史问题，各个国家依然在大量使用自己的编码，比如中国的windows,默认编码依然是gbk,而不是utf-8\n基于此，如果中国的软件出口到美国，在美国人的电脑上就会显示乱码，因为他们没有gbk编码。\n若想让中国的软件可以正常的在 美国人的电脑上显示，只有以下2条路可走：\n让美国人的电脑上都装上gbk编码\n把你的软件编码以utf-8编码\n第1种方法几乎不可能实现，第2种方法比较简单。 但是也只能是针对新开发的软件。 如果你之前开发的软件就是以gbk编码的，上百万行代码可能已经写出去了，重新编码成utf-8格式也会费很大力气。\nso , 针对已经用gbk开发完毕的项目，以上2种方案都不能轻松的让项目在美国人电脑上正常显示，难道没有别的办法了么？\n有， 还记得我们讲unicode其中一个功能是其包含了跟全球所有国家编码的映射关系，意思就是，你写的是gbk的“路飞学城”,但是unicode能自动知道它在unicode中的“路飞学城”的编码是什么，如果这样的话，那是不是意味着，无论你以什么编码存储的数据 ，只要你的软件在把数据从硬盘读到内存里，转成unicode来显示，就可以了。\n由于所有的系统、编程语言都默认支持unicode，那你的gbk软件放到美国电脑 上，加载到内存里，变成了unicode,中文就可以正常展示啦。\n这个表你自己也可以下载下来 \nunicode与gbk的映射表 \nhttp://www.\nunicode.org/charts/\n \nPython3的执行过程\n在看实际代码的例子前，我们来聊聊，python3 执行代码的过程\n解释器找到代码文件，把代码字符串按文件头定义的编码加载到内存，转成unicode\n把代码字符串按照语法规则进行解释，\n所有的变量字符都会以unicode编码声明\n编码转换过程\n实际代码演示，在py3上 把你的代码以utf-8编写， 保存，然后在windows上执行，\ns = '路飞学城'\nprint(s)\nso ,一切都很美好，到这里，我们关于编码的学习按说就可以结束了。\n但是，如生活一样，美好的表面下，总是隐藏着不尽如人意，上面的utf-8编码之所以能在windows gbk的终端下显示正常，是因为到了内存里python解释器把utf-8转成了unicode , 但是这只是python3, 并不是所有的编程语言在内存里默认编码都是unicode,比如 万恶的python2 就不是， 它的默认编码是ASCII，想写中文，就必须声明文件头的coding为gbk or utf-8, 声明之后，python2解释器仅以文件头声明的编码去解释你的代码，加载到内存后，并不会主动帮你转为unicode,也就是说，你的文件编码是utf-8,加载到内存里，你的变量字符串就也是utf-8, 这意味着什么你知道么？。。。意味着，你以utf-8编码的文件，在windows是乱码。 \n乱是正常的，不乱才不正常，因为只有2种情况 ，你的windows上显示才不会乱\n字符串以GBK格式显示\n字符串是unicode编码\n既然Python2并不会自动的把文件编码转为unicode存在内存里， 那就只能使出最后一招了，你自己人肉转。Py3 自动把文件编码转为unicode必定是调用了什么方法，这个方法就是，decode(解码) 和encode(编码)\nUTF-8 --> decode 解码 --> Unicode\nUnicode --> encode 编码 --> GBK / UTF-8 ..\ndecode示例\nencode 示例\n记住下图规则\n如何验证编码转对了呢？\n查看数据类型，python 2 里有专门的unicode 类型\n查看unicode编码映射表\n　　unicode字符是有专门的unicode类型来判断的，但是utf-8,gbk编码的字符都是str,你如果分辨出来的当前的字符串数据是何种编码的呢？ 有人说可以通过字节长度判断，因为utf-8一个中文占3字节，gbk一个占2字节\n靠上面字节个数，虽然也能大体判断是什么类型，但总觉得不是很专业。\n怎么才能精确的验证一个字符的编码呢，就是拿这些16进制的数跟编码表里去匹配。\n“路飞学城”的unicode编码的映射位置是\tu'\\u8def\\u98de\\u5b66\\u57ce' ，‘\\u8def’ 就是‘路’，到表里搜一下。\n“路飞学城”对应的GBK编码是'\\xc2\\xb7\\xb7\\xc9\\xd1\\xa7\\xb3\\xc7' ，2个字节一个中文，\"路\" 的二进制 \"\\xc2\\xb7\"是4个16进制，正好2字节，拿它到unicode映射表里对一下， 发现是G0-4237，并不是\\xc2\\xb7呀。。。擦。演砸了吧。。\n再查下“飞” \\u98de ，对应的是G0-3749， 跟\\xb7\\xc9也对不上。\n虽然对不上， 但好\\xc2\\xb7 和G0-4237中的第2位的2和第4位的7对上了，“飞”字也是一样，莫非巧合？ \n把他们都转成2进制显示试试 \n路\nC               2\n8   4   2   1   8   4   2   1\n1   1   0   0   0   0   1   0\n\nB               7\n8   4   2   1   8   4   2   1\n1   0   1   1   0   1   1   1\n\n\n飞\nB               7\n8   4   2   1   8   4   2   1\n1   0   1   1   0   1   1   1\n\nC               9\n8   4   2   1   8   4   2   1\n1   1   0   0   1   0   0   1\n这个“路”还是跟G0-4237对不上呀，没错， 但如果你把路\\xc2\\xb7的每个二进制字节的左边第一个bit变成0试试呢， 我擦，加起来就真的是4237了呀。。难道又是巧合？？？ 　\n必然不是，是因为，GBK的编码表示形式决定的。。因为GBK编码在设计初期就考虑到了要兼容ASCII,即如果是英文，就用一个字节表示，2个字节就是中文，但如何区别连在一起的2个字节是代表2个英文字母，还是一个中文汉字呢？ 中国人如此聪明，决定，2个字节连在一起，如果每个字节的第1位(也就是相当于128的那个2进制位)如果是1，就代表这是个中文，这个首位是128的字节被称为高字节。 也就是2个高字节连在一起，必然就是一个中文。 你怎么如此笃定？因为0-127已经表示了英文的绝大部分字符，128-255是ASCII的扩展表，表示的都是极特殊的字符，一般没什么用。所以中国人就直接拿来用了。 \n问：那为什么上面 \"\\xc2\\xb7\"的2进制要把128所在的位去掉才能与unicode编码表里的G0-4237匹配上呢？\n这只能说是unicode在映射表的表达上直接忽略了高字节，但真正映射的时候 ，肯定还是需要用高字节的哈。\nPython bytes类型\n在python 2 上写字符串\n>>> s = \"路飞\"\n>>> print s\n路飞\n>>> s\n'\\xe8\\xb7\\xaf\\xe9\\xa3\\x9e'\n虽说打印的是路飞，但直接调用变量s，看到的却是一个个的16进制表示的二进制字节，我们怎么称呼这样的数据呢？直接叫二进制么？也可以， 但相比于010101，这个数据串在表示形式上又把2进制转成了16进制来表示，这是为什么呢？ 哈，为的就是让人们看起来更可读。我们称之为bytes类型，即字节类型， 它把8个二进制一组称为一个byte,用16进制来表示。 　\n说这个有什么意思呢？\n想告诉你一个事实， 就是，python2的字符串其实更应该称为字节串。 通过存储方式就能看出来， 但python2里还有一个类型是bytes呀，难道又叫bytes又叫字符串？ 嗯 ，是的，在python2里，bytes == str ， 其实就是一回事　\n除此之外呢， python2里还有个单独的类型是unicode , 把字符串解码后，就会变成unicode\n>>>\n \ns\n\n\n'\n\\xe8\\xb7\\xaf\\xe9\\xa3\\x9e\n'\n \n#utf-8\n\n\n>>>\n \ns\n.\ndecode\n(\n'utf-8'\n)\n\n\nu\n'\n\\u8def\\u98de\n'\n \n#unicode 在unicode编码表里对应的位置\n\n\n>>>\n \nprint\n(\ns\n.\ndecode\n(\n'utf-8'\n))\n\n\n路飞\n \n#unicode 格式的字符\n由于Python创始人在开发初期认知的局限性，其并未预料到python能发展成一个全球流行的语言，导致其开发初期并没有把支持全球各国语言当做重要的事情来做，所以就轻佻的把ASCII当做了默认编码。 当后来大家对支持汉字、日文、法语等语言的呼声越来越高时，Python于是准备引入unicode,但若直接把默认编码改成unicode的话是不现实的， 因为很多软件就是基于之前的默认编码ASCII开发的，编码一换，那些软件的编码就都乱了。所以Python 2 就直接 搞了一个新的字符类型，就叫unicode类型，比如你想让你的中文在全球所有电脑上正常显示，在内存里就得把字符串存成unicode类型\n>>> s = \"路飞\"\n>>> s\n'\\xe8\\xb7\\xaf\\xe9\\xa3\\x9e'\n>>> s2 = s.decode(\"utf-8\")\n>>> s2\nu'\\u8def\\u98de'\n>>> type(s2)\n<type 'unicode'>\n\n时间来到2008年，python发展已近20年，创始人龟叔越来越觉得python里的好多东西已发展的不像他的初衷那样，开始变得臃肿、不简洁、且有些设计让人摸不到头脑，比如unicode 与str类型，str 与bytes类型的关系，这给很多python程序员造成了困扰。\n龟叔再也忍不了，像之前一样的修修补补已不能让Python变的更好，于是来了个大变革，Python3横空出世，不兼容python2,python3比python2做了非常多的改进，其中一个就是终于把字符串变成了unicode,文件默认编码变成了utf-8,这意味着，只要用python3,无论你的程序是以哪种编码开发的，都可以在全球各国电脑上正常显示，真是太棒啦！\nPY3 除了把字符串的编码改成了unicode, 还把str 和bytes 做了明确区分， str 就是unicode格式的字符， bytes就是单纯二进制啦。\n最后一个问题，为什么在py3里，把unicode编码后，字符串就变成了bytes格式？ 你直接给我直接打印成gbk的字符展示不好么？我想其实py3的设计真是煞费苦心，就是想通过这样的方式明确的告诉你，想在py3里看字符，必须得是unicode编码，其它编码一律按bytes格式展示。 \n好吧，就说这么多吧。 \n最后再提示一下，Python只要出现各种编码问题，无非是哪里的编码设置出错了\n常见编码错误的原因有：\nPython解释器的默认编码\nPython源文件文件编码\nTerminal使用的编码\n操作系统的语言设置\n掌握了编码之前的关系后，挨个排错就好啦　　\n看这个文章如果有不明白的地方的话，可以看这个视频，是配合这个文章讲的，100%搞明白。\nPython开发21天入门必备 - 网易云课堂"},
{"title": "三天搞定Python", "description": "所有内容都在下边这三个链接里： 三天搞定Python基础功，Day 1基础篇 三天搞定Python基础功，Day 1基础篇 三天搞定Python基本功，Day 2科学计算篇", "article": "知乎的各位朋友不好意思，前段时间因为给本科生带了一个Python的培训课程，每天弄得很累，所以没时间前来更新。也很感谢和欢迎猫兄\n@黑猫Q形态\n在我的专栏发文。\n我在学校带的Python课程主要是针对低年级的本科生，他们没有任何编程基础，很多人也没有学习很复杂的统计内容。因此我为他们量身订做了相应的课件，保持我的老风格，尽量以轻松简单的模式，把尽可能多的内容教给他们。\n我这里把我相应的课件以链接的形式和大家分享一下。因为在国外知乎的服务器经常很难登录，我尝试过在知乎上传课件图片，但最后都搞不好，因此只能给大家我微信公众号里的链接了。在这里跟大家说个抱歉。\n我的课件内容主要总共三份，这些课件我参考了很多的资料，有网上资源，也有一些教材，然后自己整理出来的，针对本科生和零基础的人设计的。所以高手们可以忽略的自然。不说多了，所有内容都在下边这三个链接里：\n三天搞定Python基础功，Day 1基础篇\n三天搞定Python基础功，Day 1基础篇\n三天搞定Python基本功，Day 2科学计算篇\n三天搞定Python基本功，Day 2科学计算篇\n三天搞定Python基础功，Day 3统计入门篇\n三天搞定Python基础功，Day 3统计入门篇\n希望能对没有接触过编程，或者没有接触过Python的朋友有个参考。"},
{"title": "学好深度学习，Python 得达到什么程度？", "description": "第一步：学Python3，不要学Python2了，到2020年Python2就不再被维护了。下面是我觉得最好的Python3自学书籍下载链接。Python3程序开发指南", "article": "我觉得真心不难，学习路线图应该是这样的：\n第一步：学Python3，不要学Python2了，到2020年Python2就不再被维护了。下面是我觉得最好的Python3自学书籍下载链接。\nPython3程序开发指南.第二版(带书签).pdf\n第二步：学习深度学习简单的例子，如MNIST, CIFAR, PTB, Word2Vec等等。只要学习了这里面的基础任务，基本可以说是入门了。我建议结合网上的深度学习教材来看代码。\n深度学习: 基础例子\n第三步：学习更加复杂的深度学习例子，并尝试重现一篇自己喜欢的paper。下面的链接中整理了计算机视觉、自然语言处理、生成对抗网络等中大型应用的代码链接。\n深度学习: 例子大全\n第四步：对强化学习感兴趣的同学，可以看看这套代码库，我们用简单且统一的代码模版，实现了大部分的强化学习算法，并不断地添加最新算法。我们最近在写一本深度强化学习的书，也是用Python作为例子的。\n深度\"强化\"学习:实现全家桶\n开源项目组和学校最近在招人，对AI感兴趣的同学可以看看我的主页：\nHao Dong Homepage\n别光收藏呀，也点赞一下呀 ～～\n其他回答：\nMaix-EMC：AI科学家的硬件梦 | 嵌入式工程师的AI梦\n在DeepMind或OpenAI工作是什么体验？\nAI领域的灌水之风如何破局？"},
{"title": "Python与Excel交互——Xlwings", "description": "(公众号里排版会舒服很多） Xlwings是我认为的Python最强大的处理Excel的库，主要原因如下： 1 Windows，Mac都能用 （Excel，WPS也都能用）", "article": "(公众号里排版会舒服很多）\nXlwings是我认为的Python\n最强大\n的处理Excel的库，主要原因如下：\n1 Windows，Mac都能用 （Excel，WPS也都能用）\n2 功能齐全，支持Excel的新建、打开、修改、保存（pandas和xlsxwriter去不能全做到）\n3 语法简单（用过一次后我就记住了）\n4 可以调用VBA，有丰富的API\nTalk is cheap, show you the code.\n先说基本操作：\n引入库\nimport\n \nxlwings\n \nas\n \nxw\n \n打开Excel程序，默认设置：程序可见，只打开不新建工作薄\napp\n \n=\n \nxw\n.\nApp\n(\nvisible\n=\nTrue\n,\nadd_book\n=\nFalse\n)\n\n\n#新建工作簿 (如果不接下一条代码的话，Excel只会一闪而过，卖个萌就走了）\n\n\nwb\n \n=\n \napp\n.\nbooks\n.\nadd\n()\n打开已有工作簿（支持绝对路径和相对路径）\nwb = app.books.open('example.xlsx')\n#练习的时候建议直接用下面这条\n#wb = xw.Book('example.xlsx')\n#这样的话就不会频繁打开新的Excel\n保存工作簿\nwb.save('example.xlsx')\n退出工作簿（可省略）\nwb.close()\n退出Excel\napp.quit()\n引用Excel工作表，单元格\n引用工作表\nsht = wb.sheets[0]\n#sht = wb.sheets[第一个sheet名]\n引用单元格\nrng = sht.range('a1')\n#rng = sht['a1']\n#rng = sht[0,0] 第一行的第一列即a1,相当于pandas的切片\n引用区域\nrng = sht.range('a1:a5')\n#rng = sht['a1:a5']\n#rng = sht[:5,0]\n重头戏：写入数据\n(xlwings多个单元格的写入大多是以表格形式)\n选择起始单元格A1,写入字符串‘Hello’\nsht.range('a1').value = 'Hello'\n默认按行插入：A1:D1分别写入1,2,3,4\nsht.range('a1').value = [1,2,3,4]\n等同于\nsht.range('a1:d1').value = [1,2,3,4]\n按列插入： A2:A5分别写入5,6,7,8\n你可能会想\n*sht.range('a2:a5').value = [5,6,7,8]\n但是你会发现xlwings还是会按行处理的，上面一行等同于\n*sht.range('a2').value = [5,6,7,8]\n正确语法:\nsht.range('a2').options(transpose=True).value = [5,6,7,8]\n既然默认的是按行写入，我们就把它倒过来嘛（transpose），单词要打对，如果你打错单词，它不会报错，而会按默认的行来写入（别问我怎么知道的）\n我们输入信息的时候往往不只是写入一行或一列，\n多行输入就要用二维列表了：\nsht.range('a6').expand('table').value = [['a','b','c'],['d','e','f'],['g','h','i']]\n说完了写入就该讲读取了，记住了写入，读取就简单了\n读取A1:D4（直接填入单元格范围就行了）\nprint(sht.range('a1:d4').value)\n返回的值是列表形式，多行多列为二维列表，但有一点要注意，返回的数值默认是浮点数\na = sht.range('a1:d1').value\nprint(a)\nfor i in a:\n  print(i)\n  print(type(i))\n读取excel的第一列怎么做？\n*a = sht.range('a:a').value\nprint(len(a))\n你将会得到一个1048576个元素的列表，也就是空值也包含进去了，所以这种方法不行\n思路：先计算单元格的行数(前提是连续的单元格)\nrng = sht.range('a1').expand('table')\nnrows = rng.rows.count\n接着就可以按准确范围读取了\na\n \n=\n \nsht\n.\nrange\n(\nf\n'a1:a\n{nrows}\n'\n)\n.\nvalue\n同理选取一行的数据也一样\nncols\n \n=\n \nrng\n.\ncolumns\n.\ncount\n\n\n#用切片\n\n\nfst_col\n \n=\n \nsht\n[\n0\n,:\nncols\n]\n.\nvalue\n好了基本操作就介绍到这里了，下次搞个实战，把xlwings好好用起来\n（实战已完成，链接在下面）\n呆呆：Python与Excel交互——Xlwings实战\n点个赞支持下呗！"},
{"title": "Python 有哪些黑魔法？", "description": "其实即便是不借助神经网络，我们用 Python 和一些 Python 库也能实现换脸，只不过替换的是静态图像中的人脸，但凭此也足以显示出 Python 的“神秘力量”。 我们下面就传授一下这门", "article": "还记得吗？去年冬天，在国外 AI 圈有个事情闹得很火：知名论坛 Reddit 上忽然出现一个叫 deepfakes 的大神，借助神经网络实现了\n人脸替换\n，让一些好莱坞女星“出演”了 AV。\n后来根据这个项目又衍生了一个叫 FakeAPP 的桌面应用，可以让\n尼古拉斯·凯奇\n这样的明星随心所欲的“出演”任何电影，当然换成任何人的脸部都可以。我们曾详细分享过这些项目：\n景略集智：大意了！居然有人用AI技术制作假AV！\n景略集智：AI已经决定了，ta就是未来每一届奥斯卡最佳男主。\n怎么样，是不是被这种换脸的效果惊到了？其实即便是不借助神经网络，我们用 Python 和一些 Python 库也能实现换脸，只不过替换的是静态图像中的人脸，但凭此也足以显示出 Python 的“神秘力量”。\n我们下面就传授一下这门 Python“换脸”大法。\n在本文，我们会介绍如何通过一段简短的 Python 脚本（200行）将一张图片中面部特征自动替换为另外一张图片中的面部特征。也就是实现下面这样的效果：\n具体过程分为四个步骤：\n检测面部标志；\n旋转、缩放和平移图 2 以适应图 1；\n调整图 2 的白平衡以匹配图 1；\n将图 2 的特征融合到图 1 中；\n本脚本的完整代码地址见文末。\n使用dlib提取面部标志\n本脚本使用 dlib 的 Python bindings 来提取面部标志：\ndlib 实现了 Vahid Kazemi 和 Josephine Sullivan 所著论文《One Millisecond Face Alignment with an Ensemble of Regression Tree》一文中描述的算法。算法本身非常复杂，但是通过 dlib的接口实现它非常简单：\nPREDICTOR_PATH\n \n=\n \n\"/home/matt/dlib-18.16/shape_predictor_68_face_landmarks.dat\"\n\n\n\ndetector\n \n=\n \ndlib\n.\nget_frontal_face_detector\n()\n\n\npredictor\n \n=\n \ndlib\n.\nshape_predictor\n(\nPREDICTOR_PATH\n)\n\n\n\ndef\n \nget_landmarks\n(\nim\n):\n\n   \nrects\n \n=\n \ndetector\n(\nim\n,\n \n1\n)\n\n\n   \nif\n \nlen\n(\nrects\n)\n \n>\n \n1\n:\n\n       \nraise\n \nTooManyFaces\n\n   \nif\n \nlen\n(\nrects\n)\n \n==\n \n0\n:\n\n       \nraise\n \nNoFaces\n\n\n\nreturn\n \nnumpy\n.\nmatrix\n([[\np\n.\nx\n,\n \np\n.\ny\n]\n \nfor\n \np\n \nin\n \npredictor\n(\nim\n,\n \nrects\n[\n0\n])\n.\nparts\n()])\nget_landmarks() 函数 以 numpy 数组的形式接收图像，并返回一个 68x2 的元素矩阵。矩阵的每一行与输入图像中特定特征点的 x，y 坐标相对应。\n特征提取器（predictor）需要一个大概的边界框作为算法的输入。这将由传统的面部检测器（detector）提供。该面部检测器会返回一个矩形列表，其中每一个矩形与图像中的一张人脸相对应。\n生成 predictor 需要预先训练好的模型。该模型可在 dlib sourceforge repository 下载。\nhttps://\nsourceforge.net/project\ns/dclib/files/dlib/v18.10/shape_predictor_68_face_landmarks.dat.bz2/download\n用普氏分析法（Procrustes Analysis）实现人脸对齐\n现在我们已经有两个面部标志矩阵，其中的每一行都含有某个面部特征的坐标（如第 30 行给出了鼻尖的坐标）。我们现在只要弄明白如何旋转、平移和缩放第一个向量的所有点，使其尽可能匹配第二个向量中的点。同理，同样的变换可用于将第二张图叠加在第一张图上。\n为使其更加数学化，我们设 T，s 和 R，并求如下等式最小值：\n其中，R 是一个 2x2 的正交矩阵，s 是一个标量，T 是一个二维向量，pi 和 qi 是之前计算出的面部标志矩阵行标和列标。\n事实证明，这类问题用常规普氏分析法（Ordinary Procrustes Analysis）可以解决：\ndef\n \ntransformation_from_points\n(\npoints1\n,\n \npoints2\n):\n\n   \npoints1\n \n=\n \npoints1\n.\nastype\n(\nnumpy\n.\nfloat64\n)\n\n   \npoints2\n \n=\n \npoints2\n.\nastype\n(\nnumpy\n.\nfloat64\n)\n\n\n   \nc1\n \n=\n \nnumpy\n.\nmean\n(\npoints1\n,\n \naxis\n=\n0\n)\n\n   \nc2\n \n=\n \nnumpy\n.\nmean\n(\npoints2\n,\n \naxis\n=\n0\n)\n\n   \npoints1\n \n-=\n \nc1\n\n   \npoints2\n \n-=\n \nc2\n\n\n   \ns1\n \n=\n \nnumpy\n.\nstd\n(\npoints1\n)\n\n   \ns2\n \n=\n \nnumpy\n.\nstd\n(\npoints2\n)\n\n   \npoints1\n \n/=\n \ns1\n\n   \npoints2\n \n/=\n \ns2\n\n\n   \nU\n,\n \nS\n,\n \nVt\n \n=\n \nnumpy\n.\nlinalg\n.\nsvd\n(\npoints1\n.\nT\n \n*\n \npoints2\n)\n\n   \nR\n \n=\n \n(\nU\n \n*\n \nVt\n)\n.\nT\n\n\n   \nreturn\n \nnumpy\n.\nvstack\n([\nnumpy\n.\nhstack\n(((\ns2\n \n/\n \ns1\n)\n \n*\n \nR\n,\n\n                                      \nc2\n.\nT\n \n-\n \n(\ns2\n \n/\n \ns1\n)\n \n*\n \nR\n \n*\n \nc1\n.\nT\n)),\n\n                        \nnumpy\n.\nmatrix\n([\n0.\n,\n \n0.\n,\n \n1.\n])])\n我们逐步分析一下代码：\n将输入矩阵转换为浮点型。这也是后续步骤的必要条件。\n将每一个点集减去它的矩心。一旦为这两个新的点集找到了一个最佳的缩放和旋转方法，这两个矩心c1和c2就可以用来找到完整的解决方案。\n同样，将每一个点集除以它的标准偏差。这消除了缩放偏差。\n使用奇异值分解（singular value decomposition）计算旋转部分。请参阅维基百科有关Orthogonal Procrustes Problem的文章，以了解它的具体工作原理。\n将整个变换过程以仿射变换矩阵形式返回。\n之后，返回结果可以插入 OpenCV 的 cv2.warpAffine 函数，将第二个图片映射到第一个图片上：\ndef\n \nwarp_im\n(\nim\n,\n \nM\n,\n \ndshape\n):\n\n   \noutput_im\n \n=\n \nnumpy\n.\nzeros\n(\ndshape\n,\n \ndtype\n=\nim\n.\ndtype\n)\n\n   \ncv2\n.\nwarpAffine\n(\nim\n,\n\n                  \nM\n[:\n2\n],\n\n                  \n(\ndshape\n[\n1\n],\n \ndshape\n[\n0\n]),\n\n                  \ndst\n=\noutput_im\n,\n\n                  \nborderMode\n=\ncv2\n.\nBORDER_TRANSPARENT\n,\n\n                  \nflags\n=\ncv2\n.\nWARP_INVERSE_MAP\n)\n\n\nreturn\n \noutput_im\n校正第二张图片的颜色\n如果此时我们试图直接叠加面部特征，很快会发现一个问题：\n这样肯定是没法儿看的...\n两幅图像之间不同的\n肤色\n和\n光线\n造成了覆盖区域边缘的不连续。所以我们尝试修正它：\nCOLOUR_CORRECT_BLUR_FRAC\n \n=\n \n0.6\n\n\nLEFT_EYE_POINTS\n \n=\n \nlist\n(\nrange\n(\n42\n,\n \n48\n))\n\n\nRIGHT_EYE_POINTS\n \n=\n \nlist\n(\nrange\n(\n36\n,\n \n42\n))\n\n\n\ndef\n \ncorrect_colours\n(\nim1\n,\n \nim2\n,\n \nlandmarks1\n):\n\n   \nblur_amount\n \n=\n \nCOLOUR_CORRECT_BLUR_FRAC\n \n*\n \nnumpy\n.\nlinalg\n.\nnorm\n(\n\n                             \nnumpy\n.\nmean\n(\nlandmarks1\n[\nLEFT_EYE_POINTS\n],\n \naxis\n=\n0\n)\n \n-\n\n                             \nnumpy\n.\nmean\n(\nlandmarks1\n[\nRIGHT_EYE_POINTS\n],\n \naxis\n=\n0\n))\n\n   \nblur_amount\n \n=\n \nint\n(\nblur_amount\n)\n\n   \nif\n \nblur_amount\n \n%\n \n2\n \n==\n \n0\n:\n\n       \nblur_amount\n \n+=\n \n1\n\n   \nim1_blur\n \n=\n \ncv2\n.\nGaussianBlur\n(\nim1\n,\n \n(\nblur_amount\n,\n \nblur_amount\n),\n \n0\n)\n\n   \nim2_blur\n \n=\n \ncv2\n.\nGaussianBlur\n(\nim2\n,\n \n(\nblur_amount\n,\n \nblur_amount\n),\n \n0\n)\n\n\n   \n# Avoid divide-by-zero errors.\n\n   \nim2_blur\n \n+=\n \n128\n \n*\n \n(\nim2_blur\n \n<=\n \n1.0\n)\n\n\n   \nreturn\n \n(\nim2\n.\nastype\n(\nnumpy\n.\nfloat64\n)\n \n*\n \nim1_blur\n.\nastype\n(\nnumpy\n.\nfloat64\n)\n \n/\n\n                                               \nim2_blur\n.\nastype\n(\nnumpy\n.\nfloat64\n))\n现在效果怎么样？我们瞅瞅：\n这不是更奇怪了么...\n此函数试图改变图 2 的颜色来匹配图 1，也就是用 im2 除以 im2 的高斯模糊，然后乘以 im1 的高斯模糊。在这里我们使用了颜色平衡（ RGB scaling colour-correction），但不是直接使用全图的常数比例因子，而是采用每个像素的局部比例因子。\n通过这种方法也只能在某种程度上修正两图间的光线差异。比如说，如果图 1 的光线来自某一边，但图 2 的光线非常均匀，校色后图 2 也会出现有一边暗一些的情况。\n也就是说，\n这是一个相当粗糙的解决方案\n，而且关键在于大小适当的高斯内核。如果太小，图 2 中会出现图 1 的面部特征。如果太大，内核会跑到被像素覆盖的面部区域之外，并变色。这里的内核大小为瞳距的 0.6 倍。\n将图 2 的特征融合到图 1 中\n用一个蒙版（mask）来选择图 2 和图 1 应被最终显示的部分：\n值为 1 (白色)的地方为图 2 应显示的区域，值为 0 (黑色)的地方为图 1 应显示的区域。值在 0 和 1 之间的地方为图 1 图 2 的混合区域。\n这是生成上述内容的代码：\nLEFT_EYE_POINTS\n \n=\n \nlist\n(\nrange\n(\n42\n,\n \n48\n))\n\n\nRIGHT_EYE_POINTS\n \n=\n \nlist\n(\nrange\n(\n36\n,\n \n42\n))\n\n\nLEFT_BROW_POINTS\n \n=\n \nlist\n(\nrange\n(\n22\n,\n \n27\n))\n\n\nRIGHT_BROW_POINTS\n \n=\n \nlist\n(\nrange\n(\n17\n,\n \n22\n))\n\n\nNOSE_POINTS\n \n=\n \nlist\n(\nrange\n(\n27\n,\n \n35\n))\n\n\nMOUTH_POINTS\n \n=\n \nlist\n(\nrange\n(\n48\n,\n \n61\n))\n\n\nOVERLAY_POINTS\n \n=\n \n[\n\n   \nLEFT_EYE_POINTS\n \n+\n \nRIGHT_EYE_POINTS\n \n+\n \nLEFT_BROW_POINTS\n \n+\n \nRIGHT_BROW_POINTS\n,\n\n   \nNOSE_POINTS\n \n+\n \nMOUTH_POINTS\n,\n\n\n]\n\n\nFEATHER_AMOUNT\n \n=\n \n11\n\n\n\ndef\n \ndraw_convex_hull\n(\nim\n,\n \npoints\n,\n \ncolor\n):\n\n   \npoints\n \n=\n \ncv2\n.\nconvexHull\n(\npoints\n)\n\n   \ncv2\n.\nfillConvexPoly\n(\nim\n,\n \npoints\n,\n \ncolor\n=\ncolor\n)\n\n\n\ndef\n \nget_face_mask\n(\nim\n,\n \nlandmarks\n):\n\n   \nim\n \n=\n \nnumpy\n.\nzeros\n(\nim\n.\nshape\n[:\n2\n],\n \ndtype\n=\nnumpy\n.\nfloat64\n)\n\n\n   \nfor\n \ngroup\n \nin\n \nOVERLAY_POINTS\n:\n\n       \ndraw_convex_hull\n(\nim\n,\n\n                        \nlandmarks\n[\ngroup\n],\n\n                        \ncolor\n=\n1\n)\n\n\n   \nim\n \n=\n \nnumpy\n.\narray\n([\nim\n,\n \nim\n,\n \nim\n])\n.\ntranspose\n((\n1\n,\n \n2\n,\n \n0\n))\n\n\n   \nim\n \n=\n \n(\ncv2\n.\nGaussianBlur\n(\nim\n,\n \n(\nFEATHER_AMOUNT\n,\n \nFEATHER_AMOUNT\n),\n \n0\n)\n \n>\n \n0\n)\n \n*\n \n1.0\n\n   \nim\n \n=\n \ncv2\n.\nGaussianBlur\n(\nim\n,\n \n(\nFEATHER_AMOUNT\n,\n \nFEATHER_AMOUNT\n),\n \n0\n)\n\n\n   \nreturn\n \nim\n\n\n\nmask\n \n=\n \nget_face_mask\n(\nim2\n,\n \nlandmarks2\n)\n\n\nwarped_mask\n \n=\n \nwarp_im\n(\nmask\n,\n \nM\n,\n \nim1\n.\nshape\n)\n\n\ncombined_mask\n \n=\n \nnumpy\n.\nmax\n([\nget_face_mask\n(\nim1\n,\n \nlandmarks1\n),\n \nwarped_mask\n],\n\n                         \naxis\n=\n0\n)\n我们来分析一下：\n常规的 get_face_mask() 函数定义是：为一张图像和一个标志矩阵生成一个蒙版。蒙版会画出两个白色的凸多边形：一个是眼睛周围的区域，一个是鼻子和嘴部周围的区域。之后，蒙版的边缘区域向外羽化 11 个像素，这可以帮助消除剩下的不连续部分。\n为图 1 图 2 生成面部蒙版。使用与步骤 2 中的转换，可以使图 2 的蒙版转换至图 1 的坐标空间。\n之后，对所有元素取最大值操作，将这两个蒙版合二为一。这样做是为了保证图 1 的特征也能被覆盖的同时图 2 特征能显示出来。\n最后，将蒙版应用于最终图像：\noutput_im\n \n=\n \nim1\n \n*\n \n(\n1.0\n \n-\n \ncombined_mask\n)\n \n+\n \nwarped_corrected_im2\n \n*\n \ncombined_mask\n哈，换脸成功！\n附：本项目代码地址：\nhttps://\ngithub.com/matthewearl/\nfaceswap/blob/master/faceswap.py\n参考资料：\n \nhttps://\nmatthewearl.github.io/2\n015/07/28/switching-eds-with-python/"},
{"title": "哪些 Python 库让你相见恨晚？", "description": "大量时间（少敲代码），还不赶紧用起来~ 我的其他回答 python如何画出漂亮的地图？ 时间序列数据如何插补缺失值？ 机器学习中的因果关系:", "article": "最近发现一个神奇的库pandas-profiling，\n一行代码\n生成\n超详细数据分析报告\n，实乃我等数据分析从业者的福音哈哈~ \n一键生成超详细数据分析报告\nhttps://www.zhihu.com/video/1143534815029669888\n一般来说，面对一个数据集，我们需要做一些探索性分析 (Exploratory data analysis)，这个过程繁琐而冗杂。以泰坦尼克号数据集为例，传统方法是先用Dataframe.describe()：\nimport pandas as pd\n\ndata = pd.read_csv('https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv')\ndata.describe()\n通过describe()方法，我们对数据集可以有一个大体的认知。然后，通过分析各变量之间的关系（直方图，散点图，柱状图，关联分析等等），我们可以进一步探索这个数据集。EDA这个步骤通常需要耗费大量的时间和精力。如今，有了pandas-profiling库，我们一行代码就可以生成一份超详细的数据分析报告~\nimport pandas_profiling  \n\ndata.profile_report(title='Titanic Dataset')\n具体报告效果如下：\n一键存储为html网页文件，so easy! \nprofile = data.profile_report(title='Titanic Dataset')\nprofile.to_file(output_file='result/titanic_report.html')\n我生成的html网页版数据分析报告请\n点击这里\n。\n最后，虽然pandas-profiling这个库并非完全智能，但是一份详细的数据报告，可以为我们节省大量时间（少敲代码），还不赶紧用起来~\n我的其他回答\npython如何画出漂亮的地图？\n时间序列数据如何插补缺失值？\n机器学习中的因果关系: 从辛普森悖论（常见的统计学谬误）谈起\n让我们跑一个最简单的GAN网络吧！（附Jupyter Notebook 代码）\n欢迎大家关注我的\n机器学习笔记\n专栏，我会用小白也能听懂的语言，为大家讲述机器学习中那些有趣好玩的知识 (*╹▽╹*)\n机器学习笔记"},
{"title": "一张图学会python", "description": "括能力表示无比敬仰。 今天没事逛PythonTab：Python中文开发者社区门户，又看到了这张图，于是果断保存发布出来，侵删。 对于看过几遍入门教程的同学来说", "article": "这张图在知乎上我看到过，但是错过没保存，当时对这图的作者的概括能力表示无比敬仰。\n今天没事逛\nPythonTab：Python中文开发者社区门户\n，又看到了这张图，于是果断保存发布出来，侵删。\n对于\n看过几遍入门教程\n的同学来说，下一步就是进入长时间的实战阶段，这个阶段会对之前似是而非的理解进行修正，会经常出错，bug满天飞。这个时候有这张神图作为辅助，那简直是地图插满眼啊。\n希望能帮助到你。"},
{"title": "Python也能聊微信", "description": "wxpy文档：wxpy: 用 Python 玩微信 github地址：youfou/wxpy 本文已更新微信同名公众号【Python与数据分析】，欢迎关注~", "article": "最近研究微信API，发现个非常好用的python库：wxpy。wxpy基于itchat，使用了 Web 微信的通讯协议，实现了微信登录、收发消息、搜索好友、数据统计等功能。\n这里我们就来介绍一下这个库，并在最后实现一个聊天机器人。\n准备工作\n安装非常简单，从官方源下载安装\npip install -U wxpy\n或者从豆瓣源安装\npip install -U wxpy -i \n\"https://pypi.doubanio.com/simple/\"\n模块初探\n安装完成后，我们来试下几个基本的功能\n1. 扫码登录微信\nfrom\n \nwxpy\n \nimport\n \n*\n\n\nbot\n \n=\n \nBot\n()\n运行上面的程序，会弹出二维码，用手机微信扫一扫即可实现登录。\n但上面的程序有一个缺点，每次运行都要扫二维码。不过wxpy非常贴心地提供了缓存的选项，如下\nbot\n \n=\n \nBot\n(\ncache_path\n=\nTrue\n)\n这样把登录信息保存下来，就不用每次都扫二维码了。\n2. 发送消息\nbot\n.\nfile_helper\n.\nsend\n(\n\"hello\"\n)\n这里的file_helper就是微信的文件传输助手，我们给文件传输助手发送一条消息，可以在手机端收到如下的消息\n3. 接受消息\n我们实现一个收到消息自动回复的功能。\n@bot.register\n()\n\n\ndef\n \nprint_message\n(\nmsg\n):\n\n    \nprint\n(\nmsg\n.\ntext\n)\n\n    \nreturn\n \nmsg\n.\ntext\n\n\n\n# 进入Python命令行，让程序保持运行\n\n\nembed\n()\n强哥打开自己的公众号管理平台，在后端向自己发送消息，就可以收到如下的消息回复\n4. 搜索好友及微信群\n我们来实现一个搜索公司群、定位老板并转发老板消息的功能\nfrom\n \nwxpy\n \nimport\n \n*\n\n\n\nbot\n \n=\n \nBot\n(\ncache_path\n=\nTrue\n)\n\n\n\n# 定位公司群\n\n\ncompany_group\n \n=\n \nbot\n.\ngroups\n()\n.\nsearch\n(\n'公司微信群'\n)[\n0\n]\n\n\n\n# 定位老板\n\n\nboss\n \n=\n \ncompany_group\n.\nsearch\n(\n'老板大名'\n)[\n0\n]\n\n\n\n# 将老板的消息转发到文件传输助手\n\n\n@bot.register\n(\ncompany_group\n)\n\n\ndef\n \nforward_boss_message\n(\nmsg\n):\n\n    \nif\n \nmsg\n.\nmember\n \n==\n \nboss\n:\n\n        \nmsg\n.\nforward\n(\nbot\n.\nfile_helper\n,\n \nprefix\n=\n'老板发言'\n)\n\n\n\n# 堵塞线程\n\n\nembed\n()\n对于老板喜欢在群里面喊话的同学来说，这是一个福音，以后再也不用担心错失老板的重要信息了~~\n数据统计\nwxpy的好友统计功能非常好用，可以很方便地统计好友的地理位置分布和性别分布。\n下面的代码中，强哥统计了下自己的好友的分布情况，并打印出人数最多的10个地区。\nfrom\n \nwxpy\n \nimport\n \n*\n\n\n\nbot\n \n=\n \nBot\n(\ncache_path\n=\nTrue\n)\n\n\nfriends_stat\n \n=\n \nbot\n.\nfriends\n()\n.\nstats\n()\n\n\n\nfriend_loc\n \n=\n \n[]\n \n# 每一个元素是一个二元列表，分别存储地区和人数信息\n\n\nfor\n \nprovince\n,\n \ncount\n \nin\n \nfriends_stat\n[\n\"province\"\n]\n.\niteritems\n():\n\n    \nif\n \nprovince\n \n!=\n \n\"\"\n:\n \n        \nfriend_loc\n.\nappend\n([\nprovince\n,\n \ncount\n])\n\n\n\n# 对人数倒序排序\n\n\nfriend_loc\n.\nsort\n(\nkey\n=\nlambda\n \nx\n:\n \nx\n[\n1\n],\n \nreverse\n=\nTrue\n)\n\n\n\n# 打印人数最多的10个地区\n\n\nfor\n \nitem\n \nin\n \nfriend_loc\n[:\n10\n]:\n\n    \nprint\n \nitem\n[\n0\n],\n \nitem\n[\n1\n]\n统计出来的地区分布数据画成图表如下\n强哥身在上海，大多数的好友也来自上海，上面的图表也如实地反应了这一情况。\n统计性别分布的代码如下\nfor\n \nsex\n,\n \ncount\n \nin\n \nfriends_stat\n[\n\"sex\"\n]\n.\niteritems\n():\n\n    \n# 1代表MALE, 2代表FEMALE\n\n    \nif\n \nsex\n \n==\n \n1\n:\n\n        \nprint\n \n\"MALE \n%d\n\"\n \n%\n \ncount\n\n    \nelif\n \nsex\n \n==\n \n2\n:\n\n        \nprint\n \n\"FEMALE \n%d\n\"\n \n%\n \ncount\n把性别分布的数据生成图表如下\n可以看到好友中男性占了大多数。男性朋友多多，老婆放心多多，嗯~~\n聊天机器人\n有了上面功能简介部分的基础，我们来实现一个聊天机器人。\n聊天机器人基于图灵机器人。图灵机器人可以在\n图灵机器人－中文语境下智能度最高的机器人大脑\n注册账号，并创建机器人。需记下api key，调用图灵API的时候会用到。\n# -*- coding: utf-8 -*-\n\n\nimport\n \njson\n\n\nimport\n \nrequests\n\n\nfrom\n \nwxpy\n \nimport\n \n*\n\n\n\n# 调用图灵机器人API，发送消息并获得机器人的回复\n\n\ndef\n \nauto_reply\n(\ntext\n):\n\n    \nurl\n \n=\n \n\"http://www.tuling123.com/openapi/api\"\n\n    \napi_key\n \n=\n \n\"你的api key\"\n\n    \npayload\n \n=\n \n{\n\n        \n\"key\"\n:\n \napi_key\n,\n\n        \n\"info\"\n:\n \ntext\n,\n\n        \n\"userid\"\n:\n \n\"123456\"\n\n    \n}\n\n    \nr\n \n=\n \nrequests\n.\npost\n(\nurl\n,\n \ndata\n=\njson\n.\ndumps\n(\npayload\n))\n\n    \nresult\n \n=\n \njson\n.\nloads\n(\nr\n.\ncontent\n)\n\n    \nreturn\n \n\"[tuling] \"\n \n+\n \nresult\n[\n\"text\"\n]\n\n\n\nbot\n \n=\n \nBot\n(\nconsole_qr\n=\nTrue\n,\n \ncache_path\n=\nTrue\n)\n\n\n\n@bot.register\n(\nmp\n)\n\n\ndef\n \nforward_message\n(\nmsg\n):\n\n    \nreturn\n \nauto_reply\n(\nmsg\n.\ntext\n)\n\n\n\nembed\n()\n运行上面的程序，发送消息给自己，可以看到如下的对话\n机器人太逗了，上来就要红包，还把我当男朋友了~\n附录\nwxpy文档：\nwxpy: 用 Python 玩微信\ngithub地址：\nyoufou/wxpy\n本文已更新微信同名公众号【Python与数据分析】，欢迎关注~"}
]